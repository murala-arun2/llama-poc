@startuml
package org {
package springframework {
package security {
package access {
package annotation {
interface AnnotationMetadataExtractor    {
  extractAttributes(securityAnnotation : A) : Collection<?extendsConfigAttribute>
}
class Jsr250MethodSecurityMetadataSource extends org.springframework.security.access.method.AbstractFallbackMethodSecurityMetadataSource   {
  defaultRolePrefix : String
  setDefaultRolePrefix(defaultRolePrefix : String) : void
  findAttributes(clazz : Class<?>) : Collection<ConfigAttribute>
  findAttributes(method : Method, targetClass : Class<?>) : Collection<ConfigAttribute>
  getAllConfigAttributes() : Collection<ConfigAttribute>
  processAnnotations(annotations : Annotation[]) : List<ConfigAttribute>
  getRoleWithDefaultPrefix(role : String) : String
}
class Jsr250SecurityConfig extends org.springframework.security.access.SecurityConfig   {
  PERMIT_ALL_ATTRIBUTE : Jsr250SecurityConfig
  DENY_ALL_ATTRIBUTE : Jsr250SecurityConfig
  Jsr250SecurityConfig(role : String) : None
}
class Jsr250Voter    {
  supports(configAttribute : ConfigAttribute) : boolean
  supports(clazz : Class<?>) : boolean
  vote(authentication : Authentication, object : Object, definition : Collection<ConfigAttribute>) : int
}
Jsr250Voter::vote --> org.springframework.security.core.Authentication::getAuthorities : authentication.getAuthorities() 
class SecuredAnnotationSecurityMetadataSource extends org.springframework.security.access.method.AbstractFallbackMethodSecurityMetadataSource   {
  annotationExtractor : AnnotationMetadataExtractor
  annotationType : Class<?extendsAnnotation>
  SecuredAnnotationSecurityMetadataSource() : None
  SecuredAnnotationSecurityMetadataSource(annotationMetadataExtractor : AnnotationMetadataExtractor) : None
  findAttributes(clazz : Class<?>) : Collection<ConfigAttribute>
  findAttributes(method : Method, targetClass : Class<?>) : Collection<ConfigAttribute>
  getAllConfigAttributes() : Collection<ConfigAttribute>
  processAnnotation(annotation : Annotation) : Collection<ConfigAttribute>
}
class SecuredAnnotationMetadataExtractor    {
  extractAttributes(secured : Secured) : Collection<ConfigAttribute>
}
}
package event {
class AbstractAuthorizationEvent extends org.springframework.context.ApplicationEvent   {
  AbstractAuthorizationEvent(secureObject : Object) : None
}
class AuthenticationCredentialsNotFoundEvent    {
  credentialsNotFoundException : AuthenticationCredentialsNotFoundException
  configAttribs : Collection<ConfigAttribute>
  AuthenticationCredentialsNotFoundEvent(secureObject : Object, attributes : Collection<ConfigAttribute>, credentialsNotFoundException : AuthenticationCredentialsNotFoundException) : None
  getConfigAttributes() : Collection<ConfigAttribute>
  getCredentialsNotFoundException() : AuthenticationCredentialsNotFoundException
}
class AuthorizationFailureEvent    {
  accessDeniedException : AccessDeniedException
  authentication : Authentication
  configAttributes : Collection<ConfigAttribute>
  AuthorizationFailureEvent(secureObject : Object, attributes : Collection<ConfigAttribute>, authentication : Authentication, accessDeniedException : AccessDeniedException) : None
  getAccessDeniedException() : AccessDeniedException
  getAuthentication() : Authentication
  getConfigAttributes() : Collection<ConfigAttribute>
}
class AuthorizedEvent    {
  authentication : Authentication
  configAttributes : Collection<ConfigAttribute>
  AuthorizedEvent(secureObject : Object, attributes : Collection<ConfigAttribute>, authentication : Authentication) : None
  getAuthentication() : Authentication
  getConfigAttributes() : Collection<ConfigAttribute>
}
class LoggerListener    {
  logger : Log
  onApplicationEvent(event : AbstractAuthorizationEvent) : void
  onAuthenticationCredentialsNotFoundEvent(authEvent : AuthenticationCredentialsNotFoundEvent) : void
  onPublicInvocationEvent(event : PublicInvocationEvent) : void
  onAuthorizedEvent(authEvent : AuthorizedEvent) : void
  onAuthorizationFailureEvent(authEvent : AuthorizationFailureEvent) : void
}
class PublicInvocationEvent    {
  PublicInvocationEvent(secureObject : Object) : None
}
}
package expression {
package method {
class AbstractExpressionBasedMethodConfigAttribute  implements org.springframework.security.access.ConfigAttribute  {
  filterExpression : Expression
  authorizeExpression : Expression
  AbstractExpressionBasedMethodConfigAttribute(filterExpression : String, authorizeExpression : String) : None
  AbstractExpressionBasedMethodConfigAttribute(filterExpression : Expression, authorizeExpression : Expression) : None
  getFilterExpression() : Expression
  getAuthorizeExpression() : Expression
  getAttribute() : String
}
class DefaultMethodSecurityExpressionHandler    {
  logger : Log
  trustResolver : AuthenticationTrustResolver
  parameterNameDiscoverer : ParameterNameDiscoverer
  permissionCacheOptimizer : PermissionCacheOptimizer
  defaultRolePrefix : String
  DefaultMethodSecurityExpressionHandler() : None
  createEvaluationContextInternal(auth : Authentication, mi : MethodInvocation) : StandardEvaluationContext
  createEvaluationContext(authentication : Supplier<Authentication>, mi : MethodInvocation) : EvaluationContext
  createSecurityExpressionRoot(authentication : Authentication, invocation : MethodInvocation) : MethodSecurityExpressionOperations
  createSecurityExpressionRoot(authentication : Supplier<Authentication>, invocation : MethodInvocation) : MethodSecurityExpressionOperations
  filter(filterTarget : Object, filterExpression : Expression, ctx : EvaluationContext) : Object
  filterCollection(filterTarget : Collection<T>, filterExpression : Expression, ctx : EvaluationContext, rootObject : MethodSecurityExpressionOperations) : Object
  filterArray(filterTarget : Object[], filterExpression : Expression, ctx : EvaluationContext, rootObject : MethodSecurityExpressionOperations) : Object
  filterMap(filterTarget : Map<K,V>, filterExpression : Expression, ctx : EvaluationContext, rootObject : MethodSecurityExpressionOperations) : Object
  filterStream(filterTarget : Stream<?>, filterExpression : Expression, ctx : EvaluationContext, rootObject : MethodSecurityExpressionOperations) : Object
  setTrustResolver(trustResolver : AuthenticationTrustResolver) : void
  getTrustResolver() : AuthenticationTrustResolver
  setParameterNameDiscoverer(parameterNameDiscoverer : ParameterNameDiscoverer) : void
  getParameterNameDiscoverer() : ParameterNameDiscoverer
  setPermissionCacheOptimizer(permissionCacheOptimizer : PermissionCacheOptimizer) : void
  setReturnObject(returnObject : Object, ctx : EvaluationContext) : void
  setDefaultRolePrefix(defaultRolePrefix : String) : void
  getDefaultRolePrefix() : String
}
DefaultMethodSecurityExpressionHandler::filterCollection --> org.springframework.security.access.PermissionCacheOptimizer::cachePermissionsFor : permissionCacheOptimizer.cachePermissionsFor(rootObject.getAuthentication(),filterTarget) 
DefaultMethodSecurityExpressionHandler::filterArray --> org.springframework.security.access.PermissionCacheOptimizer::cachePermissionsFor : permissionCacheOptimizer.cachePermissionsFor(rootObject.getAuthentication(),Arrays.asList(filterTarget)) 
class ExpressionBasedAnnotationAttributeFactory  implements org.springframework.security.access.prepost.PrePostInvocationAttributeFactory  {
  parserLock : Object
  parser : ExpressionParser
  handler : MethodSecurityExpressionHandler
  ExpressionBasedAnnotationAttributeFactory(handler : MethodSecurityExpressionHandler) : None
  createPreInvocationAttribute(preFilterAttribute : String, filterObject : String, preAuthorizeAttribute : String) : PreInvocationAttribute
  createPostInvocationAttribute(postFilterAttribute : String, postAuthorizeAttribute : String) : PostInvocationAttribute
  getParser() : ExpressionParser
}
ExpressionBasedAnnotationAttributeFactory::createPreInvocationAttribute --> org.springframework.expression.ExpressionParser::parseExpression : parser.parseExpression(preAuthorizeAttribute) 
ExpressionBasedAnnotationAttributeFactory::createPreInvocationAttribute --> org.springframework.expression.ExpressionParser::parseExpression : parser.parseExpression("permitAll") 
ExpressionBasedAnnotationAttributeFactory::createPreInvocationAttribute --> org.springframework.expression.ExpressionParser::parseExpression : parser.parseExpression(preFilterAttribute) 
ExpressionBasedAnnotationAttributeFactory::createPostInvocationAttribute --> org.springframework.expression.ExpressionParser::parseExpression : parser.parseExpression(postAuthorizeAttribute) 
ExpressionBasedAnnotationAttributeFactory::createPostInvocationAttribute --> org.springframework.expression.ExpressionParser::parseExpression : parser.parseExpression(postFilterAttribute) 
class ExpressionBasedPostInvocationAdvice  implements org.springframework.security.access.prepost.PostInvocationAuthorizationAdvice  {
  logger : Log
  expressionHandler : MethodSecurityExpressionHandler
  ExpressionBasedPostInvocationAdvice(expressionHandler : MethodSecurityExpressionHandler) : None
  after(authentication : Authentication, mi : MethodInvocation, postAttr : PostInvocationAttribute, returnedObject : Object) : Object
}
class ExpressionBasedPreInvocationAdvice  implements org.springframework.security.access.prepost.PreInvocationAuthorizationAdvice  {
  expressionHandler : MethodSecurityExpressionHandler
  before(authentication : Authentication, mi : MethodInvocation, attr : PreInvocationAttribute) : boolean
  findFilterTarget(filterTargetName : String, ctx : EvaluationContext, invocation : MethodInvocation) : Object
  setExpressionHandler(expressionHandler : MethodSecurityExpressionHandler) : void
}
class MethodSecurityEvaluationContext extends org.springframework.context.expression.MethodBasedEvaluationContext   {
  MethodSecurityEvaluationContext(user : Authentication, mi : MethodInvocation) : None
  MethodSecurityEvaluationContext(user : Authentication, mi : MethodInvocation, parameterNameDiscoverer : ParameterNameDiscoverer) : None
  MethodSecurityEvaluationContext(root : MethodSecurityExpressionOperations, mi : MethodInvocation, parameterNameDiscoverer : ParameterNameDiscoverer) : None
  getSpecificMethod(mi : MethodInvocation) : Method
}
MethodSecurityEvaluationContext::MethodSecurityEvaluationContext --> org.aopalliance.intercept.MethodInvocation::getThis : mi.getThis() 
MethodSecurityEvaluationContext::MethodSecurityEvaluationContext --> org.aopalliance.intercept.MethodInvocation::getArguments : mi.getArguments() 
MethodSecurityEvaluationContext::MethodSecurityEvaluationContext --> org.aopalliance.intercept.MethodInvocation::getArguments : mi.getArguments() 
MethodSecurityEvaluationContext::getSpecificMethod --> org.aopalliance.intercept.MethodInvocation::getMethod : mi.getMethod() 
MethodSecurityEvaluationContext::getSpecificMethod --> org.aopalliance.intercept.MethodInvocation::getThis : mi.getThis() 
interface MethodSecurityExpressionHandler    {
  filter(filterTarget : Object, filterExpression : Expression, ctx : EvaluationContext) : Object
  setReturnObject(returnObject : Object, ctx : EvaluationContext) : void
}
interface MethodSecurityExpressionOperations    {
  setFilterObject(filterObject : Object) : void
  getFilterObject() : Object
  setReturnObject(returnObject : Object) : void
  getReturnObject() : Object
  getThis() : Object
}
class MethodSecurityExpressionRoot extends org.springframework.security.access.expression.SecurityExpressionRoot   {
  filterObject : Object
  returnObject : Object
  target : Object
  MethodSecurityExpressionRoot(a : Authentication) : None
  MethodSecurityExpressionRoot(authentication : Supplier<Authentication>) : None
  setFilterObject(filterObject : Object) : void
  getFilterObject() : Object
  setReturnObject(returnObject : Object) : void
  getReturnObject() : Object
  setThis(target : Object) : void
  getThis() : Object
}
class PostInvocationExpressionAttribute  implements org.springframework.security.access.prepost.PostInvocationAttribute  {
  PostInvocationExpressionAttribute(filterExpression : String, authorizeExpression : String) : None
  PostInvocationExpressionAttribute(filterExpression : Expression, authorizeExpression : Expression) : None
  toString() : String
}
class PreInvocationExpressionAttribute  implements org.springframework.security.access.prepost.PreInvocationAttribute  {
  filterTarget : String
  PreInvocationExpressionAttribute(filterExpression : String, filterTarget : String, authorizeExpression : String) : None
  PreInvocationExpressionAttribute(filterExpression : Expression, filterTarget : String, authorizeExpression : Expression) : None
  getFilterTarget() : String
  toString() : String
}
}
class AbstractSecurityExpressionHandler    {
  expressionParser : ExpressionParser
  beanResolver : BeanResolver
  roleHierarchy : RoleHierarchy
  permissionEvaluator : PermissionEvaluator
  getExpressionParser() : ExpressionParser
  setExpressionParser(expressionParser : ExpressionParser) : void
  createEvaluationContext(authentication : Authentication, invocation : T) : EvaluationContext
  createEvaluationContextInternal(authentication : Authentication, invocation : T) : StandardEvaluationContext
  createSecurityExpressionRoot(authentication : Authentication, invocation : T) : SecurityExpressionOperations
  getRoleHierarchy() : RoleHierarchy
  setRoleHierarchy(roleHierarchy : RoleHierarchy) : void
  getPermissionEvaluator() : PermissionEvaluator
  setPermissionEvaluator(permissionEvaluator : PermissionEvaluator) : void
  getBeanResolver() : BeanResolver
  setApplicationContext(applicationContext : ApplicationContext) : void
}
class DenyAllPermissionEvaluator  implements org.springframework.security.access.PermissionEvaluator  {
  logger : Log
  hasPermission(authentication : Authentication, target : Object, permission : Object) : boolean
  hasPermission(authentication : Authentication, targetId : Serializable, targetType : String, permission : Object) : boolean
}
DenyAllPermissionEvaluator::hasPermission --> org.springframework.security.core.Authentication::getName : authentication.getName() 
DenyAllPermissionEvaluator::hasPermission --> org.springframework.security.core.Authentication::getName : authentication.getName() 
class ExpressionUtils    {
  ExpressionUtils() : None
  evaluateAsBoolean(expr : Expression, ctx : EvaluationContext) : boolean
}
ExpressionUtils::evaluateAsBoolean --> org.springframework.expression.Expression::getValue : expr.getValue(ctx,Boolean.class) 
ExpressionUtils::evaluateAsBoolean --> org.springframework.expression.Expression::getExpressionString : expr.getExpressionString() 
interface SecurityExpressionHandler    {
  getExpressionParser() : ExpressionParser
  createEvaluationContext(authentication : Authentication, invocation : T) : EvaluationContext
  createEvaluationContext(authentication : Supplier<Authentication>, invocation : T) : EvaluationContext
}
interface SecurityExpressionOperations    {
  getAuthentication() : Authentication
  hasAuthority(authority : String) : boolean
  hasAnyAuthority() : boolean
  hasRole(role : String) : boolean
  hasAnyRole() : boolean
  permitAll() : boolean
  denyAll() : boolean
  isAnonymous() : boolean
  isAuthenticated() : boolean
  isRememberMe() : boolean
  isFullyAuthenticated() : boolean
  hasPermission(target : Object, permission : Object) : boolean
  hasPermission(targetId : Object, targetType : String, permission : Object) : boolean
}
class SecurityExpressionRoot    {
  authentication : Supplier<Authentication>
  trustResolver : AuthenticationTrustResolver
  roleHierarchy : RoleHierarchy
  roles : Set<String>
  defaultRolePrefix : String
  permitAll : boolean
  denyAll : boolean
  permissionEvaluator : PermissionEvaluator
  read : String
  write : String
  create : String
  delete : String
  admin : String
  SecurityExpressionRoot(authentication : Authentication) : None
  SecurityExpressionRoot(authentication : Supplier<Authentication>) : None
  hasAuthority(authority : String) : boolean
  hasAnyAuthority() : boolean
  hasRole(role : String) : boolean
  hasAnyRole() : boolean
  hasAnyAuthorityName(prefix : String) : boolean
  getAuthentication() : Authentication
  permitAll() : boolean
  denyAll() : boolean
  isAnonymous() : boolean
  isAuthenticated() : boolean
  isRememberMe() : boolean
  isFullyAuthenticated() : boolean
  getPrincipal() : Object
  setTrustResolver(trustResolver : AuthenticationTrustResolver) : void
  setRoleHierarchy(roleHierarchy : RoleHierarchy) : void
  setDefaultRolePrefix(defaultRolePrefix : String) : void
  getAuthoritySet() : Set<String>
  hasPermission(target : Object, permission : Object) : boolean
  hasPermission(targetId : Object, targetType : String, permission : Object) : boolean
  setPermissionEvaluator(permissionEvaluator : PermissionEvaluator) : void
  getRoleWithDefaultPrefix(defaultRolePrefix : String, role : String) : String
}
SecurityExpressionRoot::isAnonymous --> org.springframework.security.authentication.AuthenticationTrustResolver::isAnonymous : trustResolver.isAnonymous(getAuthentication()) 
SecurityExpressionRoot::isAuthenticated --> org.springframework.security.authentication.AuthenticationTrustResolver::isAuthenticated : trustResolver.isAuthenticated(getAuthentication()) 
SecurityExpressionRoot::isRememberMe --> org.springframework.security.authentication.AuthenticationTrustResolver::isRememberMe : trustResolver.isRememberMe(getAuthentication()) 
SecurityExpressionRoot::isFullyAuthenticated --> org.springframework.security.authentication.AuthenticationTrustResolver::isFullyAuthenticated : trustResolver.isFullyAuthenticated(authentication) 
SecurityExpressionRoot::getAuthoritySet --> org.springframework.security.access.hierarchicalroles.RoleHierarchy::getReachableGrantedAuthorities : roleHierarchy.getReachableGrantedAuthorities(userAuthorities) 
SecurityExpressionRoot::hasPermission --> org.springframework.security.access.PermissionEvaluator::hasPermission : permissionEvaluator.hasPermission(getAuthentication(),target,permission) 
SecurityExpressionRoot::hasPermission --> org.springframework.security.access.PermissionEvaluator::hasPermission : permissionEvaluator.hasPermission(getAuthentication(),(Serializable)targetId,targetType,permission) 
}
package hierarchicalroles {
class CycleInRoleHierarchyException    {
  serialVersionUID : long
  CycleInRoleHierarchyException() : None
}
class NullRoleHierarchy    {
  getReachableGrantedAuthorities(authorities : Collection<?extendsGrantedAuthority>) : Collection<?extendsGrantedAuthority>
}
interface RoleHierarchy    {
  getReachableGrantedAuthorities(authorities : Collection<?extendsGrantedAuthority>) : Collection<?extendsGrantedAuthority>
}
class RoleHierarchyAuthoritiesMapper  implements org.springframework.security.core.authority.mapping.GrantedAuthoritiesMapper  {
  roleHierarchy : RoleHierarchy
  RoleHierarchyAuthoritiesMapper(roleHierarchy : RoleHierarchy) : None
  mapAuthorities(authorities : Collection<?extendsGrantedAuthority>) : Collection<?extendsGrantedAuthority>
}
class RoleHierarchyImpl    {
  logger : Log
  rolesReachableInOneOrMoreStepsMap : Map<String,Set<GrantedAuthority>>
  RoleHierarchyImpl() : None
  RoleHierarchyImpl(hierarchy : Map<String,Set<GrantedAuthority>>) : None
  fromHierarchy(hierarchy : String) : RoleHierarchyImpl
  withDefaultRolePrefix() : Builder
  withRolePrefix(rolePrefix : String) : Builder
  setHierarchy(roleHierarchyStringRepresentation : String) : void
  getReachableGrantedAuthorities(authorities : Collection<?extendsGrantedAuthority>) : Collection<GrantedAuthority>
  buildRolesReachableInOneStepMap(hierarchy : String) : Map<String,Set<GrantedAuthority>>
  buildRolesReachableInOneOrMoreStepsMap(hierarchy : Map<String,Set<GrantedAuthority>>) : Map<String,Set<GrantedAuthority>>
}
class Builder    {
  rolePrefix : String
  hierarchy : Map<String,Set<GrantedAuthority>>
  Builder(rolePrefix : String) : None
  role(role : String) : ImpliedRoles
  build() : RoleHierarchyImpl
  addHierarchy(role : String) : Builder
}
class ImpliedRoles    {
  role : String
  ImpliedRoles(role : String) : None
  implies() : Builder
}
class RoleHierarchyUtils    {
  RoleHierarchyUtils() : None
  roleHierarchyFromMap(roleHierarchyMap : Map<String,List<String>>) : String
}
}
package intercept {
package aopalliance {
class MethodSecurityInterceptor extends org.springframework.security.access.intercept.AbstractSecurityInterceptor implements org.aopalliance.intercept.MethodInterceptor  {
  securityMetadataSource : MethodSecurityMetadataSource
  getSecureObjectClass() : Class<?>
  invoke(mi : MethodInvocation) : Object
  getSecurityMetadataSource() : MethodSecurityMetadataSource
  obtainSecurityMetadataSource() : SecurityMetadataSource
  setSecurityMetadataSource(newSource : MethodSecurityMetadataSource) : void
}
class MethodSecurityMetadataSourceAdvisor extends org.springframework.aop.support.AbstractPointcutAdvisor implements org.springframework.beans.factory.BeanFactoryAware  {
  attributeSource : MethodSecurityMetadataSource
  interceptor : MethodInterceptor
  pointcut : Pointcut
  beanFactory : BeanFactory
  adviceBeanName : String
  metadataSourceBeanName : String
  adviceMonitor : Object
  MethodSecurityMetadataSourceAdvisor(adviceBeanName : String, attributeSource : MethodSecurityMetadataSource, attributeSourceBeanName : String) : None
  getPointcut() : Pointcut
  getAdvice() : Advice
  setBeanFactory(beanFactory : BeanFactory) : void
  readObject(ois : ObjectInputStream) : void
}
MethodSecurityMetadataSourceAdvisor::getAdvice --> org.springframework.beans.factory.BeanFactory::getBean : beanFactory.getBean(adviceBeanName,MethodInterceptor.class) 
MethodSecurityMetadataSourceAdvisor::readObject --> java.io.ObjectInputStream::defaultReadObject : ois.defaultReadObject() 
MethodSecurityMetadataSourceAdvisor::readObject --> org.springframework.beans.factory.BeanFactory::getBean : beanFactory.getBean(metadataSourceBeanName,MethodSecurityMetadataSource.class) 
class MethodSecurityMetadataSourcePointcut    {
  matches(m : Method, targetClass : Class<?>) : boolean
}
}
package aspectj {
interface AspectJCallback    {
  proceedWithObject() : Object
}
class AspectJMethodSecurityInterceptor extends org.springframework.security.access.intercept.aopalliance.MethodSecurityInterceptor   {
  invoke(jp : JoinPoint) : Object
  invoke(jp : JoinPoint, advisorProceed : AspectJCallback) : Object
}
class MethodInvocationAdapter  implements org.aopalliance.intercept.MethodInvocation  {
  jp : ProceedingJoinPoint
  method : Method
  target : Object
  MethodInvocationAdapter(jp : JoinPoint) : None
  findMethod(name : String, declaringType : Class<?>, params : Class<?>[]) : Method
  getMethod() : Method
  getArguments() : Object[]
  getStaticPart() : AccessibleObject
  getThis() : Object
  proceed() : Object
}
MethodInvocationAdapter::MethodInvocationAdapter --> org.aspectj.lang.ProceedingJoinPoint::getTarget : jp.getTarget() 
MethodInvocationAdapter::MethodInvocationAdapter --> org.aspectj.lang.ProceedingJoinPoint::getTarget : jp.getTarget() 
MethodInvocationAdapter::MethodInvocationAdapter --> org.aspectj.lang.ProceedingJoinPoint::getSignature : jp.getSignature().getDeclaringType() 
MethodInvocationAdapter::MethodInvocationAdapter --> org.aspectj.lang.ProceedingJoinPoint::getSignature : jp.getSignature() 
MethodInvocationAdapter::MethodInvocationAdapter --> org.aspectj.lang.ProceedingJoinPoint::getStaticPart : jp.getStaticPart().getSignature().getName() 
MethodInvocationAdapter::MethodInvocationAdapter --> org.aspectj.lang.ProceedingJoinPoint::getStaticPart : jp.getStaticPart().getSignature() 
MethodInvocationAdapter::MethodInvocationAdapter --> org.aspectj.lang.ProceedingJoinPoint::getStaticPart : jp.getStaticPart() 
MethodInvocationAdapter::MethodInvocationAdapter --> org.aspectj.lang.ProceedingJoinPoint::getStaticPart : jp.getStaticPart().getSignature() 
MethodInvocationAdapter::MethodInvocationAdapter --> org.aspectj.lang.ProceedingJoinPoint::getStaticPart : jp.getStaticPart() 
MethodInvocationAdapter::MethodInvocationAdapter --> org.aspectj.lang.ProceedingJoinPoint::getStaticPart : jp.getStaticPart().getSignature().getDeclaringType() 
MethodInvocationAdapter::MethodInvocationAdapter --> org.aspectj.lang.ProceedingJoinPoint::getStaticPart : jp.getStaticPart().getSignature() 
MethodInvocationAdapter::MethodInvocationAdapter --> org.aspectj.lang.ProceedingJoinPoint::getStaticPart : jp.getStaticPart() 
MethodInvocationAdapter::getArguments --> org.aspectj.lang.ProceedingJoinPoint::getArgs : jp.getArgs() 
MethodInvocationAdapter::proceed --> org.aspectj.lang.ProceedingJoinPoint::proceed : jp.proceed() 
}
class AbstractSecurityInterceptor    {
  logger : Log
  messages : MessageSourceAccessor
  securityContextHolderStrategy : SecurityContextHolderStrategy
  eventPublisher : ApplicationEventPublisher
  accessDecisionManager : AccessDecisionManager
  afterInvocationManager : AfterInvocationManager
  authenticationManager : AuthenticationManager
  runAsManager : RunAsManager
  alwaysReauthenticate : boolean
  rejectPublicInvocations : boolean
  validateConfigAttributes : boolean
  publishAuthorizationSuccess : boolean
  afterPropertiesSet() : void
  validateAttributeDefs(attributeDefs : Collection<ConfigAttribute>) : void
  beforeInvocation(object : Object) : InterceptorStatusToken
  attemptAuthorization(object : Object, attributes : Collection<ConfigAttribute>, authenticated : Authentication) : void
  finallyInvocation(token : InterceptorStatusToken) : void
  afterInvocation(token : InterceptorStatusToken, returnedObject : Object) : Object
  authenticateIfRequired() : Authentication
  credentialsNotFound(reason : String, secureObject : Object, configAttribs : Collection<ConfigAttribute>) : void
  getAccessDecisionManager() : AccessDecisionManager
  getAfterInvocationManager() : AfterInvocationManager
  getAuthenticationManager() : AuthenticationManager
  getRunAsManager() : RunAsManager
  getSecureObjectClass() : Class<?>
  isAlwaysReauthenticate() : boolean
  isRejectPublicInvocations() : boolean
  isValidateConfigAttributes() : boolean
  obtainSecurityMetadataSource() : SecurityMetadataSource
  setSecurityContextHolderStrategy(securityContextHolderStrategy : SecurityContextHolderStrategy) : void
  setAccessDecisionManager(accessDecisionManager : AccessDecisionManager) : void
  setAfterInvocationManager(afterInvocationManager : AfterInvocationManager) : void
  setAlwaysReauthenticate(alwaysReauthenticate : boolean) : void
  setApplicationEventPublisher(applicationEventPublisher : ApplicationEventPublisher) : void
  setAuthenticationManager(newManager : AuthenticationManager) : void
  setMessageSource(messageSource : MessageSource) : void
  setPublishAuthorizationSuccess(publishAuthorizationSuccess : boolean) : void
  setRejectPublicInvocations(rejectPublicInvocations : boolean) : void
  setRunAsManager(runAsManager : RunAsManager) : void
  setValidateConfigAttributes(validateConfigAttributes : boolean) : void
  publishEvent(event : ApplicationEvent) : void
}
AbstractSecurityInterceptor::afterPropertiesSet --> org.springframework.security.access.AccessDecisionManager::supports : accessDecisionManager.supports(getSecureObjectClass()) 
AbstractSecurityInterceptor::validateAttributeDefs --> org.springframework.security.access.AccessDecisionManager::supports : accessDecisionManager.supports(attr) 
AbstractSecurityInterceptor::beforeInvocation --> org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : securityContextHolderStrategy.getContext().getAuthentication() 
AbstractSecurityInterceptor::beforeInvocation --> org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : securityContextHolderStrategy.getContext() 
AbstractSecurityInterceptor::beforeInvocation --> org.springframework.context.support.MessageSourceAccessor::getMessage : messages.getMessage("AbstractSecurityInterceptor.authenticationNotFound","An Authentication object was not found in the SecurityContext") 
AbstractSecurityInterceptor::beforeInvocation --> org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : securityContextHolderStrategy.getContext() 
AbstractSecurityInterceptor::beforeInvocation --> org.springframework.security.core.context.SecurityContextHolderStrategy::createEmptyContext : securityContextHolderStrategy.createEmptyContext() 
AbstractSecurityInterceptor::beforeInvocation --> org.springframework.security.core.context.SecurityContextHolderStrategy::setContext : securityContextHolderStrategy.setContext(newCtx) 
AbstractSecurityInterceptor::beforeInvocation --> org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : securityContextHolderStrategy.getContext() 
AbstractSecurityInterceptor::attemptAuthorization --> org.springframework.security.access.AccessDecisionManager::decide : accessDecisionManager.decide(authenticated,object,attributes) 
AbstractSecurityInterceptor::finallyInvocation --> org.springframework.security.core.context.SecurityContextHolderStrategy::setContext : securityContextHolderStrategy.setContext(token.getSecurityContext()) 
AbstractSecurityInterceptor::authenticateIfRequired --> org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : securityContextHolderStrategy.getContext().getAuthentication() 
AbstractSecurityInterceptor::authenticateIfRequired --> org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : securityContextHolderStrategy.getContext() 
AbstractSecurityInterceptor::authenticateIfRequired --> org.springframework.security.authentication.AuthenticationManager::authenticate : authenticationManager.authenticate(authentication) 
AbstractSecurityInterceptor::authenticateIfRequired --> org.springframework.security.core.context.SecurityContextHolderStrategy::createEmptyContext : securityContextHolderStrategy.createEmptyContext() 
AbstractSecurityInterceptor::authenticateIfRequired --> org.springframework.security.core.context.SecurityContextHolderStrategy::setContext : securityContextHolderStrategy.setContext(context) 
AbstractSecurityInterceptor::publishEvent --> org.springframework.context.ApplicationEventPublisher::publishEvent : eventPublisher.publishEvent(event) 
class NoOpAuthenticationManager    {
  authenticate(authentication : Authentication) : Authentication
}
interface AfterInvocationManager    {
  decide(authentication : Authentication, object : Object, attributes : Collection<ConfigAttribute>, returnedObject : Object) : Object
  supports(attribute : ConfigAttribute) : boolean
  supports(clazz : Class<?>) : boolean
}
class AfterInvocationProviderManager    {
  logger : Log
  providers : List<AfterInvocationProvider>
  afterPropertiesSet() : void
  decide(authentication : Authentication, object : Object, config : Collection<ConfigAttribute>, returnedObject : Object) : Object
  getProviders() : List<AfterInvocationProvider>
  setProviders(newList : List<?>) : void
  checkIfValidList(listToCheck : List<?>) : void
  supports(attribute : ConfigAttribute) : boolean
  supports(clazz : Class<?>) : boolean
}
class InterceptorStatusToken    {
  securityContext : SecurityContext
  attr : Collection<ConfigAttribute>
  secureObject : Object
  contextHolderRefreshRequired : boolean
  InterceptorStatusToken(securityContext : SecurityContext, contextHolderRefreshRequired : boolean, attributes : Collection<ConfigAttribute>, secureObject : Object) : None
  getAttributes() : Collection<ConfigAttribute>
  getSecurityContext() : SecurityContext
  getSecureObject() : Object
  isContextHolderRefreshRequired() : boolean
}
class MethodInvocationPrivilegeEvaluator  implements org.springframework.beans.factory.InitializingBean  {
  logger : Log
  securityInterceptor : AbstractSecurityInterceptor
  afterPropertiesSet() : void
  isAllowed(invocation : MethodInvocation, authentication : Authentication) : boolean
  setSecurityInterceptor(securityInterceptor : AbstractSecurityInterceptor) : void
}
class NullRunAsManager    {
  buildRunAs(authentication : Authentication, object : Object, config : Collection<ConfigAttribute>) : Authentication
  supports(attribute : ConfigAttribute) : boolean
  supports(clazz : Class<?>) : boolean
}
class RunAsImplAuthenticationProvider    {
  messages : MessageSourceAccessor
  key : String
  afterPropertiesSet() : void
  authenticate(authentication : Authentication) : Authentication
  getKey() : String
  setKey(key : String) : void
  setMessageSource(messageSource : MessageSource) : void
  supports(authentication : Class<?>) : boolean
}
RunAsImplAuthenticationProvider::authenticate --> org.springframework.context.support.MessageSourceAccessor::getMessage : messages.getMessage("RunAsImplAuthenticationProvider.incorrectKey","The presented RunAsUserToken does not contain the expected key") 
interface RunAsManager    {
  buildRunAs(authentication : Authentication, object : Object, attributes : Collection<ConfigAttribute>) : Authentication
  supports(attribute : ConfigAttribute) : boolean
  supports(clazz : Class<?>) : boolean
}
class RunAsManagerImpl    {
  key : String
  rolePrefix : String
  afterPropertiesSet() : void
  buildRunAs(authentication : Authentication, object : Object, attributes : Collection<ConfigAttribute>) : Authentication
  getKey() : String
  getRolePrefix() : String
  setKey(key : String) : void
  setRolePrefix(rolePrefix : String) : void
  supports(attribute : ConfigAttribute) : boolean
  supports(clazz : Class<?>) : boolean
}
class RunAsUserToken extends org.springframework.security.authentication.AbstractAuthenticationToken   {
  serialVersionUID : long
  originalAuthentication : Class<?extendsAuthentication>
  credentials : Object
  principal : Object
  keyHash : int
  RunAsUserToken(key : String, principal : Object, credentials : Object, authorities : Collection<?extendsGrantedAuthority>, originalAuthentication : Class<?extendsAuthentication>) : None
  getCredentials() : Object
  getKeyHash() : int
  getOriginalAuthentication() : Class<?extendsAuthentication>
  getPrincipal() : Object
  toString() : String
}
}
package method {
class AbstractFallbackMethodSecurityMetadataSource    {
  getAttributes(method : Method, targetClass : Class<?>) : Collection<ConfigAttribute>
  findAttributes(method : Method, targetClass : Class<?>) : Collection<ConfigAttribute>
  findAttributes(clazz : Class<?>) : Collection<ConfigAttribute>
}
class AbstractMethodSecurityMetadataSource    {
  logger : Log
  getAttributes(object : Object) : Collection<ConfigAttribute>
  supports(clazz : Class<?>) : boolean
}
class DelegatingMethodSecurityMetadataSource    {
  NULL_CONFIG_ATTRIBUTE : List<ConfigAttribute>
  methodSecurityMetadataSources : List<MethodSecurityMetadataSource>
  attributeCache : Map<DefaultCacheKey,Collection<ConfigAttribute>>
  DelegatingMethodSecurityMetadataSource(methodSecurityMetadataSources : List<MethodSecurityMetadataSource>) : None
  getAttributes(method : Method, targetClass : Class<?>) : Collection<ConfigAttribute>
  getAllConfigAttributes() : Collection<ConfigAttribute>
  getMethodSecurityMetadataSources() : List<MethodSecurityMetadataSource>
}
class DefaultCacheKey    {
  method : Method
  targetClass : Class<?>
  DefaultCacheKey(method : Method, targetClass : Class<?>) : None
  equals(other : Object) : boolean
  hashCode() : int
  toString() : String
}
class MapBasedMethodSecurityMetadataSource  implements org.springframework.beans.factory.BeanClassLoaderAware  {
  beanClassLoader : ClassLoader
  methodMap : Map<RegisteredMethod,List<ConfigAttribute>>
  nameMap : Map<RegisteredMethod,String>
  MapBasedMethodSecurityMetadataSource() : None
  MapBasedMethodSecurityMetadataSource(methodMap : Map<String,List<ConfigAttribute>>) : None
  findAttributes(clazz : Class<?>) : Collection<ConfigAttribute>
  findAttributes(method : Method, targetClass : Class<?>) : Collection<ConfigAttribute>
  findAttributesSpecifiedAgainst(method : Method, clazz : Class<?>) : List<ConfigAttribute>
  addSecureMethod(name : String, attr : List<ConfigAttribute>) : void
  addSecureMethod(javaType : Class<?>, mappedName : String, attr : List<ConfigAttribute>) : void
  registerAllMatchingMethods(javaType : Class<?>, attr : List<ConfigAttribute>, name : String, matchingMethods : List<Method>) : void
  addSecureMethod(javaType : Class<?>, method : Method, attr : List<ConfigAttribute>) : void
  addSecureMethod(method : RegisteredMethod, attr : List<ConfigAttribute>) : void
  getAllConfigAttributes() : Collection<ConfigAttribute>
  isMatch(methodName : String, mappedName : String) : boolean
  setBeanClassLoader(beanClassLoader : ClassLoader) : void
  getMethodMapSize() : int
}
class RegisteredMethod    {
  method : Method
  registeredJavaType : Class<?>
  RegisteredMethod(method : Method, registeredJavaType : Class<?>) : None
  equals(obj : Object) : boolean
  hashCode() : int
  toString() : String
}
interface MethodSecurityMetadataSource    {
  getAttributes(method : Method, targetClass : Class<?>) : Collection<ConfigAttribute>
}
}
package prepost {
class PostInvocationAdviceProvider  implements org.springframework.security.access.AfterInvocationProvider  {
  logger : Log
  postAdvice : PostInvocationAuthorizationAdvice
  PostInvocationAdviceProvider(postAdvice : PostInvocationAuthorizationAdvice) : None
  decide(authentication : Authentication, object : Object, config : Collection<ConfigAttribute>, returnedObject : Object) : Object
  findPostInvocationAttribute(config : Collection<ConfigAttribute>) : PostInvocationAttribute
  supports(attribute : ConfigAttribute) : boolean
  supports(clazz : Class<?>) : boolean
}
interface PostInvocationAttribute    {
}
interface PostInvocationAuthorizationAdvice    {
  after(authentication : Authentication, mi : MethodInvocation, pia : PostInvocationAttribute, returnedObject : Object) : Object
}
interface PreInvocationAttribute    {
}
interface PreInvocationAuthorizationAdvice    {
  before(authentication : Authentication, mi : MethodInvocation, preInvocationAttribute : PreInvocationAttribute) : boolean
}
class PreInvocationAuthorizationAdviceVoter    {
  logger : Log
  preAdvice : PreInvocationAuthorizationAdvice
  PreInvocationAuthorizationAdviceVoter(pre : PreInvocationAuthorizationAdvice) : None
  supports(attribute : ConfigAttribute) : boolean
  supports(clazz : Class<?>) : boolean
  vote(authentication : Authentication, method : MethodInvocation, attributes : Collection<ConfigAttribute>) : int
  findPreInvocationAttribute(config : Collection<ConfigAttribute>) : PreInvocationAttribute
}
class PrePostAdviceReactiveMethodInterceptor  implements org.aopalliance.intercept.MethodInterceptor  {
  anonymous : Authentication
  attributeSource : MethodSecurityMetadataSource
  preInvocationAdvice : PreInvocationAuthorizationAdvice
  postAdvice : PostInvocationAuthorizationAdvice
  COROUTINES_FLOW_CLASS_NAME : String
  RETURN_TYPE_METHOD_PARAMETER_INDEX : int
  PrePostAdviceReactiveMethodInterceptor(attributeSource : MethodSecurityMetadataSource, preInvocationAdvice : PreInvocationAuthorizationAdvice, postInvocationAdvice : PostInvocationAuthorizationAdvice) : None
  invoke(invocation : MethodInvocation) : Object
  proceed(invocation : MethodInvocation) : T
  flowProceed(invocation : MethodInvocation) : Object
  findPostInvocationAttribute(config : Collection<ConfigAttribute>) : PostInvocationAttribute
  findPreInvocationAttribute(config : Collection<ConfigAttribute>) : PreInvocationAttribute
}
PrePostAdviceReactiveMethodInterceptor::invoke --> org.springframework.security.access.method.MethodSecurityMetadataSource::getAttributes : attributeSource.getAttributes(method,targetClass) 
class KotlinDelegate    {
  asFlow(publisher : Publisher<?>) : Object
}
class PrePostAnnotationSecurityMetadataSource extends org.springframework.security.access.method.AbstractMethodSecurityMetadataSource   {
  attributeFactory : PrePostInvocationAttributeFactory
  PrePostAnnotationSecurityMetadataSource(attributeFactory : PrePostInvocationAttributeFactory) : None
  getAttributes(method : Method, targetClass : Class<?>) : Collection<ConfigAttribute>
  getAllConfigAttributes() : Collection<ConfigAttribute>
  findAnnotation(method : Method, targetClass : Class<?>, annotationClass : Class<A>) : A
}
PrePostAnnotationSecurityMetadataSource::getAttributes --> java.lang.reflect.Method::getDeclaringClass : method.getDeclaringClass() 
interface PrePostInvocationAttributeFactory    {
  createPreInvocationAttribute(preFilterAttribute : String, filterObject : String, preAuthorizeAttribute : String) : PreInvocationAttribute
  createPostInvocationAttribute(postFilterAttribute : String, postAuthorizeAttribute : String) : PostInvocationAttribute
}
}
package vote {
class AbstractAccessDecisionManager    {
  logger : Log
  decisionVoters : List<AccessDecisionVoter<?>>
  messages : MessageSourceAccessor
  allowIfAllAbstainDecisions : boolean
  AbstractAccessDecisionManager(decisionVoters : List<AccessDecisionVoter<?>>) : None
  afterPropertiesSet() : void
  checkAllowIfAllAbstainDecisions() : void
  getDecisionVoters() : List<AccessDecisionVoter<?>>
  isAllowIfAllAbstainDecisions() : boolean
  setAllowIfAllAbstainDecisions(allowIfAllAbstainDecisions : boolean) : void
  setMessageSource(messageSource : MessageSource) : void
  supports(attribute : ConfigAttribute) : boolean
  supports(clazz : Class<?>) : boolean
  toString() : String
}
AbstractAccessDecisionManager::checkAllowIfAllAbstainDecisions --> org.springframework.context.support.MessageSourceAccessor::getMessage : messages.getMessage("AbstractAccessDecisionManager.accessDenied","Access is denied") 
class AbstractAclVoter    {
  processDomainObjectClass : Class<?>
  getDomainObjectInstance(invocation : MethodInvocation) : Object
  getProcessDomainObjectClass() : Class<?>
  setProcessDomainObjectClass(processDomainObjectClass : Class<?>) : void
  supports(clazz : Class<?>) : boolean
}
class AffirmativeBased    {
  AffirmativeBased(decisionVoters : List<AccessDecisionVoter<?>>) : None
  decide(authentication : Authentication, object : Object, configAttributes : Collection<ConfigAttribute>) : void
}
class AuthenticatedVoter    {
  IS_AUTHENTICATED_FULLY : String
  IS_AUTHENTICATED_REMEMBERED : String
  IS_AUTHENTICATED_ANONYMOUSLY : String
  authenticationTrustResolver : AuthenticationTrustResolver
  isFullyAuthenticated(authentication : Authentication) : boolean
  setAuthenticationTrustResolver(authenticationTrustResolver : AuthenticationTrustResolver) : void
  supports(attribute : ConfigAttribute) : boolean
  supports(clazz : Class<?>) : boolean
  vote(authentication : Authentication, object : Object, attributes : Collection<ConfigAttribute>) : int
}
AuthenticatedVoter::isFullyAuthenticated --> org.springframework.security.authentication.AuthenticationTrustResolver::isFullyAuthenticated : authenticationTrustResolver.isFullyAuthenticated(authentication) 
AuthenticatedVoter::vote --> org.springframework.security.authentication.AuthenticationTrustResolver::isRememberMe : authenticationTrustResolver.isRememberMe(authentication) 
AuthenticatedVoter::vote --> org.springframework.security.authentication.AuthenticationTrustResolver::isAnonymous : authenticationTrustResolver.isAnonymous(authentication) 
AuthenticatedVoter::vote --> org.springframework.security.authentication.AuthenticationTrustResolver::isRememberMe : authenticationTrustResolver.isRememberMe(authentication) 
class ConsensusBased    {
  allowIfEqualGrantedDeniedDecisions : boolean
  ConsensusBased(decisionVoters : List<AccessDecisionVoter<?>>) : None
  decide(authentication : Authentication, object : Object, configAttributes : Collection<ConfigAttribute>) : void
  isAllowIfEqualGrantedDeniedDecisions() : boolean
  setAllowIfEqualGrantedDeniedDecisions(allowIfEqualGrantedDeniedDecisions : boolean) : void
}
class RoleHierarchyVoter    {
  roleHierarchy : RoleHierarchy
  RoleHierarchyVoter(roleHierarchy : RoleHierarchy) : None
  extractAuthorities(authentication : Authentication) : Collection<?extendsGrantedAuthority>
}
RoleHierarchyVoter::extractAuthorities --> org.springframework.security.access.hierarchicalroles.RoleHierarchy::getReachableGrantedAuthorities : roleHierarchy.getReachableGrantedAuthorities(authentication.getAuthorities()) 
RoleHierarchyVoter::extractAuthorities --> org.springframework.security.core.Authentication::getAuthorities : authentication.getAuthorities() 
class RoleVoter    {
  rolePrefix : String
  getRolePrefix() : String
  setRolePrefix(rolePrefix : String) : void
  supports(attribute : ConfigAttribute) : boolean
  supports(clazz : Class<?>) : boolean
  vote(authentication : Authentication, object : Object, attributes : Collection<ConfigAttribute>) : int
  extractAuthorities(authentication : Authentication) : Collection<?extendsGrantedAuthority>
}
RoleVoter::extractAuthorities --> org.springframework.security.core.Authentication::getAuthorities : authentication.getAuthorities() 
class UnanimousBased    {
  UnanimousBased(decisionVoters : List<AccessDecisionVoter<?>>) : None
  decide(authentication : Authentication, object : Object, attributes : Collection<ConfigAttribute>) : void
}
}
interface AccessDecisionManager    {
  decide(authentication : Authentication, object : Object, configAttributes : Collection<ConfigAttribute>) : void
  supports(attribute : ConfigAttribute) : boolean
  supports(clazz : Class<?>) : boolean
}
interface AccessDecisionVoter    {
  supports(attribute : ConfigAttribute) : boolean
  supports(clazz : Class<?>) : boolean
  vote(authentication : Authentication, object : S, attributes : Collection<ConfigAttribute>) : int
}
class AccessDeniedException    {
  serialVersionUID : long
  AccessDeniedException(msg : String) : None
  AccessDeniedException(msg : String, cause : Throwable) : None
}
interface AfterInvocationProvider    {
  decide(authentication : Authentication, object : Object, attributes : Collection<ConfigAttribute>, returnedObject : Object) : Object
  supports(attribute : ConfigAttribute) : boolean
  supports(clazz : Class<?>) : boolean
}
class AuthorizationServiceException    {
  serialVersionUID : long
  AuthorizationServiceException(msg : String) : None
  AuthorizationServiceException(msg : String, cause : Throwable) : None
}
interface ConfigAttribute    {
  getAttribute() : String
}
interface PermissionCacheOptimizer    {
  cachePermissionsFor(a : Authentication, objects : Collection<?>) : void
}
interface PermissionEvaluator    {
  hasPermission(authentication : Authentication, targetDomainObject : Object, permission : Object) : boolean
  hasPermission(authentication : Authentication, targetId : Serializable, targetType : String, permission : Object) : boolean
}
class SecurityConfig    {
  serialVersionUID : long
  attrib : String
  SecurityConfig(config : String) : None
  equals(obj : Object) : boolean
  getAttribute() : String
  hashCode() : int
  toString() : String
  createListFromCommaDelimitedString(access : String) : List<ConfigAttribute>
  createList() : List<ConfigAttribute>
}
interface SecurityMetadataSource    {
  getAttributes(object : Object) : Collection<ConfigAttribute>
  getAllConfigAttributes() : Collection<ConfigAttribute>
  supports(clazz : Class<?>) : boolean
}
}
package aot {
package hint {
class AuthorizeReturnObjectCoreHintsRegistrar    {
  proxyFactory : AuthorizationProxyFactory
  scanner : SecurityAnnotationScanner<AuthorizeReturnObject>
  visitedClasses : Set<Class<?>>
  AuthorizeReturnObjectCoreHintsRegistrar(proxyFactory : AuthorizationProxyFactory) : None
  registerHints(hints : RuntimeHints, beanFactory : ConfigurableListableBeanFactory) : void
}
AuthorizeReturnObjectCoreHintsRegistrar::registerHints --> org.springframework.beans.factory.config.ConfigurableListableBeanFactory::getBeanDefinitionNames : beanFactory.getBeanDefinitionNames() 
AuthorizeReturnObjectCoreHintsRegistrar::registerHints --> org.springframework.beans.factory.config.ConfigurableListableBeanFactory::getType : beanFactory.getType(name,false) 
class AuthorizeReturnObjectHintsRegistrar    {
  proxyFactory : AuthorizationProxyFactory
  scanner : SecurityAnnotationScanner<AuthorizeReturnObject>
  visitedClasses : Set<Class<?>>
  classesToProxy : List<Class<?>>
  AuthorizeReturnObjectHintsRegistrar(proxyFactory : AuthorizationProxyFactory) : None
  AuthorizeReturnObjectHintsRegistrar(proxyFactory : AuthorizationProxyFactory, classes : List<Class<?>>) : None
  registerHints(hints : RuntimeHints, beanFactory : ConfigurableListableBeanFactory) : void
  registerProxy(hints : RuntimeHints, clazz : Class<?>) : void
  traverseType(toProxy : List<Class<?>>, clazz : Class<?>) : void
}
AuthorizeReturnObjectHintsRegistrar::registerProxy --> org.springframework.security.authorization.AuthorizationProxyFactory::proxy : proxyFactory.proxy(clazz) 
class CoreSecurityRuntimeHints  implements org.springframework.aot.hint.RuntimeHintsRegistrar  {
  registerHints(hints : RuntimeHints, classLoader : ClassLoader) : void
  registerMethodSecurityHints(hints : RuntimeHints) : void
  registerExpressionEvaluationHints(hints : RuntimeHints) : void
  registerExceptionEventsHints(hints : RuntimeHints) : void
  getDefaultAuthenticationExceptionEventPublisherTypes() : List<TypeReference>
  registerDefaultJdbcSchemaFileHint(hints : RuntimeHints) : void
  registerSecurityContextHints(hints : RuntimeHints) : void
}
CoreSecurityRuntimeHints::registerHints --> org.springframework.aot.hint.RuntimeHints::resources : hints.resources().registerResourceBundle("org.springframework.security.messages") 
CoreSecurityRuntimeHints::registerHints --> org.springframework.aot.hint.RuntimeHints::resources : hints.resources() 
CoreSecurityRuntimeHints::registerMethodSecurityHints --> org.springframework.aot.hint.RuntimeHints::reflection : hints.reflection().registerType(TypeReference.of("org.springframework.security.access.expression.method.MethodSecurityExpressionRoot"),(builder)->builder.withMembers(MemberCategory.INVOKE_PUBLIC_METHODS)) 
CoreSecurityRuntimeHints::registerMethodSecurityHints --> org.springframework.aot.hint.RuntimeHints::reflection : hints.reflection() 
CoreSecurityRuntimeHints::registerMethodSecurityHints --> org.springframework.aot.hint.RuntimeHints::reflection : hints.reflection().registerType(AbstractAuthenticationToken.class,(builder)->builder.withMembers(MemberCategory.INVOKE_PUBLIC_METHODS)) 
CoreSecurityRuntimeHints::registerMethodSecurityHints --> org.springframework.aot.hint.RuntimeHints::reflection : hints.reflection() 
CoreSecurityRuntimeHints::registerExpressionEvaluationHints --> org.springframework.aot.hint.RuntimeHints::reflection : hints.reflection().registerTypes(List.of(TypeReference.of(SecurityExpressionOperations.class),TypeReference.of(SecurityExpressionRoot.class)),(builder)->builder.withMembers(MemberCategory.DECLARED_FIELDS,MemberCategory.INVOKE_DECLARED_METHODS)) 
CoreSecurityRuntimeHints::registerExpressionEvaluationHints --> org.springframework.aot.hint.RuntimeHints::reflection : hints.reflection() 
CoreSecurityRuntimeHints::registerExceptionEventsHints --> org.springframework.aot.hint.RuntimeHints::reflection : hints.reflection().registerTypes(getDefaultAuthenticationExceptionEventPublisherTypes(),(builder)->builder.withMembers(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)) 
CoreSecurityRuntimeHints::registerExceptionEventsHints --> org.springframework.aot.hint.RuntimeHints::reflection : hints.reflection() 
CoreSecurityRuntimeHints::registerDefaultJdbcSchemaFileHint --> org.springframework.aot.hint.RuntimeHints::resources : hints.resources().registerPattern(JdbcDaoImpl.DEFAULT_USER_SCHEMA_DDL_LOCATION) 
CoreSecurityRuntimeHints::registerDefaultJdbcSchemaFileHint --> org.springframework.aot.hint.RuntimeHints::resources : hints.resources() 
CoreSecurityRuntimeHints::registerSecurityContextHints --> org.springframework.aot.hint.RuntimeHints::reflection : hints.reflection().registerType(SecurityContextImpl.class,(builder)->builder.withMembers(MemberCategory.INVOKE_PUBLIC_METHODS)) 
CoreSecurityRuntimeHints::registerSecurityContextHints --> org.springframework.aot.hint.RuntimeHints::reflection : hints.reflection() 
class OneTimeTokenRuntimeHints  implements org.springframework.aot.hint.RuntimeHintsRegistrar  {
  registerHints(hints : RuntimeHints, classLoader : ClassLoader) : void
}
OneTimeTokenRuntimeHints::registerHints --> org.springframework.aot.hint.RuntimeHints::resources : hints.resources().registerPattern("org/springframework/security/core/ott/jdbc/one-time-tokens-schema.sql") 
OneTimeTokenRuntimeHints::registerHints --> org.springframework.aot.hint.RuntimeHints::resources : hints.resources() 
class PrePostAuthorizeExpressionBeanHintsRegistrar    {
  preAuthorizeScanner : SecurityAnnotationScanner<PreAuthorize>
  postAuthorizeScanner : SecurityAnnotationScanner<PostAuthorize>
  authorizeReturnObjectScanner : SecurityAnnotationScanner<AuthorizeReturnObject>
  expressionParser : SpelExpressionParser
  visitedClasses : Set<Class<?>>
  toVisit : List<Class<?>>
  PrePostAuthorizeExpressionBeanHintsRegistrar() : None
  PrePostAuthorizeExpressionBeanHintsRegistrar(toVisit : List<Class<?>>) : None
  registerHints(hints : RuntimeHints, beanFactory : ConfigurableListableBeanFactory) : void
  extractSecurityExpressions(clazz : Class<?>) : Set<String>
  extractBeanNames(rawExpression : String) : Set<String>
  resolveBeanNames(beanNames : Set<String>, node : SpelNode) : void
}
PrePostAuthorizeExpressionBeanHintsRegistrar::extractBeanNames --> org.springframework.expression.spel.standard.SpelExpressionParser::parseRaw : expressionParser.parseRaw(rawExpression) 
PrePostAuthorizeExpressionBeanHintsRegistrar::resolveBeanNames --> org.springframework.expression.spel.SpelNode::getChildCount : node.getChildCount() 
PrePostAuthorizeExpressionBeanHintsRegistrar::resolveBeanNames --> org.springframework.expression.spel.SpelNode::getChild : node.getChild(i) 
class PrePostAuthorizeHintsRegistrar    {
  registerHints(hints : RuntimeHints, beanFactory : ConfigurableListableBeanFactory) : void
}
PrePostAuthorizeHintsRegistrar::registerHints --> org.springframework.beans.factory.config.ConfigurableListableBeanFactory::getBeanDefinitionNames : beanFactory.getBeanDefinitionNames() 
class SecurityHintsAotProcessor  implements org.springframework.beans.factory.aot.BeanFactoryInitializationAotProcessor  {
  processAheadOfTime(beanFactory : ConfigurableListableBeanFactory) : BeanFactoryInitializationAotContribution
}
class AuthorizationProxyFactoryAotContribution    {
  beanFactory : ConfigurableListableBeanFactory
  AuthorizationProxyFactoryAotContribution(beanFactory : ConfigurableListableBeanFactory) : None
  applyTo(context : GenerationContext, code : BeanFactoryInitializationCode) : void
}
interface SecurityHintsRegistrar    {
  registerHints(hints : RuntimeHints, beanFactory : ConfigurableListableBeanFactory) : void
}
}
}
package authentication {
package dao {
class AbstractUserDetailsAuthenticationProvider    {
  logger : Log
  messages : MessageSourceAccessor
  userCache : UserCache
  forcePrincipalAsString : boolean
  hideUserNotFoundExceptions : boolean
  preAuthenticationChecks : UserDetailsChecker
  postAuthenticationChecks : UserDetailsChecker
  authoritiesMapper : GrantedAuthoritiesMapper
  additionalAuthenticationChecks(userDetails : UserDetails, authentication : UsernamePasswordAuthenticationToken) : void
  afterPropertiesSet() : void
  authenticate(authentication : Authentication) : Authentication
  determineUsername(authentication : Authentication) : String
  createSuccessAuthentication(principal : Object, authentication : Authentication, user : UserDetails) : Authentication
  doAfterPropertiesSet() : void
  getUserCache() : UserCache
  isForcePrincipalAsString() : boolean
  isHideUserNotFoundExceptions() : boolean
  retrieveUser(username : String, authentication : UsernamePasswordAuthenticationToken) : UserDetails
  setForcePrincipalAsString(forcePrincipalAsString : boolean) : void
  setHideUserNotFoundExceptions(hideUserNotFoundExceptions : boolean) : void
  setMessageSource(messageSource : MessageSource) : void
  setUserCache(userCache : UserCache) : void
  supports(authentication : Class<?>) : boolean
  getPreAuthenticationChecks() : UserDetailsChecker
  setPreAuthenticationChecks(preAuthenticationChecks : UserDetailsChecker) : void
  getPostAuthenticationChecks() : UserDetailsChecker
  setPostAuthenticationChecks(postAuthenticationChecks : UserDetailsChecker) : void
  setAuthoritiesMapper(authoritiesMapper : GrantedAuthoritiesMapper) : void
}
AbstractUserDetailsAuthenticationProvider::authenticate --> org.springframework.context.support.MessageSourceAccessor::getMessage : messages.getMessage("AbstractUserDetailsAuthenticationProvider.onlySupports","Only UsernamePasswordAuthenticationToken is supported") 
AbstractUserDetailsAuthenticationProvider::authenticate --> org.springframework.security.core.userdetails.UserCache::getUserFromCache : userCache.getUserFromCache(username) 
AbstractUserDetailsAuthenticationProvider::authenticate --> org.springframework.context.support.MessageSourceAccessor::getMessage : messages.getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials","Bad credentials") 
AbstractUserDetailsAuthenticationProvider::authenticate --> org.springframework.security.core.userdetails.UserDetailsChecker::check : preAuthenticationChecks.check(user) 
AbstractUserDetailsAuthenticationProvider::authenticate --> org.springframework.security.core.userdetails.UserDetailsChecker::check : preAuthenticationChecks.check(user) 
AbstractUserDetailsAuthenticationProvider::authenticate --> org.springframework.security.core.userdetails.UserDetailsChecker::check : postAuthenticationChecks.check(user) 
AbstractUserDetailsAuthenticationProvider::authenticate --> org.springframework.security.core.userdetails.UserCache::putUserInCache : userCache.putUserInCache(user) 
AbstractUserDetailsAuthenticationProvider::createSuccessAuthentication --> org.springframework.security.core.authority.mapping.GrantedAuthoritiesMapper::mapAuthorities : authoritiesMapper.mapAuthorities(user.getAuthorities()) 
class DefaultPreAuthenticationChecks    {
  check(user : UserDetails) : void
}
class DefaultPostAuthenticationChecks    {
  check(user : UserDetails) : void
}
class DaoAuthenticationProvider    {
  USER_NOT_FOUND_PASSWORD : String
  passwordEncoder : Supplier<PasswordEncoder>
  userNotFoundEncodedPassword : String
  userDetailsService : UserDetailsService
  userDetailsPasswordService : UserDetailsPasswordService
  compromisedPasswordChecker : CompromisedPasswordChecker
  DaoAuthenticationProvider() : None
  DaoAuthenticationProvider(userDetailsService : UserDetailsService) : None
  DaoAuthenticationProvider(passwordEncoder : PasswordEncoder) : None
  additionalAuthenticationChecks(userDetails : UserDetails, authentication : UsernamePasswordAuthenticationToken) : void
  doAfterPropertiesSet() : void
  retrieveUser(username : String, authentication : UsernamePasswordAuthenticationToken) : UserDetails
  createSuccessAuthentication(principal : Object, authentication : Authentication, user : UserDetails) : Authentication
  prepareTimingAttackProtection() : void
  mitigateAgainstTimingAttack(authentication : UsernamePasswordAuthenticationToken) : void
  setPasswordEncoder(passwordEncoder : PasswordEncoder) : void
  getPasswordEncoder() : PasswordEncoder
  setUserDetailsService(userDetailsService : UserDetailsService) : void
  getUserDetailsService() : UserDetailsService
  setUserDetailsPasswordService(userDetailsPasswordService : UserDetailsPasswordService) : void
  setCompromisedPasswordChecker(compromisedPasswordChecker : CompromisedPasswordChecker) : void
}
DaoAuthenticationProvider::createSuccessAuthentication --> org.springframework.security.authentication.password.CompromisedPasswordChecker::check : compromisedPasswordChecker.check(presentedPassword).isCompromised() 
DaoAuthenticationProvider::createSuccessAuthentication --> org.springframework.security.authentication.password.CompromisedPasswordChecker::check : compromisedPasswordChecker.check(presentedPassword) 
DaoAuthenticationProvider::createSuccessAuthentication --> org.springframework.security.core.userdetails.UserDetailsPasswordService::updatePassword : userDetailsPasswordService.updatePassword(user,newPassword) 
}
package event {
class AbstractAuthenticationEvent extends org.springframework.context.ApplicationEvent   {
  AbstractAuthenticationEvent(authentication : Authentication) : None
  getAuthentication() : Authentication
}
class AbstractAuthenticationFailureEvent    {
  exception : AuthenticationException
  AbstractAuthenticationFailureEvent(authentication : Authentication, exception : AuthenticationException) : None
  getException() : AuthenticationException
}
class AuthenticationFailureBadCredentialsEvent    {
  serialVersionUID : long
  AuthenticationFailureBadCredentialsEvent(authentication : Authentication, exception : AuthenticationException) : None
}
class AuthenticationFailureCredentialsExpiredEvent    {
  serialVersionUID : long
  AuthenticationFailureCredentialsExpiredEvent(authentication : Authentication, exception : AuthenticationException) : None
}
class AuthenticationFailureDisabledEvent    {
  serialVersionUID : long
  AuthenticationFailureDisabledEvent(authentication : Authentication, exception : AuthenticationException) : None
}
class AuthenticationFailureExpiredEvent    {
  serialVersionUID : long
  AuthenticationFailureExpiredEvent(authentication : Authentication, exception : AuthenticationException) : None
}
class AuthenticationFailureLockedEvent    {
  serialVersionUID : long
  AuthenticationFailureLockedEvent(authentication : Authentication, exception : AuthenticationException) : None
}
class AuthenticationFailureProviderNotFoundEvent    {
  serialVersionUID : long
  AuthenticationFailureProviderNotFoundEvent(authentication : Authentication, exception : AuthenticationException) : None
}
class AuthenticationFailureProxyUntrustedEvent    {
  serialVersionUID : long
  AuthenticationFailureProxyUntrustedEvent(authentication : Authentication, exception : AuthenticationException) : None
}
class AuthenticationFailureServiceExceptionEvent    {
  serialVersionUID : long
  AuthenticationFailureServiceExceptionEvent(authentication : Authentication, exception : AuthenticationException) : None
}
class AuthenticationSuccessEvent    {
  serialVersionUID : long
  AuthenticationSuccessEvent(authentication : Authentication) : None
}
class InteractiveAuthenticationSuccessEvent    {
  serialVersionUID : long
  generatedBy : Class<?>
  InteractiveAuthenticationSuccessEvent(authentication : Authentication, generatedBy : Class<?>) : None
  getGeneratedBy() : Class<?>
}
class LoggerListener    {
  logger : Log
  logInteractiveAuthenticationSuccessEvents : boolean
  onApplicationEvent(event : AbstractAuthenticationEvent) : void
  getLogMessage(event : AbstractAuthenticationEvent) : String
  isLogInteractiveAuthenticationSuccessEvents() : boolean
  setLogInteractiveAuthenticationSuccessEvents(logInteractiveAuthenticationSuccessEvents : boolean) : void
}
class LogoutSuccessEvent    {
  serialVersionUID : long
  LogoutSuccessEvent(authentication : Authentication) : None
}
}
package jaas {
package event {
class JaasAuthenticationEvent extends org.springframework.context.ApplicationEvent   {
  JaasAuthenticationEvent(auth : Authentication) : None
  getAuthentication() : Authentication
}
class JaasAuthenticationFailedEvent    {
  serialVersionUID : long
  exception : Exception
  JaasAuthenticationFailedEvent(auth : Authentication, exception : Exception) : None
  getException() : Exception
}
class JaasAuthenticationSuccessEvent    {
  serialVersionUID : long
  JaasAuthenticationSuccessEvent(auth : Authentication) : None
}
}
package memory {
class InMemoryConfiguration extends javax.security.auth.login.Configuration   {
  defaultConfiguration : AppConfigurationEntry[]
  mappedConfigurations : Map<String,AppConfigurationEntry[]>
  InMemoryConfiguration(defaultConfiguration : AppConfigurationEntry[]) : None
  InMemoryConfiguration(mappedConfigurations : Map<String,AppConfigurationEntry[]>) : None
  InMemoryConfiguration(mappedConfigurations : Map<String,AppConfigurationEntry[]>, defaultConfiguration : AppConfigurationEntry[]) : None
  getAppConfigurationEntry(name : String) : AppConfigurationEntry[]
  refresh() : void
}
}
class AbstractJaasAuthenticationProvider    {
  applicationEventPublisher : ApplicationEventPublisher
  authorityGranters : AuthorityGranter[]
  callbackHandlers : JaasAuthenticationCallbackHandler[]
  log : Log
  loginExceptionResolver : LoginExceptionResolver
  loginContextName : String
  afterPropertiesSet() : void
  authenticate(auth : Authentication) : Authentication
  getAuthorities(principals : Set<Principal>) : Set<GrantedAuthority>
  createLoginContext(handler : CallbackHandler) : LoginContext
  handleLogout(event : SessionDestroyedEvent) : void
  logout(token : JaasAuthenticationToken, loginContext : LoginContext) : void
  onApplicationEvent(event : SessionDestroyedEvent) : void
  publishFailureEvent(token : UsernamePasswordAuthenticationToken, ase : AuthenticationException) : void
  publishSuccessEvent(token : UsernamePasswordAuthenticationToken) : void
  getAuthorityGranters() : AuthorityGranter[]
  setAuthorityGranters(authorityGranters : AuthorityGranter[]) : void
  getCallbackHandlers() : JaasAuthenticationCallbackHandler[]
  setCallbackHandlers(callbackHandlers : JaasAuthenticationCallbackHandler[]) : void
  getLoginContextName() : String
  setLoginContextName(loginContextName : String) : void
  getLoginExceptionResolver() : LoginExceptionResolver
  setLoginExceptionResolver(loginExceptionResolver : LoginExceptionResolver) : void
  supports(aClass : Class<?>) : boolean
  setApplicationEventPublisher(applicationEventPublisher : ApplicationEventPublisher) : void
  getApplicationEventPublisher() : ApplicationEventPublisher
}
AbstractJaasAuthenticationProvider::publishFailureEvent --> org.springframework.context.ApplicationEventPublisher::publishEvent : applicationEventPublisher.publishEvent(newJaasAuthenticationFailedEvent(token,ase)) 
AbstractJaasAuthenticationProvider::publishSuccessEvent --> org.springframework.context.ApplicationEventPublisher::publishEvent : applicationEventPublisher.publishEvent(newJaasAuthenticationSuccessEvent(token)) 
class InternalCallbackHandler    {
  authentication : Authentication
  InternalCallbackHandler(authentication : Authentication) : None
  handle(callbacks : Callback[]) : void
}
interface AuthorityGranter    {
  grant(principal : Principal) : Set<String>
}
class DefaultJaasAuthenticationProvider    {
  configuration : Configuration
  afterPropertiesSet() : void
  createLoginContext(handler : CallbackHandler) : LoginContext
  getConfiguration() : Configuration
  setConfiguration(configuration : Configuration) : void
}
class DefaultLoginExceptionResolver    {
  resolveException(ex : LoginException) : AuthenticationException
}
DefaultLoginExceptionResolver::resolveException --> javax.security.auth.login.LoginException::getMessage : ex.getMessage() 
interface JaasAuthenticationCallbackHandler    {
  handle(callback : Callback, auth : Authentication) : void
}
class JaasAuthenticationProvider    {
  log : Log
  loginConfig : Resource
  refreshConfigurationOnStartup : boolean
  afterPropertiesSet() : void
  createLoginContext(handler : CallbackHandler) : LoginContext
  configureJaas(loginConfig : Resource) : void
  configureJaasUsingLoop() : void
  convertLoginConfigToUrl() : String
  publishFailureEvent(token : UsernamePasswordAuthenticationToken, ase : AuthenticationException) : void
  getLoginConfig() : Resource
  setLoginConfig(loginConfig : Resource) : void
  setRefreshConfigurationOnStartup(refresh : boolean) : void
}
JaasAuthenticationProvider::convertLoginConfigToUrl --> org.springframework.core.io.Resource::getFile : loginConfig.getFile().getAbsolutePath().replace(File.separatorChar,'/') 
JaasAuthenticationProvider::convertLoginConfigToUrl --> org.springframework.core.io.Resource::getFile : loginConfig.getFile().getAbsolutePath() 
JaasAuthenticationProvider::convertLoginConfigToUrl --> org.springframework.core.io.Resource::getFile : loginConfig.getFile() 
JaasAuthenticationProvider::convertLoginConfigToUrl --> org.springframework.core.io.Resource::getURL : loginConfig.getURL().toString() 
JaasAuthenticationProvider::convertLoginConfigToUrl --> org.springframework.core.io.Resource::getURL : loginConfig.getURL() 
class JaasAuthenticationToken extends org.springframework.security.authentication.UsernamePasswordAuthenticationToken   {
  serialVersionUID : long
  loginContext : LoginContext
  JaasAuthenticationToken(principal : Object, credentials : Object, loginContext : LoginContext) : None
  JaasAuthenticationToken(principal : Object, credentials : Object, authorities : List<GrantedAuthority>, loginContext : LoginContext) : None
  getLoginContext() : LoginContext
}
class JaasGrantedAuthority  implements org.springframework.security.core.GrantedAuthority  {
  serialVersionUID : long
  role : String
  principal : Principal
  JaasGrantedAuthority(role : String, principal : Principal) : None
  getPrincipal() : Principal
  getAuthority() : String
  equals(obj : Object) : boolean
  hashCode() : int
  toString() : String
}
JaasGrantedAuthority::equals --> java.security.Principal::equals : principal.equals(jga.getPrincipal()) 
JaasGrantedAuthority::hashCode --> java.security.Principal::hashCode : principal.hashCode() 
class JaasNameCallbackHandler    {
  handle(callback : Callback, authentication : Authentication) : void
  getUserName(authentication : Authentication) : String
}
JaasNameCallbackHandler::getUserName --> org.springframework.security.core.Authentication::getPrincipal : authentication.getPrincipal() 
class JaasPasswordCallbackHandler    {
  handle(callback : Callback, auth : Authentication) : void
}
JaasPasswordCallbackHandler::handle --> org.springframework.security.core.Authentication::getCredentials : auth.getCredentials().toString().toCharArray() 
JaasPasswordCallbackHandler::handle --> org.springframework.security.core.Authentication::getCredentials : auth.getCredentials().toString() 
JaasPasswordCallbackHandler::handle --> org.springframework.security.core.Authentication::getCredentials : auth.getCredentials() 
interface LoginExceptionResolver    {
  resolveException(ex : LoginException) : AuthenticationException
}
class SecurityContextLoginModule  implements javax.security.auth.spi.LoginModule  {
  log : Log
  securityContextHolderStrategy : SecurityContextHolderStrategy
  authen : Authentication
  subject : Subject
  ignoreMissingAuthentication : boolean
  abort() : boolean
  commit() : boolean
  setSecurityContextHolderStrategy(securityContextHolderStrategy : SecurityContextHolderStrategy) : void
  getAuthentication() : Authentication
  getSubject() : Subject
  initialize(subject : Subject, callbackHandler : CallbackHandler, sharedState : Map, options : Map) : void
  login() : boolean
  logout() : boolean
}
SecurityContextLoginModule::commit --> javax.security.auth.Subject::getPrincipals : subject.getPrincipals().add(authen) 
SecurityContextLoginModule::commit --> javax.security.auth.Subject::getPrincipals : subject.getPrincipals() 
SecurityContextLoginModule::login --> org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : securityContextHolderStrategy.getContext().getAuthentication() 
SecurityContextLoginModule::login --> org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : securityContextHolderStrategy.getContext() 
SecurityContextLoginModule::logout --> javax.security.auth.Subject::getPrincipals : subject.getPrincipals().remove(authen) 
SecurityContextLoginModule::logout --> javax.security.auth.Subject::getPrincipals : subject.getPrincipals() 
}
package ott {
package reactive {
class InMemoryReactiveOneTimeTokenService    {
  oneTimeTokenService : InMemoryOneTimeTokenService
  generate(request : GenerateOneTimeTokenRequest) : Mono<OneTimeToken>
  consume(authenticationToken : OneTimeTokenAuthenticationToken) : Mono<OneTimeToken>
  setClock(clock : Clock) : void
}
InMemoryReactiveOneTimeTokenService::setClock --> org.springframework.security.authentication.ott.InMemoryOneTimeTokenService::setClock : oneTimeTokenService.setClock(clock) 
class OneTimeTokenReactiveAuthenticationManager  implements org.springframework.security.authentication.ReactiveAuthenticationManager  {
  oneTimeTokenService : ReactiveOneTimeTokenService
  userDetailsService : ReactiveUserDetailsService
  OneTimeTokenReactiveAuthenticationManager(oneTimeTokenService : ReactiveOneTimeTokenService, userDetailsService : ReactiveUserDetailsService) : None
  authenticate(authentication : Authentication) : Mono<Authentication>
  onSuccess(token : OneTimeTokenAuthenticationToken) : Function<UserDetails,OneTimeTokenAuthenticationToken>
}
OneTimeTokenReactiveAuthenticationManager::authenticate --> org.springframework.security.core.userdetails.ReactiveUserDetailsService::findByUsername : userDetailsService.findByUsername(consumed.getUsername()) 
OneTimeTokenReactiveAuthenticationManager::onSuccess --> org.springframework.security.authentication.ott.OneTimeTokenAuthenticationToken::getDetails : token.getDetails() 
interface ReactiveOneTimeTokenService    {
  generate(request : GenerateOneTimeTokenRequest) : Mono<OneTimeToken>
  consume(authenticationToken : OneTimeTokenAuthenticationToken) : Mono<OneTimeToken>
}
}
class DefaultOneTimeToken    {
  serialVersionUID : long
  token : String
  username : String
  expireAt : Instant
  DefaultOneTimeToken(token : String, username : String, expireAt : Instant) : None
  getTokenValue() : String
  getUsername() : String
  getExpiresAt() : Instant
}
class GenerateOneTimeTokenRequest    {
  DEFAULT_EXPIRES_IN : Duration
  username : String
  expiresIn : Duration
  GenerateOneTimeTokenRequest(username : String) : None
  GenerateOneTimeTokenRequest(username : String, expiresIn : Duration) : None
  getUsername() : String
  getExpiresIn() : Duration
}
class InMemoryOneTimeTokenService    {
  oneTimeTokenByToken : Map<String,OneTimeToken>
  clock : Clock
  generate(request : GenerateOneTimeTokenRequest) : OneTimeToken
  consume(authenticationToken : OneTimeTokenAuthenticationToken) : OneTimeToken
  cleanExpiredTokensIfNeeded() : void
  isExpired(ott : OneTimeToken) : boolean
  setClock(clock : Clock) : void
}
InMemoryOneTimeTokenService::generate --> java.time.Clock::instant : clock.instant().plus(request.getExpiresIn()) 
InMemoryOneTimeTokenService::generate --> java.time.Clock::instant : clock.instant() 
InMemoryOneTimeTokenService::isExpired --> java.time.Clock::instant : clock.instant().isAfter(ott.getExpiresAt()) 
InMemoryOneTimeTokenService::isExpired --> java.time.Clock::instant : clock.instant() 
class InvalidOneTimeTokenException extends org.springframework.security.core.AuthenticationException   {
  serialVersionUID : long
  InvalidOneTimeTokenException(msg : String) : None
}
class JdbcOneTimeTokenService    {
  logger : Log
  jdbcOperations : JdbcOperations
  oneTimeTokenParametersMapper : Function<OneTimeToken,List<SqlParameterValue>>
  oneTimeTokenRowMapper : RowMapper<OneTimeToken>
  clock : Clock
  taskScheduler : ThreadPoolTaskScheduler
  DEFAULT_CLEANUP_CRON : String
  TABLE_NAME : String
  COLUMN_NAMES : String
  SAVE_ONE_TIME_TOKEN_SQL : String
  FILTER : String
  DELETE_ONE_TIME_TOKEN_SQL : String
  SELECT_ONE_TIME_TOKEN_SQL : String
  DELETE_ONE_TIME_TOKENS_BY_EXPIRY_TIME_QUERY : String
  JdbcOneTimeTokenService(jdbcOperations : JdbcOperations) : None
  setCleanupCron(cleanupCron : String) : void
  generate(request : GenerateOneTimeTokenRequest) : OneTimeToken
  insertOneTimeToken(oneTimeToken : OneTimeToken) : void
  consume(authenticationToken : OneTimeTokenAuthenticationToken) : OneTimeToken
  isExpired(ott : OneTimeToken) : boolean
  selectOneTimeToken(authenticationToken : OneTimeTokenAuthenticationToken) : List<OneTimeToken>
  deleteOneTimeToken(oneTimeToken : OneTimeToken) : void
  createTaskScheduler(cleanupCron : String) : ThreadPoolTaskScheduler
  cleanupExpiredTokens() : void
  afterPropertiesSet() : void
  destroy() : void
  setClock(clock : Clock) : void
}
JdbcOneTimeTokenService::generate --> java.time.Clock::instant : clock.instant().plus(request.getExpiresIn()) 
JdbcOneTimeTokenService::generate --> java.time.Clock::instant : clock.instant() 
JdbcOneTimeTokenService::insertOneTimeToken --> org.springframework.jdbc.core.JdbcOperations::update : jdbcOperations.update(SAVE_ONE_TIME_TOKEN_SQL,pss) 
JdbcOneTimeTokenService::isExpired --> java.time.Clock::instant : clock.instant().isAfter(ott.getExpiresAt()) 
JdbcOneTimeTokenService::isExpired --> java.time.Clock::instant : clock.instant() 
JdbcOneTimeTokenService::selectOneTimeToken --> org.springframework.jdbc.core.JdbcOperations::query : jdbcOperations.query(SELECT_ONE_TIME_TOKEN_SQL,pss,oneTimeTokenRowMapper) 
JdbcOneTimeTokenService::deleteOneTimeToken --> org.springframework.jdbc.core.JdbcOperations::update : jdbcOperations.update(DELETE_ONE_TIME_TOKEN_SQL,pss) 
JdbcOneTimeTokenService::createTaskScheduler --> org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler::setThreadNamePrefix : taskScheduler.setThreadNamePrefix("spring-one-time-tokens-") 
JdbcOneTimeTokenService::createTaskScheduler --> org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler::initialize : taskScheduler.initialize() 
JdbcOneTimeTokenService::createTaskScheduler --> org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler::schedule : taskScheduler.schedule(this::cleanupExpiredTokens,newCronTrigger(cleanupCron)) 
JdbcOneTimeTokenService::cleanupExpiredTokens --> org.springframework.jdbc.core.JdbcOperations::update : jdbcOperations.update(DELETE_ONE_TIME_TOKENS_BY_EXPIRY_TIME_QUERY,pss) 
JdbcOneTimeTokenService::afterPropertiesSet --> org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler::afterPropertiesSet : taskScheduler.afterPropertiesSet() 
JdbcOneTimeTokenService::destroy --> org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler::shutdown : taskScheduler.shutdown() 
class OneTimeTokenParametersMapper    {
  apply(oneTimeToken : OneTimeToken) : List<SqlParameterValue>
}
class OneTimeTokenRowMapper    {
  mapRow(rs : ResultSet, rowNum : int) : OneTimeToken
}
interface OneTimeToken    {
  getTokenValue() : String
  getUsername() : String
  getExpiresAt() : Instant
}
class OneTimeTokenAuthenticationProvider  implements org.springframework.security.authentication.AuthenticationProvider  {
  oneTimeTokenService : OneTimeTokenService
  userDetailsService : UserDetailsService
  OneTimeTokenAuthenticationProvider(oneTimeTokenService : OneTimeTokenService, userDetailsService : UserDetailsService) : None
  authenticate(authentication : Authentication) : Authentication
  supports(authentication : Class<?>) : boolean
}
OneTimeTokenAuthenticationProvider::authenticate --> org.springframework.security.core.userdetails.UserDetailsService::loadUserByUsername : userDetailsService.loadUserByUsername(consumed.getUsername()) 
class OneTimeTokenAuthenticationToken extends org.springframework.security.authentication.AbstractAuthenticationToken   {
  serialVersionUID : long
  principal : Object
  tokenValue : String
  OneTimeTokenAuthenticationToken(principal : Object, tokenValue : String) : None
  OneTimeTokenAuthenticationToken(tokenValue : String) : None
  OneTimeTokenAuthenticationToken(principal : Object, authorities : Collection<?extendsGrantedAuthority>) : None
  unauthenticated(tokenValue : String) : OneTimeTokenAuthenticationToken
  unauthenticated(principal : Object, tokenValue : String) : OneTimeTokenAuthenticationToken
  authenticated(principal : Object, authorities : Collection<?extendsGrantedAuthority>) : OneTimeTokenAuthenticationToken
  getTokenValue() : String
  getCredentials() : Object
  getPrincipal() : Object
}
interface OneTimeTokenService    {
  generate(request : GenerateOneTimeTokenRequest) : OneTimeToken
  consume(authenticationToken : OneTimeTokenAuthenticationToken) : OneTimeToken
}
}
package password {
interface CompromisedPasswordChecker    {
  check(password : String) : CompromisedPasswordDecision
}
class CompromisedPasswordDecision    {
  compromised : boolean
  CompromisedPasswordDecision(compromised : boolean) : None
  isCompromised() : boolean
}
class CompromisedPasswordException extends org.springframework.security.core.AuthenticationException   {
  serialVersionUID : long
  CompromisedPasswordException(message : String) : None
  CompromisedPasswordException(message : String, cause : Throwable) : None
}
interface ReactiveCompromisedPasswordChecker    {
  check(password : String) : Mono<CompromisedPasswordDecision>
}
}
class AbstractAuthenticationToken    {
  authorities : Collection<GrantedAuthority>
  details : Object
  authenticated : boolean
  AbstractAuthenticationToken(authorities : Collection<?extendsGrantedAuthority>) : None
  getAuthorities() : Collection<GrantedAuthority>
  getName() : String
  isAuthenticated() : boolean
  setAuthenticated(authenticated : boolean) : void
  getDetails() : Object
  setDetails(details : Object) : void
  eraseCredentials() : void
  eraseSecret(secret : Object) : void
  equals(obj : Object) : boolean
  hashCode() : int
  toString() : String
}
class AbstractUserDetailsReactiveAuthenticationManager    {
  logger : Log
  messages : MessageSourceAccessor
  passwordEncoder : PasswordEncoder
  userDetailsPasswordService : ReactiveUserDetailsPasswordService
  scheduler : Scheduler
  preAuthenticationChecks : UserDetailsChecker
  postAuthenticationChecks : UserDetailsChecker
  compromisedPasswordChecker : ReactiveCompromisedPasswordChecker
  defaultPreAuthenticationChecks(user : UserDetails) : void
  defaultPostAuthenticationChecks(user : UserDetails) : void
  authenticate(authentication : Authentication) : Mono<Authentication>
  checkCompromisedPassword(password : String) : Mono<Void>
  upgradeEncodingIfNecessary(userDetails : UserDetails, presentedPassword : String) : Mono<UserDetails>
  createUsernamePasswordAuthenticationToken(userDetails : UserDetails) : UsernamePasswordAuthenticationToken
  setPasswordEncoder(passwordEncoder : PasswordEncoder) : void
  setScheduler(scheduler : Scheduler) : void
  setUserDetailsPasswordService(userDetailsPasswordService : ReactiveUserDetailsPasswordService) : void
  setPostAuthenticationChecks(postAuthenticationChecks : UserDetailsChecker) : void
  setMessageSource(messageSource : MessageSource) : void
  setCompromisedPasswordChecker(compromisedPasswordChecker : ReactiveCompromisedPasswordChecker) : void
  retrieveUser(username : String) : Mono<UserDetails>
}
AbstractUserDetailsReactiveAuthenticationManager::defaultPreAuthenticationChecks --> org.springframework.context.support.MessageSourceAccessor::getMessage : messages.getMessage("AbstractUserDetailsAuthenticationProvider.locked","User account is locked") 
AbstractUserDetailsReactiveAuthenticationManager::defaultPreAuthenticationChecks --> org.springframework.context.support.MessageSourceAccessor::getMessage : messages.getMessage("AbstractUserDetailsAuthenticationProvider.disabled","User is disabled") 
AbstractUserDetailsReactiveAuthenticationManager::defaultPreAuthenticationChecks --> org.springframework.context.support.MessageSourceAccessor::getMessage : messages.getMessage("AbstractUserDetailsAuthenticationProvider.expired","User account has expired") 
AbstractUserDetailsReactiveAuthenticationManager::defaultPostAuthenticationChecks --> org.springframework.context.support.MessageSourceAccessor::getMessage : messages.getMessage("AbstractUserDetailsAuthenticationProvider.credentialsExpired","User credentials have expired") 
AbstractUserDetailsReactiveAuthenticationManager::authenticate --> org.springframework.security.crypto.password.PasswordEncoder::matches : passwordEncoder.matches(presentedPassword,userDetails.getPassword()) 
AbstractUserDetailsReactiveAuthenticationManager::checkCompromisedPassword --> org.springframework.security.authentication.password.ReactiveCompromisedPasswordChecker::check : compromisedPasswordChecker.check(password).filter(CompromisedPasswordDecision::isCompromised).flatMap((compromised)->Mono.error(newCompromisedPasswordException("The provided password is compromised, please change your password"))) 
AbstractUserDetailsReactiveAuthenticationManager::checkCompromisedPassword --> org.springframework.security.authentication.password.ReactiveCompromisedPasswordChecker::check : compromisedPasswordChecker.check(password).filter(CompromisedPasswordDecision::isCompromised) 
AbstractUserDetailsReactiveAuthenticationManager::checkCompromisedPassword --> org.springframework.security.authentication.password.ReactiveCompromisedPasswordChecker::check : compromisedPasswordChecker.check(password) 
AbstractUserDetailsReactiveAuthenticationManager::upgradeEncodingIfNecessary --> org.springframework.security.crypto.password.PasswordEncoder::upgradeEncoding : passwordEncoder.upgradeEncoding(userDetails.getPassword()) 
AbstractUserDetailsReactiveAuthenticationManager::upgradeEncodingIfNecessary --> org.springframework.security.crypto.password.PasswordEncoder::encode : passwordEncoder.encode(presentedPassword) 
AbstractUserDetailsReactiveAuthenticationManager::upgradeEncodingIfNecessary --> org.springframework.security.core.userdetails.ReactiveUserDetailsPasswordService::updatePassword : userDetailsPasswordService.updatePassword(userDetails,newPassword) 
class AccountExpiredException    {
  serialVersionUID : long
  AccountExpiredException(msg : String) : None
  AccountExpiredException(msg : String, cause : Throwable) : None
}
class AccountStatusException extends org.springframework.security.core.AuthenticationException   {
  AccountStatusException(msg : String) : None
  AccountStatusException(msg : String, cause : Throwable) : None
}
class AccountStatusUserDetailsChecker    {
  logger : Log
  messages : MessageSourceAccessor
  check(user : UserDetails) : void
  setMessageSource(messageSource : MessageSource) : void
}
AccountStatusUserDetailsChecker::check --> org.springframework.context.support.MessageSourceAccessor::getMessage : messages.getMessage("AccountStatusUserDetailsChecker.locked","User account is locked") 
AccountStatusUserDetailsChecker::check --> org.springframework.context.support.MessageSourceAccessor::getMessage : messages.getMessage("AccountStatusUserDetailsChecker.disabled","User is disabled") 
AccountStatusUserDetailsChecker::check --> org.springframework.context.support.MessageSourceAccessor::getMessage : messages.getMessage("AccountStatusUserDetailsChecker.expired","User account has expired") 
AccountStatusUserDetailsChecker::check --> org.springframework.context.support.MessageSourceAccessor::getMessage : messages.getMessage("AccountStatusUserDetailsChecker.credentialsExpired","User credentials have expired") 
class AnonymousAuthenticationProvider    {
  messages : MessageSourceAccessor
  key : String
  AnonymousAuthenticationProvider(key : String) : None
  authenticate(authentication : Authentication) : Authentication
  getKey() : String
  setMessageSource(messageSource : MessageSource) : void
  supports(authentication : Class<?>) : boolean
}
AnonymousAuthenticationProvider::authenticate --> org.springframework.context.support.MessageSourceAccessor::getMessage : messages.getMessage("AnonymousAuthenticationProvider.incorrectKey","The presented AnonymousAuthenticationToken does not contain the expected key") 
class AnonymousAuthenticationToken  implements java.io.Serializable  {
  serialVersionUID : long
  principal : Object
  keyHash : int
  AnonymousAuthenticationToken(key : String, principal : Object, authorities : Collection<?extendsGrantedAuthority>) : None
  AnonymousAuthenticationToken(keyHash : Integer, principal : Object, authorities : Collection<?extendsGrantedAuthority>) : None
  extractKeyHash(key : String) : Integer
  equals(obj : Object) : boolean
  hashCode() : int
  getCredentials() : Object
  getKeyHash() : int
  getPrincipal() : Object
}
class AuthenticationCredentialsNotFoundException extends org.springframework.security.core.AuthenticationException   {
  serialVersionUID : long
  AuthenticationCredentialsNotFoundException(msg : String) : None
  AuthenticationCredentialsNotFoundException(msg : String, cause : Throwable) : None
}
interface AuthenticationDetailsSource    {
  buildDetails(context : C) : T
}
interface AuthenticationEventPublisher    {
  publishAuthenticationSuccess(authentication : Authentication) : void
  publishAuthenticationFailure(exception : AuthenticationException, authentication : Authentication) : void
}
interface AuthenticationManager    {
  authenticate(authentication : Authentication) : Authentication
}
interface AuthenticationManagerResolver    {
  resolve(context : C) : AuthenticationManager
}
class AuthenticationObservationContext    {
  authenticationRequest : Authentication
  authenticationManager : Class<?>
  authenticationResult : Authentication
  getAuthenticationRequest() : Authentication
  setAuthenticationRequest(authenticationRequest : Authentication) : void
  getAuthenticationResult() : Authentication
  setAuthenticationResult(authenticationResult : Authentication) : void
  getAuthenticationManagerClass() : Class<?>
  setAuthenticationManagerClass(authenticationManagerClass : Class<?>) : void
}
class AuthenticationObservationConvention    {
  OBSERVATION_NAME : String
  getName() : String
  getContextualName(context : AuthenticationObservationContext) : String
  getLowCardinalityKeyValues(context : AuthenticationObservationContext) : KeyValues
  getAuthenticationType(context : AuthenticationObservationContext) : String
  getAuthenticationMethod(context : AuthenticationObservationContext) : String
  getAuthenticationResult(context : AuthenticationObservationContext) : String
  getAuthenticationFailureType(context : AuthenticationObservationContext) : String
  supportsContext(context : Observation.Context) : boolean
}
interface AuthenticationProvider    {
  authenticate(authentication : Authentication) : Authentication
  supports(authentication : Class<?>) : boolean
}
class AuthenticationServiceException extends org.springframework.security.core.AuthenticationException   {
  serialVersionUID : long
  AuthenticationServiceException(msg : String) : None
  AuthenticationServiceException(msg : String, cause : Throwable) : None
}
interface AuthenticationTrustResolver    {
  isAnonymous(authentication : Authentication) : boolean
  isRememberMe(authentication : Authentication) : boolean
  isFullyAuthenticated(authentication : Authentication) : boolean
  isAuthenticated(authentication : Authentication) : boolean
}
AuthenticationTrustResolver::isAuthenticated --> org.springframework.security.core.Authentication::isAuthenticated : authentication.isAuthenticated() 
class AuthenticationTrustResolverImpl    {
  anonymousClass : Class<?extendsAuthentication>
  rememberMeClass : Class<?extendsAuthentication>
  getAnonymousClass() : Class<?extendsAuthentication>
  getRememberMeClass() : Class<?extendsAuthentication>
  isAnonymous(authentication : Authentication) : boolean
  isRememberMe(authentication : Authentication) : boolean
  setAnonymousClass(anonymousClass : Class<?extendsAuthentication>) : void
  setRememberMeClass(rememberMeClass : Class<?extendsAuthentication>) : void
}
class BadCredentialsException extends org.springframework.security.core.AuthenticationException   {
  serialVersionUID : long
  BadCredentialsException(msg : String) : None
  BadCredentialsException(msg : String, cause : Throwable) : None
}
class CachingUserDetailsService  implements org.springframework.security.core.userdetails.UserDetailsService  {
  userCache : UserCache
  delegate : UserDetailsService
  CachingUserDetailsService(delegate : UserDetailsService) : None
  getUserCache() : UserCache
  setUserCache(userCache : UserCache) : void
  loadUserByUsername(username : String) : UserDetails
}
CachingUserDetailsService::loadUserByUsername --> org.springframework.security.core.userdetails.UserCache::getUserFromCache : userCache.getUserFromCache(username) 
CachingUserDetailsService::loadUserByUsername --> org.springframework.security.core.userdetails.UserDetailsService::loadUserByUsername : delegate.loadUserByUsername(username) 
CachingUserDetailsService::loadUserByUsername --> org.springframework.security.core.userdetails.UserCache::putUserInCache : userCache.putUserInCache(user) 
class CredentialsExpiredException    {
  serialVersionUID : long
  CredentialsExpiredException(msg : String) : None
  CredentialsExpiredException(msg : String, cause : Throwable) : None
}
class DefaultAuthenticationEventPublisher    {
  logger : Log
  applicationEventPublisher : ApplicationEventPublisher
  exceptionMappings : HashMap<String,Constructor<?extendsAbstractAuthenticationEvent>>
  defaultAuthenticationFailureEventConstructor : Constructor<?extendsAbstractAuthenticationFailureEvent>
  DefaultAuthenticationEventPublisher() : None
  DefaultAuthenticationEventPublisher(applicationEventPublisher : ApplicationEventPublisher) : None
  publishAuthenticationSuccess(authentication : Authentication) : void
  publishAuthenticationFailure(exception : AuthenticationException, authentication : Authentication) : void
  getEventConstructor(exception : AuthenticationException) : Constructor<?extendsAbstractAuthenticationEvent>
  setApplicationEventPublisher(applicationEventPublisher : ApplicationEventPublisher) : void
  setAdditionalExceptionMappings(additionalExceptionMappings : Properties) : void
  setAdditionalExceptionMappings(mappings : Map<Class<?extendsAuthenticationException>,Class<?extendsAbstractAuthenticationFailureEvent>>) : void
  setDefaultAuthenticationFailureEvent(defaultAuthenticationFailureEventClass : Class<?extendsAbstractAuthenticationFailureEvent>) : void
  addMapping(exceptionClass : String, eventClass : Class<?extendsAbstractAuthenticationFailureEvent>) : void
}
DefaultAuthenticationEventPublisher::publishAuthenticationSuccess --> org.springframework.context.ApplicationEventPublisher::publishEvent : applicationEventPublisher.publishEvent(newAuthenticationSuccessEvent(authentication)) 
DefaultAuthenticationEventPublisher::publishAuthenticationFailure --> org.springframework.context.ApplicationEventPublisher::publishEvent : applicationEventPublisher.publishEvent(event) 
class DelegatingReactiveAuthenticationManager    {
  delegates : List<ReactiveAuthenticationManager>
  continueOnError : boolean
  logger : Log
  DelegatingReactiveAuthenticationManager() : None
  DelegatingReactiveAuthenticationManager(entryPoints : List<ReactiveAuthenticationManager>) : None
  authenticate(authentication : Authentication) : Mono<Authentication>
  setContinueOnError(continueOnError : boolean) : void
}
class DisabledException    {
  serialVersionUID : long
  DisabledException(msg : String) : None
  DisabledException(msg : String, cause : Throwable) : None
}
class InsufficientAuthenticationException extends org.springframework.security.core.AuthenticationException   {
  serialVersionUID : long
  InsufficientAuthenticationException(msg : String) : None
  InsufficientAuthenticationException(msg : String, cause : Throwable) : None
}
class InternalAuthenticationServiceException    {
  serialVersionUID : long
  InternalAuthenticationServiceException(message : String, cause : Throwable) : None
  InternalAuthenticationServiceException(message : String) : None
}
class LockedException    {
  serialVersionUID : long
  LockedException(msg : String) : None
  LockedException(msg : String, cause : Throwable) : None
}
class ObservationAuthenticationManager    {
  registry : ObservationRegistry
  delegate : AuthenticationManager
  convention : ObservationConvention<AuthenticationObservationContext>
  ObservationAuthenticationManager(registry : ObservationRegistry, delegate : AuthenticationManager) : None
  authenticate(authentication : Authentication) : Authentication
  setObservationConvention(convention : ObservationConvention<AuthenticationObservationContext>) : void
}
class ObservationReactiveAuthenticationManager    {
  registry : ObservationRegistry
  delegate : ReactiveAuthenticationManager
  convention : ObservationConvention<AuthenticationObservationContext>
  ObservationReactiveAuthenticationManager(registry : ObservationRegistry, delegate : ReactiveAuthenticationManager) : None
  authenticate(authentication : Authentication) : Mono<Authentication>
  setObservationConvention(convention : ObservationConvention<AuthenticationObservationContext>) : void
}
class ProviderManager    {
  logger : Log
  eventPublisher : AuthenticationEventPublisher
  providers : List<AuthenticationProvider>
  messages : MessageSourceAccessor
  parent : AuthenticationManager
  eraseCredentialsAfterAuthentication : boolean
  ProviderManager() : None
  ProviderManager(providers : List<AuthenticationProvider>) : None
  ProviderManager(providers : List<AuthenticationProvider>, parent : AuthenticationManager) : None
  afterPropertiesSet() : void
  checkState() : void
  authenticate(authentication : Authentication) : Authentication
  prepareException(ex : AuthenticationException, auth : Authentication) : void
  copyDetails(source : Authentication, dest : Authentication) : void
  getProviders() : List<AuthenticationProvider>
  setMessageSource(messageSource : MessageSource) : void
  setAuthenticationEventPublisher(eventPublisher : AuthenticationEventPublisher) : void
  setEraseCredentialsAfterAuthentication(eraseSecretData : boolean) : void
  isEraseCredentialsAfterAuthentication() : boolean
}
ProviderManager::authenticate --> org.springframework.context.support.MessageSourceAccessor::getMessage : messages.getMessage("ProviderManager.providerNotFound",newObject[]{toTest.getName()},"No AuthenticationProvider found for {0}") 
class NullEventPublisher    {
  publishAuthenticationFailure(exception : AuthenticationException, authentication : Authentication) : void
  publishAuthenticationSuccess(authentication : Authentication) : void
}
class ProviderNotFoundException extends org.springframework.security.core.AuthenticationException   {
  serialVersionUID : long
  ProviderNotFoundException(msg : String) : None
}
interface ReactiveAuthenticationManager    {
  authenticate(authentication : Authentication) : Mono<Authentication>
}
class ReactiveAuthenticationManagerAdapter    {
  authenticationManager : AuthenticationManager
  scheduler : Scheduler
  ReactiveAuthenticationManagerAdapter(authenticationManager : AuthenticationManager) : None
  authenticate(token : Authentication) : Mono<Authentication>
  doAuthenticate(authentication : Authentication) : Mono<Authentication>
  setScheduler(scheduler : Scheduler) : void
}
interface ReactiveAuthenticationManagerResolver    {
  resolve(context : C) : Mono<ReactiveAuthenticationManager>
}
class RememberMeAuthenticationProvider    {
  messages : MessageSourceAccessor
  key : String
  RememberMeAuthenticationProvider(key : String) : None
  afterPropertiesSet() : void
  authenticate(authentication : Authentication) : Authentication
  getKey() : String
  setMessageSource(messageSource : MessageSource) : void
  supports(authentication : Class<?>) : boolean
}
RememberMeAuthenticationProvider::authenticate --> org.springframework.context.support.MessageSourceAccessor::getMessage : messages.getMessage("RememberMeAuthenticationProvider.incorrectKey","The presented RememberMeAuthenticationToken does not contain the expected key") 
class RememberMeAuthenticationToken    {
  serialVersionUID : long
  principal : Object
  keyHash : int
  RememberMeAuthenticationToken(key : String, principal : Object, authorities : Collection<?extendsGrantedAuthority>) : None
  RememberMeAuthenticationToken(keyHash : Integer, principal : Object, authorities : Collection<?extendsGrantedAuthority>) : None
  getCredentials() : Object
  getKeyHash() : int
  getPrincipal() : Object
  equals(obj : Object) : boolean
  hashCode() : int
}
class TestingAuthenticationProvider    {
  authenticate(authentication : Authentication) : Authentication
  supports(authentication : Class<?>) : boolean
}
class TestingAuthenticationToken    {
  serialVersionUID : long
  credentials : Object
  principal : Object
  TestingAuthenticationToken(principal : Object, credentials : Object) : None
  TestingAuthenticationToken(principal : Object, credentials : Object) : None
  TestingAuthenticationToken(principal : Object, credentials : Object, authorities : List<?extendsGrantedAuthority>) : None
  TestingAuthenticationToken(principal : Object, credentials : Object, authorities : Collection<?extendsGrantedAuthority>) : None
  getCredentials() : Object
  getPrincipal() : Object
}
class UserDetailsRepositoryReactiveAuthenticationManager    {
  userDetailsService : ReactiveUserDetailsService
  UserDetailsRepositoryReactiveAuthenticationManager(userDetailsService : ReactiveUserDetailsService) : None
  retrieveUser(username : String) : Mono<UserDetails>
}
UserDetailsRepositoryReactiveAuthenticationManager::retrieveUser --> org.springframework.security.core.userdetails.ReactiveUserDetailsService::findByUsername : userDetailsService.findByUsername(username) 
class UsernamePasswordAuthenticationToken    {
  serialVersionUID : long
  principal : Object
  credentials : Object
  UsernamePasswordAuthenticationToken(principal : Object, credentials : Object) : None
  UsernamePasswordAuthenticationToken(principal : Object, credentials : Object, authorities : Collection<?extendsGrantedAuthority>) : None
  unauthenticated(principal : Object, credentials : Object) : UsernamePasswordAuthenticationToken
  authenticated(principal : Object, credentials : Object, authorities : Collection<?extendsGrantedAuthority>) : UsernamePasswordAuthenticationToken
  getCredentials() : Object
  getPrincipal() : Object
  setAuthenticated(isAuthenticated : boolean) : void
  eraseCredentials() : void
}
}
package authorization {
package event {
class AuthorizationDeniedEvent    {
  AuthorizationDeniedEvent(authentication : Supplier<Authentication>, object : T, decision : AuthorizationDecision) : None
  AuthorizationDeniedEvent(authentication : Supplier<Authentication>, object : T, result : AuthorizationResult) : None
  getObject() : T
}
class AuthorizationEvent extends org.springframework.context.ApplicationEvent   {
  serialVersionUID : long
  authentication : Supplier<Authentication>
  result : AuthorizationResult
  AuthorizationEvent(authentication : Supplier<Authentication>, object : Object, result : AuthorizationDecision) : None
  AuthorizationEvent(authentication : Supplier<Authentication>, object : Object, result : AuthorizationResult) : None
  getAuthentication() : Supplier<Authentication>
  getObject() : Object
  getAuthorizationDecision() : AuthorizationDecision
  getAuthorizationResult() : AuthorizationResult
}
class AuthorizationGrantedEvent    {
  serialVersionUID : long
  AuthorizationGrantedEvent(authentication : Supplier<Authentication>, object : T, decision : AuthorizationDecision) : None
  AuthorizationGrantedEvent(authentication : Supplier<Authentication>, object : T, result : AuthorizationResult) : None
  getObject() : T
}
}
package method {
class AbstractAuthorizationManagerRegistry    {
  NULL_MANAGER : AuthorizationManager<MethodInvocation>
  cachedManagers : Map<MethodClassKey,AuthorizationManager<MethodInvocation>>
  getManager(methodInvocation : MethodInvocation) : AuthorizationManager<MethodInvocation>
  resolveManager(method : Method, targetClass : Class<?>) : AuthorizationManager<MethodInvocation>
}
class AbstractExpressionAttributeRegistry    {
  cachedAttributes : Map<MethodClassKey,T>
  expressionHandler : MethodSecurityExpressionHandler
  getAttribute(mi : MethodInvocation) : T
  getAttribute(method : Method, targetClass : Class<?>) : T
  getExpressionHandler() : MethodSecurityExpressionHandler
  setExpressionHandler(expressionHandler : MethodSecurityExpressionHandler) : void
  setTemplateDefaults(defaults : PrePostTemplateDefaults) : void
  setTemplateDefaults(adapter : AnnotationTemplateExpressionDefaults) : void
  resolveAttribute(method : Method, targetClass : Class<?>) : T
  targetClass(method : Method, targetClass : Class<?>) : Class<?>
}
AbstractExpressionAttributeRegistry::targetClass --> java.lang.reflect.Method::getDeclaringClass : method.getDeclaringClass() 
interface AuthorizationAdvisor    {
}
class AuthorizationAdvisorProxyFactory    {
  isReactivePresent : boolean
  DEFAULT_VISITOR : TargetVisitor
  DEFAULT_VISITOR_SKIP_VALUE_TYPES : TargetVisitor
  authorizationProxy : AuthorizationProxyMethodInterceptor
  advisors : List<AuthorizationAdvisor>
  visitor : TargetVisitor
  AuthorizationAdvisorProxyFactory(advisors : List<AuthorizationAdvisor>) : None
  withDefaults() : AuthorizationAdvisorProxyFactory
  withReactiveDefaults() : AuthorizationAdvisorProxyFactory
  proxy(target : Object) : Object
  setAdvisors() : void
  setAdvisors(advisors : Collection<AuthorizationAdvisor>) : void
  addAdvisor(advisor : AuthorizationAdvisor) : void
  setTargetVisitor(visitor : TargetVisitor) : void
  iterator() : Iterator<AuthorizationAdvisor>
}
interface TargetVisitor    {
  visit(proxyFactory : AuthorizationAdvisorProxyFactory, target : Object) : Object
  defaults() : TargetVisitor
  defaultsSkipValueTypes() : TargetVisitor
  of() : TargetVisitor
}
class IgnoreValueTypeVisitor    {
  visit(proxyFactory : AuthorizationAdvisorProxyFactory, object : Object) : Object
}
class ClassVisitor    {
  authorizationProxy : AuthorizationProxyMethodInterceptor
  visit(proxyFactory : AuthorizationAdvisorProxyFactory, object : Object) : Object
}
class ContainerTypeVisitor    {
  visit(proxyFactory : AuthorizationAdvisorProxyFactory, target : Object) : Object
  proxyCast(proxyFactory : AuthorizationProxyFactory, target : T) : T
  proxyIterable(proxyFactory : AuthorizationProxyFactory, iterable : Iterable<T>) : Iterable<T>
  proxyIterator(proxyFactory : AuthorizationProxyFactory, iterator : Iterator<T>) : Iterator<T>
  hasNext() : boolean
  next() : T
  proxySortedSet(proxyFactory : AuthorizationProxyFactory, set : SortedSet<T>) : SortedSet<T>
  proxySet(proxyFactory : AuthorizationProxyFactory, set : Set<T>) : Set<T>
  proxyQueue(proxyFactory : AuthorizationProxyFactory, queue : Queue<T>) : Queue<T>
  proxyList(proxyFactory : AuthorizationProxyFactory, list : List<T>) : List<T>
  proxyArray(proxyFactory : AuthorizationProxyFactory, objects : Object[]) : Object[]
  proxySortedMap(proxyFactory : AuthorizationProxyFactory, entries : SortedMap<K,V>) : SortedMap<K,V>
  proxyMap(proxyFactory : AuthorizationProxyFactory, entries : Map<K,V>) : Map<K,V>
  proxyStream(proxyFactory : AuthorizationProxyFactory, stream : Stream<?>) : Stream<?>
  proxyOptional(proxyFactory : AuthorizationProxyFactory, optional : Optional<?>) : Optional<?>
  proxySupplier(proxyFactory : AuthorizationProxyFactory, supplier : Supplier<?>) : Supplier<?>
}
class ReactiveTypeVisitor    {
  visit(proxyFactory : AuthorizationAdvisorProxyFactory, target : Object) : Object
  proxyMono(proxyFactory : AuthorizationProxyFactory, mono : Mono<?>) : Mono<?>
  proxyFlux(proxyFactory : AuthorizationProxyFactory, flux : Flux<?>) : Flux<?>
}
class AuthorizationProxyMethodInterceptor    {
  GET_TARGET_METHOD : Method
  invoke(invocation : MethodInvocation) : Object
  getPointcut() : Pointcut
  getAdvice() : Advice
  getOrder() : int
}
class AuthorizationManagerAfterMethodInterceptor    {
  securityContextHolderStrategy : Supplier<SecurityContextHolderStrategy>
  logger : Log
  pointcut : Pointcut
  authorizationManager : AuthorizationManager<MethodInvocationResult>
  defaultHandler : MethodAuthorizationDeniedHandler
  order : int
  eventPublisher : AuthorizationEventPublisher
  AuthorizationManagerAfterMethodInterceptor(pointcut : Pointcut, authorizationManager : AuthorizationManager<MethodInvocationResult>) : None
  postAuthorize() : AuthorizationManagerAfterMethodInterceptor
  postAuthorize(authorizationManager : PostAuthorizeAuthorizationManager) : AuthorizationManagerAfterMethodInterceptor
  postAuthorize(authorizationManager : AuthorizationManager<MethodInvocationResult>) : AuthorizationManagerAfterMethodInterceptor
  invoke(mi : MethodInvocation) : Object
  getOrder() : int
  setOrder(order : int) : void
  setAuthorizationEventPublisher(eventPublisher : AuthorizationEventPublisher) : void
  getPointcut() : Pointcut
  getAdvice() : Advice
  isPerInstance() : boolean
  setSecurityContextHolderStrategy(strategy : SecurityContextHolderStrategy) : void
  attemptAuthorization(mi : MethodInvocation, result : Object) : Object
  handlePostInvocationDenied(mi : MethodInvocationResult, result : AuthorizationResult) : Object
  getAuthentication() : Authentication
}
AuthorizationManagerAfterMethodInterceptor::attemptAuthorization --> org.springframework.security.authorization.AuthorizationEventPublisher::publishAuthorizationEvent : eventPublisher.publishAuthorizationEvent(this::getAuthentication,object,authorizationResult) 
class AuthorizationManagerAfterReactiveMethodInterceptor    {
  COROUTINES_FLOW_CLASS_NAME : String
  RETURN_TYPE_METHOD_PARAMETER_INDEX : int
  pointcut : Pointcut
  authorizationManager : ReactiveAuthorizationManager<MethodInvocationResult>
  order : int
  defaultHandler : MethodAuthorizationDeniedHandler
  postAuthorize() : AuthorizationManagerAfterReactiveMethodInterceptor
  postAuthorize(authorizationManager : ReactiveAuthorizationManager<MethodInvocationResult>) : AuthorizationManagerAfterReactiveMethodInterceptor
  AuthorizationManagerAfterReactiveMethodInterceptor(pointcut : Pointcut, authorizationManager : ReactiveAuthorizationManager<MethodInvocationResult>) : None
  invoke(mi : MethodInvocation) : Object
  isMultiValue(returnType : Class<?>, adapter : ReactiveAdapter) : boolean
  postAuthorize(authentication : Mono<Authentication>, mi : MethodInvocation, result : Object) : Mono<Object>
  postProcess(decision : AuthorizationResult, methodInvocationResult : MethodInvocationResult) : Mono<Object>
  postProcess(decision : AuthorizationResult, methodInvocation : MethodInvocation) : Mono<Object>
  getPointcut() : Pointcut
  getAdvice() : Advice
  isPerInstance() : boolean
  getOrder() : int
  setOrder(order : int) : void
}
class KotlinDelegate    {
  asFlow(publisher : Publisher<?>) : Object
}
class AuthorizationManagerBeforeMethodInterceptor    {
  securityContextHolderStrategy : Supplier<SecurityContextHolderStrategy>
  logger : Log
  pointcut : Pointcut
  authorizationManager : AuthorizationManager<MethodInvocation>
  defaultHandler : MethodAuthorizationDeniedHandler
  order : int
  eventPublisher : AuthorizationEventPublisher
  AuthorizationManagerBeforeMethodInterceptor(pointcut : Pointcut, authorizationManager : AuthorizationManager<MethodInvocation>) : None
  preAuthorize() : AuthorizationManagerBeforeMethodInterceptor
  preAuthorize(authorizationManager : PreAuthorizeAuthorizationManager) : AuthorizationManagerBeforeMethodInterceptor
  preAuthorize(authorizationManager : AuthorizationManager<MethodInvocation>) : AuthorizationManagerBeforeMethodInterceptor
  secured() : AuthorizationManagerBeforeMethodInterceptor
  secured(authorizationManager : SecuredAuthorizationManager) : AuthorizationManagerBeforeMethodInterceptor
  secured(authorizationManager : AuthorizationManager<MethodInvocation>) : AuthorizationManagerBeforeMethodInterceptor
  jsr250() : AuthorizationManagerBeforeMethodInterceptor
  jsr250(authorizationManager : Jsr250AuthorizationManager) : AuthorizationManagerBeforeMethodInterceptor
  jsr250(authorizationManager : AuthorizationManager<MethodInvocation>) : AuthorizationManagerBeforeMethodInterceptor
  invoke(mi : MethodInvocation) : Object
  getOrder() : int
  setOrder(order : int) : void
  setAuthorizationEventPublisher(eventPublisher : AuthorizationEventPublisher) : void
  getPointcut() : Pointcut
  getAdvice() : Advice
  isPerInstance() : boolean
  setSecurityContextHolderStrategy(securityContextHolderStrategy : SecurityContextHolderStrategy) : void
  attemptAuthorization(mi : MethodInvocation) : Object
  proceed(mi : MethodInvocation) : Object
  handle(mi : MethodInvocation, denied : AuthorizationDeniedException) : Object
  handle(mi : MethodInvocation, result : AuthorizationResult) : Object
  getAuthentication() : Authentication
}
AuthorizationManagerBeforeMethodInterceptor::attemptAuthorization --> org.springframework.security.authorization.AuthorizationEventPublisher::publishAuthorizationEvent : eventPublisher.publishAuthorizationEvent(this::getAuthentication,mi,result) 
class AuthorizationManagerBeforeReactiveMethodInterceptor    {
  COROUTINES_FLOW_CLASS_NAME : String
  RETURN_TYPE_METHOD_PARAMETER_INDEX : int
  pointcut : Pointcut
  authorizationManager : ReactiveAuthorizationManager<MethodInvocation>
  order : int
  defaultHandler : MethodAuthorizationDeniedHandler
  preAuthorize() : AuthorizationManagerBeforeReactiveMethodInterceptor
  preAuthorize(authorizationManager : ReactiveAuthorizationManager<MethodInvocation>) : AuthorizationManagerBeforeReactiveMethodInterceptor
  AuthorizationManagerBeforeReactiveMethodInterceptor(pointcut : Pointcut, authorizationManager : ReactiveAuthorizationManager<MethodInvocation>) : None
  invoke(mi : MethodInvocation) : Object
  preAuthorized(mi : MethodInvocation, mapping : Flux<Object>) : Flux<Object>
  preAuthorized(mi : MethodInvocation, mapping : Mono<Object>) : Mono<Object>
  postProcess(decision : AuthorizationResult, mi : MethodInvocation) : Mono<Object>
  isMultiValue(returnType : Class<?>, adapter : ReactiveAdapter) : boolean
  getPointcut() : Pointcut
  getAdvice() : Advice
  isPerInstance() : boolean
  getOrder() : int
  setOrder(order : int) : void
}
class KotlinDelegate    {
  asFlow(publisher : Publisher<?>) : Object
}
class AuthorizationMethodPointcuts    {
  forAllAnnotations() : Pointcut
  forAnnotations() : Pointcut
  classOrMethod(annotation : Class<?extendsAnnotation>) : Pointcut
  AuthorizationMethodPointcuts() : None
}
interface AuthorizationProxy    {
  toAuthorizedTarget() : Object
}
class AuthorizeReturnObjectMethodInterceptor    {
  authorizationProxyFactory : AuthorizationProxyFactory
  pointcut : Pointcut
  order : int
  AuthorizeReturnObjectMethodInterceptor(authorizationProxyFactory : AuthorizationProxyFactory) : None
  invoke(mi : MethodInvocation) : Object
  getOrder() : int
  setOrder(order : int) : void
  getPointcut() : Pointcut
  setPointcut(pointcut : Pointcut) : void
  getAdvice() : Advice
  isPerInstance() : boolean
}
AuthorizeReturnObjectMethodInterceptor::invoke --> org.springframework.security.authorization.AuthorizationProxyFactory::proxy : authorizationProxyFactory.proxy(result) 
class MethodReturnTypePointcut    {
  returnTypeMatches : Predicate<Class<?>>
  MethodReturnTypePointcut(returnTypeMatches : Predicate<Class<?>>) : None
  matches(method : Method, targetClass : Class<?>) : boolean
}
class ExpressionAttribute    {
  NULL_ATTRIBUTE : ExpressionAttribute
  expression : Expression
  ExpressionAttribute(expression : Expression) : None
  getExpression() : Expression
  toString() : String
}
ExpressionAttribute::toString --> org.springframework.expression.Expression::getExpressionString : expression.getExpressionString() 
class ExpressionAttributeAuthorizationDecision extends org.springframework.security.authorization.AuthorizationDecision   {
  expressionAttribute : ExpressionAttribute
  ExpressionAttributeAuthorizationDecision(granted : boolean, expressionAttribute : ExpressionAttribute) : None
  getExpressionAttribute() : ExpressionAttribute
  toString() : String
}
class ExpressionUtils    {
  ExpressionUtils() : None
  evaluate(expr : Expression, ctx : EvaluationContext) : AuthorizationResult
  findAuthorizationException(ex : EvaluationException) : AuthorizationDeniedException
}
ExpressionUtils::findAuthorizationException --> org.springframework.expression.EvaluationException::getCause : ex.getCause() 
class Jsr250AuthorizationManager    {
  registry : Jsr250AuthorizationManagerRegistry
  authoritiesAuthorizationManager : AuthorizationManager<Collection<String>>
  rolePrefix : String
  setAuthoritiesAuthorizationManager(authoritiesAuthorizationManager : AuthorizationManager<Collection<String>>) : void
  setRolePrefix(rolePrefix : String) : void
  check(authentication : Supplier<Authentication>, methodInvocation : MethodInvocation) : AuthorizationDecision
}
class Jsr250AuthorizationManagerRegistry    {
  scanner : SecurityAnnotationScanner<?>
  resolveManager(method : Method, targetClass : Class<?>) : AuthorizationManager<MethodInvocation>
  findJsr250Annotation(method : Method, targetClass : Class<?>) : Annotation
  getAllowedRolesWithPrefix(rolesAllowed : RolesAllowed) : Set<String>
}
interface AuthorizationManagerCheckAdapter    {
  check(authentication : Supplier<Authentication>, object : T) : AuthorizationDecision
  authorize(authentication : Supplier<Authentication>, object : T) : AuthorizationResult
}
interface MethodAuthorizationDeniedHandler    {
  handleDeniedInvocation(methodInvocation : MethodInvocation, authorizationResult : AuthorizationResult) : Object
  handleDeniedInvocationResult(methodInvocationResult : MethodInvocationResult, authorizationResult : AuthorizationResult) : Object
}
class MethodExpressionAuthorizationManager    {
  expressionHandler : SecurityExpressionHandler<MethodInvocation>
  expression : Expression
  MethodExpressionAuthorizationManager(expressionString : String) : None
  setExpressionHandler(expressionHandler : SecurityExpressionHandler<MethodInvocation>) : void
  check(authentication : Supplier<Authentication>, context : MethodInvocation) : AuthorizationDecision
  toString() : String
}
MethodExpressionAuthorizationManager::setExpressionHandler --> org.springframework.expression.Expression::getExpressionString : expression.getExpressionString() 
class MethodInvocationResult    {
  methodInvocation : MethodInvocation
  result : Object
  MethodInvocationResult(methodInvocation : MethodInvocation, result : Object) : None
  getMethodInvocation() : MethodInvocation
  getResult() : Object
}
class NoOpAuthorizationEventPublisher  implements org.springframework.security.authorization.AuthorizationEventPublisher  {
  publishAuthorizationEvent(authentication : Supplier<Authentication>, object : T, decision : AuthorizationDecision) : void
  publishAuthorizationEvent(authentication : Supplier<Authentication>, object : T, result : AuthorizationResult) : void
}
class PostAuthorizeAuthorizationManager    {
  registry : PostAuthorizeExpressionAttributeRegistry
  setExpressionHandler(expressionHandler : MethodSecurityExpressionHandler) : void
  setTemplateDefaults(defaults : PrePostTemplateDefaults) : void
  setTemplateDefaults(defaults : AnnotationTemplateExpressionDefaults) : void
  setApplicationContext(context : ApplicationContext) : void
  check(authentication : Supplier<Authentication>, mi : MethodInvocationResult) : AuthorizationDecision
  handleDeniedInvocation(methodInvocation : MethodInvocation, authorizationResult : AuthorizationResult) : Object
  handleDeniedInvocationResult(methodInvocationResult : MethodInvocationResult, authorizationResult : AuthorizationResult) : Object
}
class PostAuthorizeExpressionAttribute    {
  handler : MethodAuthorizationDeniedHandler
  PostAuthorizeExpressionAttribute(expression : Expression, handler : MethodAuthorizationDeniedHandler) : None
  getHandler() : MethodAuthorizationDeniedHandler
}
class PostAuthorizeExpressionAttributeRegistry    {
  defaultHandler : MethodAuthorizationDeniedHandler
  handleAuthorizationDeniedScanner : SecurityAnnotationScanner<HandleAuthorizationDenied>
  handlerResolver : Function<Class<?extendsMethodAuthorizationDeniedHandler>,MethodAuthorizationDeniedHandler>
  postAuthorizeScanner : SecurityAnnotationScanner<PostAuthorize>
  PostAuthorizeExpressionAttributeRegistry() : None
  resolveAttribute(method : Method, targetClass : Class<?>) : ExpressionAttribute
  resolveHandler(method : Method, targetClass : Class<?>) : MethodAuthorizationDeniedHandler
  findPostAuthorizeAnnotation(method : Method, targetClass : Class<?>) : PostAuthorize
  setApplicationContext(context : ApplicationContext) : void
  setTemplateDefaults(templateDefaults : AnnotationTemplateExpressionDefaults) : void
  resolveHandler(context : ApplicationContext, handlerClass : Class<?extendsMethodAuthorizationDeniedHandler>) : MethodAuthorizationDeniedHandler
}
PostAuthorizeExpressionAttributeRegistry::resolveHandler --> org.springframework.context.ApplicationContext::getBeanNamesForType : context.getBeanNamesForType(handlerClass) 
PostAuthorizeExpressionAttributeRegistry::resolveHandler --> org.springframework.context.ApplicationContext::getBean : context.getBean(beanNames[0],handlerClass) 
class PostAuthorizeReactiveAuthorizationManager    {
  registry : PostAuthorizeExpressionAttributeRegistry
  PostAuthorizeReactiveAuthorizationManager() : None
  PostAuthorizeReactiveAuthorizationManager(expressionHandler : MethodSecurityExpressionHandler) : None
  setTemplateDefaults(defaults : PrePostTemplateDefaults) : void
  setTemplateDefaults(defaults : AnnotationTemplateExpressionDefaults) : void
  setApplicationContext(context : ApplicationContext) : void
  check(authentication : Mono<Authentication>, result : MethodInvocationResult) : Mono<AuthorizationDecision>
  handleDeniedInvocation(methodInvocation : MethodInvocation, authorizationResult : AuthorizationResult) : Object
  handleDeniedInvocationResult(methodInvocationResult : MethodInvocationResult, authorizationResult : AuthorizationResult) : Object
}
class PostFilterAuthorizationMethodInterceptor    {
  securityContextHolderStrategy : Supplier<SecurityContextHolderStrategy>
  registry : PostFilterExpressionAttributeRegistry
  order : int
  pointcut : Pointcut
  PostFilterAuthorizationMethodInterceptor() : None
  setExpressionHandler(expressionHandler : MethodSecurityExpressionHandler) : void
  setTemplateDefaults(defaults : PrePostTemplateDefaults) : void
  setTemplateDefaults(defaults : AnnotationTemplateExpressionDefaults) : void
  getOrder() : int
  setOrder(order : int) : void
  getPointcut() : Pointcut
  getAdvice() : Advice
  isPerInstance() : boolean
  setSecurityContextHolderStrategy(strategy : SecurityContextHolderStrategy) : void
  invoke(mi : MethodInvocation) : Object
  getAuthentication() : Authentication
}
class PostFilterAuthorizationReactiveMethodInterceptor    {
  registry : PostFilterExpressionAttributeRegistry
  pointcut : Pointcut
  order : int
  PostFilterAuthorizationReactiveMethodInterceptor() : None
  PostFilterAuthorizationReactiveMethodInterceptor(expressionHandler : MethodSecurityExpressionHandler) : None
  setTemplateDefaults(defaults : PrePostTemplateDefaults) : void
  setTemplateDefaults(defaults : AnnotationTemplateExpressionDefaults) : void
  invoke(mi : MethodInvocation) : Object
  isMultiValue(returnType : Class<?>, adapter : ReactiveAdapter) : boolean
  filterSingleValue(publisher : Publisher<?>, ctx : EvaluationContext, attribute : ExpressionAttribute) : Mono<?>
  filterMultiValue(publisher : Publisher<?>, ctx : EvaluationContext, attribute : ExpressionAttribute) : Flux<?>
  setFilterObject(ctx : EvaluationContext, result : Object) : void
  postFilter(ctx : EvaluationContext, result : Object, attribute : ExpressionAttribute) : Mono<?>
  getPointcut() : Pointcut
  getAdvice() : Advice
  isPerInstance() : boolean
  getOrder() : int
  setOrder(order : int) : void
}
class PostFilterExpressionAttributeRegistry    {
  scanner : SecurityAnnotationScanner<PostFilter>
  resolveAttribute(method : Method, targetClass : Class<?>) : ExpressionAttribute
  setTemplateDefaults(defaults : AnnotationTemplateExpressionDefaults) : void
  findPostFilterAnnotation(method : Method, targetClass : Class<?>) : PostFilter
}
class PreAuthorizeAuthorizationManager    {
  registry : PreAuthorizeExpressionAttributeRegistry
  setExpressionHandler(expressionHandler : MethodSecurityExpressionHandler) : void
  setTemplateDefaults(defaults : PrePostTemplateDefaults) : void
  setTemplateDefaults(defaults : AnnotationTemplateExpressionDefaults) : void
  setApplicationContext(context : ApplicationContext) : void
  check(authentication : Supplier<Authentication>, mi : MethodInvocation) : AuthorizationDecision
  handleDeniedInvocation(methodInvocation : MethodInvocation, authorizationResult : AuthorizationResult) : Object
}
class PreAuthorizeExpressionAttribute    {
  handler : MethodAuthorizationDeniedHandler
  PreAuthorizeExpressionAttribute(expression : Expression, handler : MethodAuthorizationDeniedHandler) : None
  getHandler() : MethodAuthorizationDeniedHandler
}
class PreAuthorizeExpressionAttributeRegistry    {
  defaultHandler : MethodAuthorizationDeniedHandler
  handleAuthorizationDeniedScanner : SecurityAnnotationScanner<HandleAuthorizationDenied>
  handlerResolver : Function<Class<?extendsMethodAuthorizationDeniedHandler>,MethodAuthorizationDeniedHandler>
  preAuthorizeScanner : SecurityAnnotationScanner<PreAuthorize>
  PreAuthorizeExpressionAttributeRegistry() : None
  resolveAttribute(method : Method, targetClass : Class<?>) : ExpressionAttribute
  resolveHandler(method : Method, targetClass : Class<?>) : MethodAuthorizationDeniedHandler
  findPreAuthorizeAnnotation(method : Method, targetClass : Class<?>) : PreAuthorize
  setApplicationContext(context : ApplicationContext) : void
  setTemplateDefaults(defaults : AnnotationTemplateExpressionDefaults) : void
  resolveHandler(context : ApplicationContext, handlerClass : Class<?extendsMethodAuthorizationDeniedHandler>) : MethodAuthorizationDeniedHandler
}
PreAuthorizeExpressionAttributeRegistry::resolveHandler --> org.springframework.context.ApplicationContext::getBeanNamesForType : context.getBeanNamesForType(handlerClass) 
PreAuthorizeExpressionAttributeRegistry::resolveHandler --> org.springframework.context.ApplicationContext::getBean : context.getBean(beanNames[0],handlerClass) 
class PreAuthorizeReactiveAuthorizationManager    {
  registry : PreAuthorizeExpressionAttributeRegistry
  PreAuthorizeReactiveAuthorizationManager() : None
  PreAuthorizeReactiveAuthorizationManager(expressionHandler : MethodSecurityExpressionHandler) : None
  setTemplateDefaults(defaults : PrePostTemplateDefaults) : void
  setTemplateDefaults(defaults : AnnotationTemplateExpressionDefaults) : void
  setApplicationContext(context : ApplicationContext) : void
  check(authentication : Mono<Authentication>, mi : MethodInvocation) : Mono<AuthorizationDecision>
  handleDeniedInvocation(methodInvocation : MethodInvocation, authorizationResult : AuthorizationResult) : Object
}
class PreFilterAuthorizationMethodInterceptor    {
  securityContextHolderStrategy : Supplier<SecurityContextHolderStrategy>
  registry : PreFilterExpressionAttributeRegistry
  order : int
  pointcut : Pointcut
  PreFilterAuthorizationMethodInterceptor() : None
  setExpressionHandler(expressionHandler : MethodSecurityExpressionHandler) : void
  setTemplateDefaults(defaults : PrePostTemplateDefaults) : void
  setTemplateDefaults(defaults : AnnotationTemplateExpressionDefaults) : void
  getOrder() : int
  setOrder(order : int) : void
  getPointcut() : Pointcut
  getAdvice() : Advice
  isPerInstance() : boolean
  setSecurityContextHolderStrategy(strategy : SecurityContextHolderStrategy) : void
  invoke(mi : MethodInvocation) : Object
  findFilterTarget(filterTargetName : String, ctx : EvaluationContext, methodInvocation : MethodInvocation) : Object
  getAuthentication() : Authentication
}
class PreFilterAuthorizationReactiveMethodInterceptor    {
  registry : PreFilterExpressionAttributeRegistry
  pointcut : Pointcut
  parameterNameDiscoverer : ParameterNameDiscoverer
  order : int
  PreFilterAuthorizationReactiveMethodInterceptor() : None
  PreFilterAuthorizationReactiveMethodInterceptor(expressionHandler : MethodSecurityExpressionHandler) : None
  setTemplateDefaults(defaults : PrePostTemplateDefaults) : void
  setTemplateDefaults(defaults : AnnotationTemplateExpressionDefaults) : void
  setParameterNameDiscoverer(parameterNameDiscoverer : ParameterNameDiscoverer) : void
  invoke(mi : MethodInvocation) : Object
  findFilterTarget(name : String, mi : MethodInvocation) : FilterTarget
  isMultiValue(returnType : Class<?>, adapter : ReactiveAdapter) : boolean
  filterSingleValue(filterTarget : Publisher<?>, filterExpression : Expression, ctx : EvaluationContext) : Mono<?>
  filterMultiValue(filterTarget : Publisher<?>, filterExpression : Expression, ctx : EvaluationContext) : Flux<?>
  getPointcut() : Pointcut
  getAdvice() : Advice
  isPerInstance() : boolean
  getOrder() : int
  setOrder(order : int) : void
}
PreFilterAuthorizationReactiveMethodInterceptor::findFilterTarget --> org.springframework.core.ParameterNameDiscoverer::getParameterNames : parameterNameDiscoverer.getParameterNames(specificMethod) 
class FilterTarget    {
  value : Publisher<?>
  index : int
  FilterTarget(value : Publisher<?>, index : int) : None
}
class PreFilterExpressionAttributeRegistry    {
  scanner : SecurityAnnotationScanner<PreFilter>
  resolveAttribute(method : Method, targetClass : Class<?>) : PreFilterExpressionAttribute
  setTemplateDefaults(defaults : AnnotationTemplateExpressionDefaults) : void
  findPreFilterAnnotation(method : Method, targetClass : Class<?>) : PreFilter
}
class PreFilterExpressionAttribute    {
  NULL_ATTRIBUTE : PreFilterExpressionAttribute
  filterTarget : String
  PreFilterExpressionAttribute(expression : Expression, filterTarget : String) : None
  getFilterTarget() : String
}
class PrePostTemplateDefaults    {
  ignoreUnknown : boolean
  isIgnoreUnknown() : boolean
  setIgnoreUnknown(ignoreUnknown : boolean) : void
}
class ReactiveAuthenticationUtils    {
  ANONYMOUS : Authentication
  getAuthentication() : Mono<Authentication>
  ReactiveAuthenticationUtils() : None
}
class ReactiveExpressionUtils    {
  evaluate(expr : Expression, ctx : EvaluationContext) : Mono<AuthorizationResult>
  adapt(expr : Expression, value : Object) : Mono<AuthorizationResult>
  evaluateAsBoolean(expr : Expression, ctx : EvaluationContext) : Mono<Boolean>
  createInvalidReturnTypeMono(expr : Expression) : Mono<T>
  ReactiveExpressionUtils() : None
}
class ReactiveMethodInvocationUtils    {
  proceed(mi : MethodInvocation) : T
  ReactiveMethodInvocationUtils() : None
}
class ReflectiveMethodAuthorizationDeniedHandler    {
  logger : Log
  targetClass : Class<?>
  managerClass : Class<?>
  ReflectiveMethodAuthorizationDeniedHandler(targetClass : Class<?>, managerClass : Class<?>) : None
  handleDeniedInvocation(methodInvocation : MethodInvocation, authorizationResult : AuthorizationResult) : Object
  handleDeniedInvocationResult(methodInvocationResult : MethodInvocationResult, authorizationResult : AuthorizationResult) : Object
  constructMethodAuthorizationDeniedHandler() : MethodAuthorizationDeniedHandler
}
class SecuredAuthorizationManager    {
  authoritiesAuthorizationManager : AuthorizationManager<Collection<String>>
  cachedAuthorities : Map<MethodClassKey,Set<String>>
  scanner : SecurityAnnotationScanner<Secured>
  setAuthoritiesAuthorizationManager(authoritiesAuthorizationManager : AuthorizationManager<Collection<String>>) : void
  check(authentication : Supplier<Authentication>, mi : MethodInvocation) : AuthorizationDecision
  getAuthorities(methodInvocation : MethodInvocation) : Set<String>
  resolveAuthorities(method : Method, targetClass : Class<?>) : Set<String>
  findSecuredAnnotation(method : Method, targetClass : Class<?>) : Secured
}
SecuredAuthorizationManager::findSecuredAnnotation --> java.lang.reflect.Method::getDeclaringClass : method.getDeclaringClass() 
class ThrowingMethodAuthorizationDeniedHandler    {
  handleDeniedInvocation(methodInvocation : MethodInvocation, authorizationResult : AuthorizationResult) : Object
  handleDeniedInvocationResult(methodInvocationResult : MethodInvocationResult, authorizationResult : AuthorizationResult) : Object
}
}
class AuthenticatedAuthorizationManager    {
  authorizationStrategy : AbstractAuthorizationStrategy
  AuthenticatedAuthorizationManager() : None
  AuthenticatedAuthorizationManager(authorizationStrategy : AbstractAuthorizationStrategy) : None
  setTrustResolver(trustResolver : AuthenticationTrustResolver) : void
  authenticated() : AuthenticatedAuthorizationManager<T>
  fullyAuthenticated() : AuthenticatedAuthorizationManager<T>
  rememberMe() : AuthenticatedAuthorizationManager<T>
  anonymous() : AuthenticatedAuthorizationManager<T>
  check(authentication : Supplier<Authentication>, object : T) : AuthorizationDecision
}
class AbstractAuthorizationStrategy    {
  trustResolver : AuthenticationTrustResolver
  setTrustResolver(trustResolver : AuthenticationTrustResolver) : void
  isGranted(authentication : Authentication) : boolean
}
class AuthenticatedAuthorizationStrategy    {
  isGranted(authentication : Authentication) : boolean
}
class FullyAuthenticatedAuthorizationStrategy    {
  isGranted(authentication : Authentication) : boolean
}
class AnonymousAuthorizationStrategy    {
  isGranted(authentication : Authentication) : boolean
}
class RememberMeAuthorizationStrategy    {
  isGranted(authentication : Authentication) : boolean
}
class AuthenticatedReactiveAuthorizationManager    {
  authTrustResolver : AuthenticationTrustResolver
  AuthenticatedReactiveAuthorizationManager() : None
  check(authentication : Mono<Authentication>, object : T) : Mono<AuthorizationDecision>
  getAuthorizationDecision(authentication : Authentication) : AuthorizationDecision
  isNotAnonymous(authentication : Authentication) : boolean
  authenticated() : AuthenticatedReactiveAuthorizationManager<T>
}
AuthenticatedReactiveAuthorizationManager::isNotAnonymous --> org.springframework.security.authentication.AuthenticationTrustResolver::isAnonymous : authTrustResolver.isAnonymous(authentication) 
class AuthoritiesAuthorizationManager    {
  roleHierarchy : RoleHierarchy
  setRoleHierarchy(roleHierarchy : RoleHierarchy) : void
  check(authentication : Supplier<Authentication>, authorities : Collection<String>) : AuthorityAuthorizationDecision
  isGranted(authentication : Authentication, authorities : Collection<String>) : boolean
  isAuthorized(authentication : Authentication, authorities : Collection<String>) : boolean
  getGrantedAuthorities(authentication : Authentication) : Collection<?extendsGrantedAuthority>
}
AuthoritiesAuthorizationManager::check --> org.springframework.security.core.Authentication::get : authentication.get() 
AuthoritiesAuthorizationManager::getGrantedAuthorities --> org.springframework.security.access.hierarchicalroles.RoleHierarchy::getReachableGrantedAuthorities : roleHierarchy.getReachableGrantedAuthorities(authentication.getAuthorities()) 
AuthoritiesAuthorizationManager::getGrantedAuthorities --> org.springframework.security.core.Authentication::getAuthorities : authentication.getAuthorities() 
class AuthorityAuthorizationDecision    {
  serialVersionUID : long
  authorities : Collection<GrantedAuthority>
  AuthorityAuthorizationDecision(granted : boolean, authorities : Collection<GrantedAuthority>) : None
  getAuthorities() : Collection<GrantedAuthority>
  toString() : String
}
class AuthorityAuthorizationManager    {
  ROLE_PREFIX : String
  delegate : AuthoritiesAuthorizationManager
  authorities : Set<String>
  AuthorityAuthorizationManager() : None
  setRoleHierarchy(roleHierarchy : RoleHierarchy) : void
  hasRole(role : String) : AuthorityAuthorizationManager<T>
  hasAuthority(authority : String) : AuthorityAuthorizationManager<T>
  hasAnyRole() : AuthorityAuthorizationManager<T>
  hasAnyRole(rolePrefix : String, roles : String[]) : AuthorityAuthorizationManager<T>
  hasAnyAuthority() : AuthorityAuthorizationManager<T>
  toNamedRolesArray(rolePrefix : String, roles : String[]) : String[]
  check(authentication : Supplier<Authentication>, object : T) : AuthorizationDecision
  toString() : String
}
class AuthorityReactiveAuthorizationManager    {
  authorities : List<GrantedAuthority>
  AuthorityReactiveAuthorizationManager() : None
  check(authentication : Mono<Authentication>, object : T) : Mono<AuthorizationDecision>
  hasAuthority(authority : String) : AuthorityReactiveAuthorizationManager<T>
  hasAnyAuthority() : AuthorityReactiveAuthorizationManager<T>
  hasRole(role : String) : AuthorityReactiveAuthorizationManager<T>
  hasAnyRole() : AuthorityReactiveAuthorizationManager<T>
  toNamedRolesArray() : String[]
}
class AuthorizationDecision    {
  serialVersionUID : long
  granted : boolean
  AuthorizationDecision(granted : boolean) : None
  isGranted() : boolean
  toString() : String
}
class AuthorizationDeniedException extends org.springframework.security.access.AccessDeniedException   {
  serialVersionUID : long
  result : AuthorizationResult
  AuthorizationDeniedException(msg : String, authorizationResult : AuthorizationResult) : None
  AuthorizationDeniedException(msg : String) : None
  getAuthorizationResult() : AuthorizationResult
  isGranted() : boolean
}
interface AuthorizationEventPublisher    {
  publishAuthorizationEvent(authentication : Supplier<Authentication>, object : T, decision : AuthorizationDecision) : void
  publishAuthorizationEvent(authentication : Supplier<Authentication>, object : T, result : AuthorizationResult) : void
}
interface AuthorizationManager    {
  verify(authentication : Supplier<Authentication>, object : T) : void
  check(authentication : Supplier<Authentication>, object : T) : AuthorizationDecision
  authorize(authentication : Supplier<Authentication>, object : T) : AuthorizationResult
}
class AuthorizationManagers    {
  anyOf() : AuthorizationManager<T>
  anyOf(allAbstainDefaultDecision : AuthorizationDecision) : AuthorizationManager<T>
  allOf() : AuthorizationManager<T>
  allOf(allAbstainDefaultDecision : AuthorizationDecision) : AuthorizationManager<T>
  not(manager : AuthorizationManager<T>) : AuthorizationManager<T>
  AuthorizationManagers() : None
}
class CompositeAuthorizationDecision    {
  results : List<AuthorizationResult>
  CompositeAuthorizationDecision(granted : boolean, results : List<AuthorizationResult>) : None
  toString() : String
}
class NotAuthorizationDecision    {
  result : AuthorizationResult
  NotAuthorizationDecision(result : AuthorizationResult) : None
  toString() : String
}
interface AuthorizationManagerCheckAdapter    {
  check(authentication : Supplier<Authentication>, object : T) : AuthorizationDecision
  authorize(authentication : Supplier<Authentication>, object : T) : AuthorizationResult
}
class AuthorizationObservationContext    {
  authentication : Authentication
  object : T
  authorizationResult : AuthorizationResult
  AuthorizationObservationContext(object : T) : None
  getAuthentication() : Authentication
  setAuthentication(authentication : Authentication) : void
  getObject() : T
  getDecision() : AuthorizationDecision
  setDecision(decision : AuthorizationDecision) : void
  getAuthorizationResult() : AuthorizationResult
  setAuthorizationResult(authorizationResult : AuthorizationResult) : void
}
class AuthorizationObservationConvention    {
  OBSERVATION_NAME : String
  getName() : String
  getContextualName(context : AuthorizationObservationContext<?>) : String
  getLowCardinalityKeyValues(context : AuthorizationObservationContext<?>) : KeyValues
  getHighCardinalityKeyValues(context : AuthorizationObservationContext<?>) : KeyValues
  supportsContext(context : Observation.Context) : boolean
  getAuthenticationType(context : AuthorizationObservationContext<?>) : String
  getObjectType(context : AuthorizationObservationContext<?>) : String
  getAuthorizationDecision(context : AuthorizationObservationContext<?>) : String
  getAuthorities(context : AuthorizationObservationContext<?>) : String
  getDecisionDetails(context : AuthorizationObservationContext<?>) : String
}
interface AuthorizationProxyFactory    {
  proxy(object : Object) : Object
}
interface AuthorizationResult    {
  isGranted() : boolean
}
class ExpressionAuthorizationDecision    {
  expression : Expression
  ExpressionAuthorizationDecision(granted : boolean, expressionAttribute : Expression) : None
  getExpression() : Expression
  toString() : String
}
ExpressionAuthorizationDecision::toString --> org.springframework.expression.Expression::getExpressionString : expression.getExpressionString() 
class ObservationAuthorizationManager    {
  registry : ObservationRegistry
  delegate : AuthorizationManager<T>
  convention : ObservationConvention<AuthorizationObservationContext<?>>
  messages : MessageSourceAccessor
  handler : MethodAuthorizationDeniedHandler
  ObservationAuthorizationManager(registry : ObservationRegistry, delegate : AuthorizationManager<T>) : None
  check(authentication : Supplier<Authentication>, object : T) : AuthorizationDecision
  setObservationConvention(convention : ObservationConvention<AuthorizationObservationContext<?>>) : void
  setMessageSource(messageSource : MessageSource) : void
  handleDeniedInvocation(methodInvocation : MethodInvocation, authorizationResult : AuthorizationResult) : Object
  handleDeniedInvocationResult(methodInvocationResult : MethodInvocationResult, authorizationResult : AuthorizationResult) : Object
}
ObservationAuthorizationManager::check --> org.springframework.context.support.MessageSourceAccessor::getMessage : messages.getMessage("AbstractAccessDecisionManager.accessDenied","Access Denied") 
ObservationAuthorizationManager::handleDeniedInvocation --> org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler::handleDeniedInvocation : handler.handleDeniedInvocation(methodInvocation,authorizationResult) 
ObservationAuthorizationManager::handleDeniedInvocationResult --> org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler::handleDeniedInvocationResult : handler.handleDeniedInvocationResult(methodInvocationResult,authorizationResult) 
class ObservationReactiveAuthorizationManager    {
  registry : ObservationRegistry
  delegate : ReactiveAuthorizationManager<T>
  convention : ObservationConvention<AuthorizationObservationContext<?>>
  handler : MethodAuthorizationDeniedHandler
  ObservationReactiveAuthorizationManager(registry : ObservationRegistry, delegate : ReactiveAuthorizationManager<T>) : None
  check(authentication : Mono<Authentication>, object : T) : Mono<AuthorizationDecision>
  setObservationConvention(convention : ObservationConvention<AuthorizationObservationContext<?>>) : void
  handleDeniedInvocation(methodInvocation : MethodInvocation, authorizationResult : AuthorizationResult) : Object
  handleDeniedInvocationResult(methodInvocationResult : MethodInvocationResult, authorizationResult : AuthorizationResult) : Object
}
ObservationReactiveAuthorizationManager::handleDeniedInvocation --> org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler::handleDeniedInvocation : handler.handleDeniedInvocation(methodInvocation,authorizationResult) 
ObservationReactiveAuthorizationManager::handleDeniedInvocationResult --> org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler::handleDeniedInvocationResult : handler.handleDeniedInvocationResult(methodInvocationResult,authorizationResult) 
interface ReactiveAuthorizationManager    {
  check(authentication : Mono<Authentication>, object : T) : Mono<AuthorizationDecision>
  verify(authentication : Mono<Authentication>, object : T) : Mono<Void>
  authorize(authentication : Mono<Authentication>, object : T) : Mono<AuthorizationResult>
}
class SingleResultAuthorizationManager    {
  DENY_MANAGER : SingleResultAuthorizationManager<?>
  PERMIT_MANAGER : SingleResultAuthorizationManager<?>
  result : AuthorizationResult
  SingleResultAuthorizationManager(result : AuthorizationResult) : None
  check(authentication : Supplier<Authentication>, object : C) : AuthorizationDecision
  authorize(authentication : Supplier<Authentication>, object : C) : AuthorizationResult
  denyAll() : SingleResultAuthorizationManager<C>
  permitAll() : SingleResultAuthorizationManager<C>
}
class SpringAuthorizationEventPublisher    {
  eventPublisher : ApplicationEventPublisher
  SpringAuthorizationEventPublisher(eventPublisher : ApplicationEventPublisher) : None
  publishAuthorizationEvent(authentication : Supplier<Authentication>, object : T, decision : AuthorizationDecision) : void
  publishAuthorizationEvent(authentication : Supplier<Authentication>, object : T, result : AuthorizationResult) : void
}
SpringAuthorizationEventPublisher::publishAuthorizationEvent --> org.springframework.context.ApplicationEventPublisher::publishEvent : eventPublisher.publishEvent(failure) 
}
package concurrent {
class AbstractDelegatingSecurityContextSupport    {
  securityContextHolderStrategy : SecurityContextHolderStrategy
  securityContext : SecurityContext
  AbstractDelegatingSecurityContextSupport(securityContext : SecurityContext) : None
  setSecurityContextHolderStrategy(securityContextHolderStrategy : SecurityContextHolderStrategy) : void
  wrap(delegate : Runnable) : Runnable
  wrap(delegate : Callable<T>) : Callable<T>
}
class DelegatingSecurityContextCallable    {
  delegate : Callable<V>
  explicitSecurityContextProvided : boolean
  delegateSecurityContext : SecurityContext
  securityContextHolderStrategy : SecurityContextHolderStrategy
  originalSecurityContext : SecurityContext
  DelegatingSecurityContextCallable(delegate : Callable<V>, securityContext : SecurityContext) : None
  DelegatingSecurityContextCallable(delegate : Callable<V>) : None
  DelegatingSecurityContextCallable(delegate : Callable<V>, securityContext : SecurityContext, explicitSecurityContextProvided : boolean) : None
  call() : V
  setSecurityContextHolderStrategy(securityContextHolderStrategy : SecurityContextHolderStrategy) : void
  toString() : String
  create(delegate : Callable<V>, securityContext : SecurityContext) : Callable<V>
  create(delegate : Callable<V>, securityContext : SecurityContext, securityContextHolderStrategy : SecurityContextHolderStrategy) : Callable<V>
}
DelegatingSecurityContextCallable::call --> org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : securityContextHolderStrategy.getContext() 
DelegatingSecurityContextCallable::call --> org.springframework.security.core.context.SecurityContextHolderStrategy::setContext : securityContextHolderStrategy.setContext(delegateSecurityContext) 
DelegatingSecurityContextCallable::call --> org.springframework.security.core.context.SecurityContextHolderStrategy::createEmptyContext : securityContextHolderStrategy.createEmptyContext() 
DelegatingSecurityContextCallable::call --> org.springframework.security.core.context.SecurityContextHolderStrategy::clearContext : securityContextHolderStrategy.clearContext() 
DelegatingSecurityContextCallable::call --> org.springframework.security.core.context.SecurityContextHolderStrategy::setContext : securityContextHolderStrategy.setContext(originalSecurityContext) 
DelegatingSecurityContextCallable::setSecurityContextHolderStrategy --> org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : securityContextHolderStrategy.getContext() 
class DelegatingSecurityContextExecutor  implements java.util.concurrent.Executor  {
  delegate : Executor
  DelegatingSecurityContextExecutor(delegateExecutor : Executor, securityContext : SecurityContext) : None
  DelegatingSecurityContextExecutor(delegate : Executor) : None
  execute(task : Runnable) : void
  getDelegateExecutor() : Executor
  setSecurityContextHolderStrategy(securityContextHolderStrategy : SecurityContextHolderStrategy) : void
}
DelegatingSecurityContextExecutor::execute --> java.util.concurrent.Executor::execute : delegate.execute(wrap(task)) 
class DelegatingSecurityContextExecutorService  implements java.util.concurrent.ExecutorService  {
  DelegatingSecurityContextExecutorService(delegateExecutorService : ExecutorService, securityContext : SecurityContext) : None
  DelegatingSecurityContextExecutorService(delegate : ExecutorService) : None
  shutdown() : void
  shutdownNow() : List<Runnable>
  isShutdown() : boolean
  isTerminated() : boolean
  awaitTermination(timeout : long, unit : TimeUnit) : boolean
  submit(task : Callable<T>) : Future<T>
  submit(task : Runnable, result : T) : Future<T>
  submit(task : Runnable) : Future<?>
  invokeAll(tasks : Collection) : List
  invokeAll(tasks : Collection, timeout : long, unit : TimeUnit) : List
  invokeAny(tasks : Collection) : Object
  invokeAny(tasks : Collection, timeout : long, unit : TimeUnit) : Object
  createTasks(tasks : Collection<Callable<T>>) : Collection<Callable<T>>
  getDelegate() : ExecutorService
}
class DelegatingSecurityContextRunnable    {
  delegate : Runnable
  explicitSecurityContextProvided : boolean
  securityContextHolderStrategy : SecurityContextHolderStrategy
  delegateSecurityContext : SecurityContext
  originalSecurityContext : SecurityContext
  DelegatingSecurityContextRunnable(delegate : Runnable, securityContext : SecurityContext) : None
  DelegatingSecurityContextRunnable(delegate : Runnable) : None
  DelegatingSecurityContextRunnable(delegate : Runnable, securityContext : SecurityContext, explicitSecurityContextProvided : boolean) : None
  run() : void
  setSecurityContextHolderStrategy(securityContextHolderStrategy : SecurityContextHolderStrategy) : void
  toString() : String
  create(delegate : Runnable, securityContext : SecurityContext) : Runnable
  create(delegate : Runnable, securityContext : SecurityContext, securityContextHolderStrategy : SecurityContextHolderStrategy) : Runnable
}
DelegatingSecurityContextRunnable::run --> org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : securityContextHolderStrategy.getContext() 
DelegatingSecurityContextRunnable::run --> org.springframework.security.core.context.SecurityContextHolderStrategy::setContext : securityContextHolderStrategy.setContext(delegateSecurityContext) 
DelegatingSecurityContextRunnable::run --> org.springframework.security.core.context.SecurityContextHolderStrategy::createEmptyContext : securityContextHolderStrategy.createEmptyContext() 
DelegatingSecurityContextRunnable::run --> org.springframework.security.core.context.SecurityContextHolderStrategy::clearContext : securityContextHolderStrategy.clearContext() 
DelegatingSecurityContextRunnable::run --> org.springframework.security.core.context.SecurityContextHolderStrategy::setContext : securityContextHolderStrategy.setContext(originalSecurityContext) 
DelegatingSecurityContextRunnable::setSecurityContextHolderStrategy --> org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : securityContextHolderStrategy.getContext() 
class DelegatingSecurityContextScheduledExecutorService  implements java.util.concurrent.ScheduledExecutorService  {
  DelegatingSecurityContextScheduledExecutorService(delegateScheduledExecutorService : ScheduledExecutorService, securityContext : SecurityContext) : None
  DelegatingSecurityContextScheduledExecutorService(delegate : ScheduledExecutorService) : None
  schedule(command : Runnable, delay : long, unit : TimeUnit) : ScheduledFuture<?>
  schedule(callable : Callable<V>, delay : long, unit : TimeUnit) : ScheduledFuture<V>
  scheduleAtFixedRate(command : Runnable, initialDelay : long, period : long, unit : TimeUnit) : ScheduledFuture<?>
  scheduleWithFixedDelay(command : Runnable, initialDelay : long, delay : long, unit : TimeUnit) : ScheduledFuture<?>
  getDelegate() : ScheduledExecutorService
}
}
package context {
class DelegatingApplicationListener    {
  listeners : List<SmartApplicationListener>
  onApplicationEvent(event : ApplicationEvent) : void
  addListener(smartApplicationListener : SmartApplicationListener) : void
}
}
package converter {
class RsaKeyConverters    {
  DASHES : String
  PKCS8_PEM_HEADER : String
  PKCS8_PEM_FOOTER : String
  X509_PEM_HEADER : String
  X509_PEM_FOOTER : String
  X509_CERT_HEADER : String
  X509_CERT_FOOTER : String
  RsaKeyConverters() : None
  pkcs8() : Converter<InputStream,RSAPrivateKey>
  x509() : Converter<InputStream,RSAPublicKey>
  x509CertificateFactory() : CertificateFactory
  readAllLines(source : InputStream) : List<String>
  rsaFactory() : KeyFactory
  isNotPkcs8Wrapper(line : String) : boolean
}
class X509PemDecoder    {
  keyFactory : KeyFactory
  X509PemDecoder(keyFactory : KeyFactory) : None
  convert(lines : List<String>) : RSAPublicKey
  isNotX509PemWrapper(line : String) : boolean
}
class X509CertificateDecoder    {
  certificateFactory : CertificateFactory
  X509CertificateDecoder(certificateFactory : CertificateFactory) : None
  convert(lines : List<String>) : RSAPublicKey
  isNotX509CertificateWrapper(line : String) : boolean
}
}
package core {
package annotation {
class AbstractSecurityAnnotationScanner    {
  scan(method : Method, targetClass : Class<?>) : A
  scan(parameter : Parameter) : A
  merge(element : AnnotatedElement, targetClass : Class<?>) : MergedAnnotation<A>
}
class AnnotationTemplateExpressionDefaults    {
  ignoreUnknown : boolean
  isIgnoreUnknown() : boolean
  setIgnoreUnknown(ignoreUnknown : boolean) : void
}
class ExpressionTemplateSecurityAnnotationScanner    {
  conversionService : DefaultConversionService
  type : Class<A>
  unique : UniqueSecurityAnnotationScanner<A>
  templateDefaults : AnnotationTemplateExpressionDefaults
  ExpressionTemplateSecurityAnnotationScanner(type : Class<A>, templateDefaults : AnnotationTemplateExpressionDefaults) : None
  merge(element : AnnotatedElement, targetClass : Class<?>) : MergedAnnotation<A>
  resolvePlaceholders(mergedAnnotation : MergedAnnotation<A>) : MergedAnnotation<A>
}
ExpressionTemplateSecurityAnnotationScanner::resolvePlaceholders --> org.springframework.core.convert.support.DefaultConversionService::convert : conversionService.convert(value,String.class) 
class ClassToStringConverter    {
  getConvertibleTypes() : Set<ConvertiblePair>
  convert(source : Object, sourceType : TypeDescriptor, targetType : TypeDescriptor) : Object
}
interface SecurityAnnotationScanner    {
  scan(method : Method, targetClass : Class<?>) : A
  scan(parameter : Parameter) : A
}
class SecurityAnnotationScanners    {
  uniqueScanners : Map<Class<?extendsAnnotation>,SecurityAnnotationScanner<?extendsAnnotation>>
  uniqueTemplateScanners : Map<Class<?extendsAnnotation>,SecurityAnnotationScanner<?extendsAnnotation>>
  uniqueTypesScanners : Map<List<Class<?extendsAnnotation>>,SecurityAnnotationScanner<?extendsAnnotation>>
  SecurityAnnotationScanners() : None
  requireUnique(type : Class<A>) : SecurityAnnotationScanner<A>
  requireUnique(type : Class<A>, templateDefaults : AnnotationTemplateExpressionDefaults) : SecurityAnnotationScanner<A>
  requireUnique(types : List<Class<?extendsAnnotation>>) : SecurityAnnotationScanner<Annotation>
}
class UniqueSecurityAnnotationScanner    {
  types : List<Class<A>>
  uniqueParameterAnnotationCache : Map<Parameter,MergedAnnotation<A>>
  uniqueMethodAnnotationCache : Map<MethodClassKey,MergedAnnotation<A>>
  UniqueSecurityAnnotationScanner(type : Class<A>) : None
  UniqueSecurityAnnotationScanner(types : List<Class<A>>) : None
  merge(element : AnnotatedElement, targetClass : Class<?>) : MergedAnnotation<A>
  requireUnique(element : AnnotatedElement, annotations : List<MergedAnnotation<A>>) : MergedAnnotation<A>
  findParameterAnnotations(current : Parameter) : List<MergedAnnotation<A>>
  findClosestParameterAnnotations(method : Method, clazz : Class<?>, current : Parameter, visited : Set<Class<?>>) : List<MergedAnnotation<A>>
  findDirectParameterAnnotations(method : Method, clazz : Class<?>, current : Parameter) : List<MergedAnnotation<A>>
  findMethodAnnotations(method : Method, targetClass : Class<?>) : List<MergedAnnotation<A>>
  findClosestMethodAnnotations(method : Method, targetClass : Class<?>, classesToSkip : Set<Class<?>>) : List<MergedAnnotation<A>>
  findClosestClassAnnotations(targetClass : Class<?>, classesToSkip : Set<Class<?>>) : List<MergedAnnotation<A>>
  findDirectAnnotations(element : AnnotatedElement) : List<MergedAnnotation<A>>
}
UniqueSecurityAnnotationScanner::merge --> java.lang.reflect.AnnotatedElement::getClass : element.getClass() 
}
package authority {
package mapping {
interface Attributes2GrantedAuthoritiesMapper    {
  getGrantedAuthorities(attributes : Collection<String>) : Collection<?extendsGrantedAuthority>
}
interface GrantedAuthoritiesMapper    {
  mapAuthorities(authorities : Collection<?extendsGrantedAuthority>) : Collection<?extendsGrantedAuthority>
}
class MapBasedAttributes2GrantedAuthoritiesMapper    {
  attributes2grantedAuthoritiesMap : Map<String,Collection<GrantedAuthority>>
  stringSeparator : String
  mappableAttributes : Set<String>
  afterPropertiesSet() : void
  getGrantedAuthorities(attributes : Collection<String>) : List<GrantedAuthority>
  getAttributes2grantedAuthoritiesMap() : Map<String,Collection<GrantedAuthority>>
  setAttributes2grantedAuthoritiesMap(attributes2grantedAuthoritiesMap : Map<?,?>) : void
  preProcessMap(orgMap : Map<?,?>) : Map<String,Collection<GrantedAuthority>>
  getGrantedAuthorityCollection(value : Object) : Collection<GrantedAuthority>
  addGrantedAuthorityCollection(result : Collection<GrantedAuthority>, value : Object) : void
  addGrantedAuthorityCollection(result : Collection<GrantedAuthority>, value : Collection<?>) : void
  addGrantedAuthorityCollection(result : Collection<GrantedAuthority>, value : Object[]) : void
  addGrantedAuthorityCollection(result : Collection<GrantedAuthority>, value : String) : void
  getMappableAttributes() : Set<String>
  getStringSeparator() : String
  setStringSeparator(stringSeparator : String) : void
}
interface MappableAttributesRetriever    {
  getMappableAttributes() : Set<String>
}
class NullAuthoritiesMapper    {
  mapAuthorities(authorities : Collection<?extendsGrantedAuthority>) : Collection<?extendsGrantedAuthority>
}
class SimpleAttributes2GrantedAuthoritiesMapper    {
  attributePrefix : String
  convertAttributeToUpperCase : boolean
  convertAttributeToLowerCase : boolean
  addPrefixIfAlreadyExisting : boolean
  afterPropertiesSet() : void
  getGrantedAuthorities(attributes : Collection<String>) : List<GrantedAuthority>
  getGrantedAuthority(attribute : String) : GrantedAuthority
  isConvertAttributeToLowerCase() : boolean
  setConvertAttributeToLowerCase(b : boolean) : void
  isConvertAttributeToUpperCase() : boolean
  setConvertAttributeToUpperCase(b : boolean) : void
  getAttributePrefix() : String
  setAttributePrefix(string : String) : void
  isAddPrefixIfAlreadyExisting() : boolean
  setAddPrefixIfAlreadyExisting(b : boolean) : void
}
class SimpleAuthorityMapper    {
  defaultAuthority : GrantedAuthority
  prefix : String
  convertToUpperCase : boolean
  convertToLowerCase : boolean
  afterPropertiesSet() : void
  mapAuthorities(authorities : Collection<?extendsGrantedAuthority>) : Set<GrantedAuthority>
  mapAuthority(name : String) : GrantedAuthority
  setPrefix(prefix : String) : void
  setConvertToUpperCase(convertToUpperCase : boolean) : void
  setConvertToLowerCase(convertToLowerCase : boolean) : void
  setDefaultAuthority(authority : String) : void
}
class SimpleMappableAttributesRetriever    {
  mappableAttributes : Set<String>
  getMappableAttributes() : Set<String>
  setMappableAttributes(aMappableRoles : Set<String>) : void
}
}
class AuthorityUtils    {
  NO_AUTHORITIES : List<GrantedAuthority>
  AuthorityUtils() : None
  commaSeparatedStringToAuthorityList(authorityString : String) : List<GrantedAuthority>
  authorityListToSet(userAuthorities : Collection<?extendsGrantedAuthority>) : Set<String>
  createAuthorityList() : List<GrantedAuthority>
  createAuthorityList(authorities : Collection<String>) : List<GrantedAuthority>
}
interface GrantedAuthoritiesContainer    {
  getGrantedAuthorities() : Collection<?extendsGrantedAuthority>
}
class SimpleGrantedAuthority  implements org.springframework.security.core.GrantedAuthority  {
  serialVersionUID : long
  role : String
  SimpleGrantedAuthority(role : String) : None
  getAuthority() : String
  equals(obj : Object) : boolean
  hashCode() : int
  toString() : String
}
}
package context {
interface DeferredSecurityContext    {
  isGenerated() : boolean
}
class GlobalSecurityContextHolderStrategy    {
  contextHolder : SecurityContext
  clearContext() : void
  getContext() : SecurityContext
  setContext(context : SecurityContext) : void
  createEmptyContext() : SecurityContext
}
class InheritableThreadLocalSecurityContextHolderStrategy    {
  contextHolder : ThreadLocal<Supplier<SecurityContext>>
  clearContext() : void
  getContext() : SecurityContext
  getDeferredContext() : Supplier<SecurityContext>
  setContext(context : SecurityContext) : void
  setDeferredContext(deferredContext : Supplier<SecurityContext>) : void
  createEmptyContext() : SecurityContext
}
class ListeningSecurityContextHolderStrategy    {
  listeners : Collection<SecurityContextChangedListener>
  delegate : SecurityContextHolderStrategy
  ListeningSecurityContextHolderStrategy(listeners : Collection<SecurityContextChangedListener>) : None
  ListeningSecurityContextHolderStrategy() : None
  ListeningSecurityContextHolderStrategy(delegate : SecurityContextHolderStrategy, listeners : Collection<SecurityContextChangedListener>) : None
  ListeningSecurityContextHolderStrategy(delegate : SecurityContextHolderStrategy) : None
  clearContext() : void
  getContext() : SecurityContext
  getDeferredContext() : Supplier<SecurityContext>
  setContext(context : SecurityContext) : void
  setDeferredContext(deferredContext : Supplier<SecurityContext>) : void
  createEmptyContext() : SecurityContext
  publish(event : SecurityContextChangedEvent) : void
}
class PublishOnceSupplier    {
  isPublished : AtomicBoolean
  old : Supplier<SecurityContext>
  updated : Supplier<SecurityContext>
  PublishOnceSupplier(old : Supplier<SecurityContext>, updated : Supplier<SecurityContext>) : None
  get() : SecurityContext
}
class ObservationSecurityContextChangedListener    {
  SECURITY_CONTEXT_CREATED : String
  SECURITY_CONTEXT_CHANGED : String
  SECURITY_CONTEXT_CLEARED : String
  registry : ObservationRegistry
  ObservationSecurityContextChangedListener(registry : ObservationRegistry) : None
  securityContextChanged(event : SecurityContextChangedEvent) : void
  getAuthentication(context : SecurityContext) : Authentication
}
ObservationSecurityContextChangedListener::securityContextChanged --> io.micrometer.observation.ObservationRegistry::getCurrentObservation : registry.getCurrentObservation() 
class ReactiveSecurityContextHolder    {
  SECURITY_CONTEXT_KEY : Class<?>
  ReactiveSecurityContextHolder() : None
  getContext() : Mono<SecurityContext>
  hasSecurityContext(context : Context) : boolean
  getSecurityContext(context : Context) : Mono<SecurityContext>
  clearContext() : Function<Context,Context>
  withSecurityContext(securityContext : Mono<?extendsSecurityContext>) : Context
  withAuthentication(authentication : Authentication) : Context
}
class ReactiveSecurityContextHolderThreadLocalAccessor    {
  threadLocal : ThreadLocal<Mono<SecurityContext>>
  key() : Object
  getValue() : Mono<SecurityContext>
  setValue(securityContext : Mono<SecurityContext>) : void
  setValue() : void
}
interface SecurityContext    {
  getAuthentication() : Authentication
  setAuthentication(authentication : Authentication) : void
}
class SecurityContextChangedEvent extends org.springframework.context.ApplicationEvent   {
  NO_CONTEXT : Supplier<SecurityContext>
  oldContext : Supplier<SecurityContext>
  newContext : Supplier<SecurityContext>
  SecurityContextChangedEvent(oldContext : Supplier<SecurityContext>, newContext : Supplier<SecurityContext>) : None
  SecurityContextChangedEvent(oldContext : SecurityContext, newContext : SecurityContext) : None
  getOldContext() : SecurityContext
  getNewContext() : SecurityContext
  isCleared() : boolean
}
interface SecurityContextChangedListener    {
  securityContextChanged(event : SecurityContextChangedEvent) : void
}
class SecurityContextHolder    {
  MODE_THREADLOCAL : String
  MODE_INHERITABLETHREADLOCAL : String
  MODE_GLOBAL : String
  MODE_PRE_INITIALIZED : String
  SYSTEM_PROPERTY : String
  strategyName : String
  strategy : SecurityContextHolderStrategy
  initializeCount : int
  initialize() : void
  initializeStrategy() : void
  clearContext() : void
  getContext() : SecurityContext
  getDeferredContext() : Supplier<SecurityContext>
  getInitializeCount() : int
  setContext(context : SecurityContext) : void
  setDeferredContext(deferredContext : Supplier<SecurityContext>) : void
  setStrategyName(strategyName : String) : void
  setContextHolderStrategy(strategy : SecurityContextHolderStrategy) : void
  getContextHolderStrategy() : SecurityContextHolderStrategy
  createEmptyContext() : SecurityContext
  toString() : String
}
interface SecurityContextHolderStrategy    {
  clearContext() : void
  getContext() : SecurityContext
  getDeferredContext() : Supplier<SecurityContext>
  setContext(context : SecurityContext) : void
  setDeferredContext(deferredContext : Supplier<SecurityContext>) : void
  createEmptyContext() : SecurityContext
}
class SecurityContextHolderThreadLocalAccessor    {
  key() : Object
  getValue() : SecurityContext
  setValue(securityContext : SecurityContext) : void
  setValue() : void
}
class SecurityContextImpl    {
  serialVersionUID : long
  authentication : Authentication
  SecurityContextImpl() : None
  SecurityContextImpl(authentication : Authentication) : None
  equals(obj : Object) : boolean
  getAuthentication() : Authentication
  hashCode() : int
  setAuthentication(authentication : Authentication) : void
  toString() : String
}
class ThreadLocalSecurityContextHolderStrategy    {
  contextHolder : ThreadLocal<Supplier<SecurityContext>>
  clearContext() : void
  getContext() : SecurityContext
  getDeferredContext() : Supplier<SecurityContext>
  setContext(context : SecurityContext) : void
  setDeferredContext(deferredContext : Supplier<SecurityContext>) : void
  createEmptyContext() : SecurityContext
}
class TransientSecurityContext    {
  serialVersionUID : long
  TransientSecurityContext() : None
  TransientSecurityContext(authentication : Authentication) : None
}
}
package parameters {
class AnnotationParameterNameDiscoverer  implements org.springframework.core.ParameterNameDiscoverer  {
  CONSTRUCTOR_METHODPARAM_FACTORY : ParameterNameFactory<Constructor<?>>
  METHOD_METHODPARAM_FACTORY : ParameterNameFactory<Method>
  annotationClassesToUse : Set<String>
  AnnotationParameterNameDiscoverer() : None
  AnnotationParameterNameDiscoverer(annotationClassesToUse : Set<String>) : None
  getParameterNames(method : Method) : String[]
  getParameterNames(constructor : Constructor<?>) : String[]
  lookupParameterNames(parameterNameFactory : ParameterNameFactory<T>, t : T) : String[]
  findParameterName(parameterAnnotations : Annotation[]) : String
}
interface ParameterNameFactory    {
  findParameterAnnotations(t : T) : Annotation[][]
}
class DefaultSecurityParameterNameDiscoverer extends org.springframework.core.PrioritizedParameterNameDiscoverer   {
  DATA_PARAM_CLASSNAME : String
  DATA_PARAM_PRESENT : boolean
  DefaultSecurityParameterNameDiscoverer() : None
  DefaultSecurityParameterNameDiscoverer(parameterNameDiscovers : List<?extendsParameterNameDiscoverer>) : None
}
}
package session {
class AbstractSessionEvent extends org.springframework.context.ApplicationEvent   {
  serialVersionUID : long
  AbstractSessionEvent(source : Object) : None
}
class InMemoryReactiveSessionRegistry    {
  sessionIdsByPrincipal : ConcurrentMap<Object,Set<String>>
  sessionById : Map<String,ReactiveSessionInformation>
  InMemoryReactiveSessionRegistry() : None
  InMemoryReactiveSessionRegistry(sessionIdsByPrincipal : ConcurrentMap<Object,Set<String>>, sessionById : Map<String,ReactiveSessionInformation>) : None
  getAllSessions(principal : Object) : Flux<ReactiveSessionInformation>
  saveSessionInformation(information : ReactiveSessionInformation) : Mono<Void>
  getSessionInformation(sessionId : String) : Mono<ReactiveSessionInformation>
  removeSessionInformation(sessionId : String) : Mono<ReactiveSessionInformation>
  updateLastAccessTime(sessionId : String) : Mono<ReactiveSessionInformation>
}
class ReactiveSessionInformation  implements java.io.Serializable  {
  serialVersionUID : long
  lastAccessTime : Instant
  principal : Object
  sessionId : String
  expired : boolean
  ReactiveSessionInformation(principal : Object, sessionId : String, lastAccessTime : Instant) : None
  withSessionId(sessionId : String) : ReactiveSessionInformation
  invalidate() : Mono<Void>
  refreshLastRequest() : Mono<Void>
  getLastAccessTime() : Instant
  getPrincipal() : Object
  getSessionId() : String
  isExpired() : boolean
  setLastAccessTime(lastAccessTime : Instant) : void
}
interface ReactiveSessionRegistry    {
  getAllSessions(principal : Object) : Flux<ReactiveSessionInformation>
  saveSessionInformation(information : ReactiveSessionInformation) : Mono<Void>
  getSessionInformation(sessionId : String) : Mono<ReactiveSessionInformation>
  removeSessionInformation(sessionId : String) : Mono<ReactiveSessionInformation>
  updateLastAccessTime(sessionId : String) : Mono<ReactiveSessionInformation>
}
class SessionCreationEvent    {
  SessionCreationEvent(source : Object) : None
}
class SessionDestroyedEvent    {
  SessionDestroyedEvent(source : Object) : None
  getSecurityContexts() : List<SecurityContext>
  getId() : String
}
class SessionIdChangedEvent    {
  SessionIdChangedEvent(source : Object) : None
  getOldSessionId() : String
  getNewSessionId() : String
}
class SessionInformation  implements java.io.Serializable  {
  serialVersionUID : long
  lastRequest : Date
  principal : Object
  sessionId : String
  expired : boolean
  SessionInformation(principal : Object, sessionId : String, lastRequest : Date) : None
  expireNow() : void
  getLastRequest() : Date
  getPrincipal() : Object
  getSessionId() : String
  isExpired() : boolean
  refreshLastRequest() : void
}
interface SessionRegistry    {
  getAllPrincipals() : List<Object>
  getAllSessions(principal : Object, includeExpiredSessions : boolean) : List<SessionInformation>
  getSessionInformation(sessionId : String) : SessionInformation
  refreshLastRequest(sessionId : String) : void
  registerNewSession(sessionId : String, principal : Object) : void
  removeSessionInformation(sessionId : String) : void
}
class SessionRegistryImpl    {
  logger : Log
  principals : ConcurrentMap<Object,Set<String>>
  sessionIds : Map<String,SessionInformation>
  SessionRegistryImpl() : None
  SessionRegistryImpl(principals : ConcurrentMap<Object,Set<String>>, sessionIds : Map<String,SessionInformation>) : None
  getAllPrincipals() : List<Object>
  getAllSessions(principal : Object, includeExpiredSessions : boolean) : List<SessionInformation>
  getSessionInformation(sessionId : String) : SessionInformation
  onApplicationEvent(event : AbstractSessionEvent) : void
  refreshLastRequest(sessionId : String) : void
  registerNewSession(sessionId : String, principal : Object) : void
  removeSessionInformation(sessionId : String) : void
}
}
package token {
class DefaultToken    {
  key : String
  keyCreationTime : long
  extendedInformation : String
  DefaultToken(key : String, keyCreationTime : long, extendedInformation : String) : None
  getKey() : String
  getKeyCreationTime() : long
  getExtendedInformation() : String
  equals(obj : Object) : boolean
  hashCode() : int
  toString() : String
}
class KeyBasedPersistenceTokenService    {
  pseudoRandomNumberBytes : int
  serverSecret : String
  serverInteger : Integer
  secureRandom : SecureRandom
  allocateToken(extendedInformation : String) : Token
  computeKey(serverSecret : String, content : String) : String
  verifyToken(key : String) : Token
  generatePseudoRandomNumber() : String
  computeServerSecretApplicableAt(time : long) : String
  setServerSecret(serverSecret : String) : void
  setSecureRandom(secureRandom : SecureRandom) : void
  setPseudoRandomNumberBytes(pseudoRandomNumberBytes : int) : void
  setServerInteger(serverInteger : Integer) : void
  afterPropertiesSet() : void
}
KeyBasedPersistenceTokenService::generatePseudoRandomNumber --> java.security.SecureRandom::nextBytes : secureRandom.nextBytes(randomBytes) 
class SecureRandomFactoryBean    {
  algorithm : String
  seed : Resource
  getObject() : SecureRandom
  getObjectType() : Class<SecureRandom>
  isSingleton() : boolean
  setAlgorithm(algorithm : String) : void
  setSeed(seed : Resource) : void
}
SecureRandomFactoryBean::getObject --> org.springframework.core.io.Resource::getInputStream : seed.getInputStream() 
class Sha512DigestUtils    {
  getSha512Digest() : MessageDigest
  sha(data : byte[]) : byte[]
  sha(data : String) : byte[]
  shaHex(data : byte[]) : String
  shaHex(data : String) : String
}
interface Token    {
  getKey() : String
  getKeyCreationTime() : long
  getExtendedInformation() : String
}
interface TokenService    {
  allocateToken(extendedInformation : String) : Token
  verifyToken(key : String) : Token
}
}
package userdetails {
package cache {
class NullUserCache  implements org.springframework.security.core.userdetails.UserCache  {
  getUserFromCache(username : String) : UserDetails
  putUserInCache(user : UserDetails) : void
  removeUserFromCache(username : String) : void
}
class SpringCacheBasedUserCache  implements org.springframework.security.core.userdetails.UserCache  {
  logger : Log
  cache : Cache
  SpringCacheBasedUserCache(cache : Cache) : None
  getUserFromCache(username : String) : UserDetails
  putUserInCache(user : UserDetails) : void
  removeUserFromCache(user : UserDetails) : void
  removeUserFromCache(username : String) : void
}
SpringCacheBasedUserCache::getUserFromCache --> org.springframework.cache.Cache::get : cache.get(username) 
SpringCacheBasedUserCache::putUserInCache --> org.springframework.cache.Cache::put : cache.put(user.getUsername(),user) 
SpringCacheBasedUserCache::removeUserFromCache --> org.springframework.cache.Cache::evict : cache.evict(username) 
}
package jdbc {
class JdbcDaoImpl extends org.springframework.jdbc.core.support.JdbcDaoSupport   {
  DEFAULT_USER_SCHEMA_DDL_LOCATION : String
  DEF_USERS_BY_USERNAME_QUERY : String
  DEF_AUTHORITIES_BY_USERNAME_QUERY : String
  DEF_GROUP_AUTHORITIES_BY_USERNAME_QUERY : String
  messages : MessageSourceAccessor
  authoritiesByUsernameQuery : String
  groupAuthoritiesByUsernameQuery : String
  usersByUsernameQuery : String
  rolePrefix : String
  usernameBasedPrimaryKey : boolean
  enableAuthorities : boolean
  enableGroups : boolean
  JdbcDaoImpl() : None
  getMessages() : MessageSourceAccessor
  addCustomAuthorities(username : String, authorities : List<GrantedAuthority>) : void
  getUsersByUsernameQuery() : String
  initDao() : void
  loadUserByUsername(username : String) : UserDetails
  loadUsersByUsername(username : String) : List<UserDetails>
  loadUserAuthorities(username : String) : List<GrantedAuthority>
  loadGroupAuthorities(username : String) : List<GrantedAuthority>
  createUserDetails(username : String, userFromUserQuery : UserDetails, combinedAuthorities : List<GrantedAuthority>) : UserDetails
  setAuthoritiesByUsernameQuery(queryString : String) : void
  getAuthoritiesByUsernameQuery() : String
  setGroupAuthoritiesByUsernameQuery(queryString : String) : void
  setRolePrefix(rolePrefix : String) : void
  getRolePrefix() : String
  setUsernameBasedPrimaryKey(usernameBasedPrimaryKey : boolean) : void
  isUsernameBasedPrimaryKey() : boolean
  setUsersByUsernameQuery(usersByUsernameQueryString : String) : void
  getEnableAuthorities() : boolean
  setEnableAuthorities(enableAuthorities : boolean) : void
  getEnableGroups() : boolean
  setEnableGroups(enableGroups : boolean) : void
  setMessageSource(messageSource : MessageSource) : void
}
JdbcDaoImpl::loadUserByUsername --> org.springframework.context.support.MessageSourceAccessor::getMessage : messages.getMessage("JdbcDaoImpl.notFound",newObject[]{username},"Username {0} not found") 
JdbcDaoImpl::loadUserByUsername --> org.springframework.context.support.MessageSourceAccessor::getMessage : messages.getMessage("JdbcDaoImpl.noAuthority",newObject[]{username},"User {0} has no GrantedAuthority") 
}
package memory {
class UserAttribute    {
  authorities : List<GrantedAuthority>
  password : String
  enabled : boolean
  addAuthority(newAuthority : GrantedAuthority) : void
  getAuthorities() : List<GrantedAuthority>
  setAuthorities(authorities : List<GrantedAuthority>) : void
  setAuthoritiesAsString(authoritiesAsStrings : List<String>) : void
  getPassword() : String
  isEnabled() : boolean
  isValid() : boolean
  setEnabled(enabled : boolean) : void
  setPassword(password : String) : void
}
class UserAttributeEditor extends java.beans.PropertyEditorSupport   {
  setAsText(s : String) : void
}
}
interface AuthenticationUserDetailsService    {
  loadUserDetails(token : T) : UserDetails
}
class MapReactiveUserDetailsService    {
  users : Map<String,UserDetails>
  MapReactiveUserDetailsService(users : Map<String,UserDetails>) : None
  MapReactiveUserDetailsService() : None
  MapReactiveUserDetailsService(users : Collection<UserDetails>) : None
  findByUsername(username : String) : Mono<UserDetails>
  updatePassword(user : UserDetails, newPassword : String) : Mono<UserDetails>
  withNewPassword(userDetails : UserDetails, newPassword : String) : UserDetails
  getKey(username : String) : String
}
interface ReactiveUserDetailsPasswordService    {
  updatePassword(user : UserDetails, newPassword : String) : Mono<UserDetails>
}
interface ReactiveUserDetailsService    {
  findByUsername(username : String) : Mono<UserDetails>
}
class User    {
  serialVersionUID : long
  logger : Log
  password : String
  username : String
  authorities : Set<GrantedAuthority>
  accountNonExpired : boolean
  accountNonLocked : boolean
  credentialsNonExpired : boolean
  enabled : boolean
  User(username : String, password : String, authorities : Collection<?extendsGrantedAuthority>) : None
  User(username : String, password : String, enabled : boolean, accountNonExpired : boolean, credentialsNonExpired : boolean, accountNonLocked : boolean, authorities : Collection<?extendsGrantedAuthority>) : None
  getAuthorities() : Collection<GrantedAuthority>
  getPassword() : String
  getUsername() : String
  isEnabled() : boolean
  isAccountNonExpired() : boolean
  isAccountNonLocked() : boolean
  isCredentialsNonExpired() : boolean
  eraseCredentials() : void
  sortAuthorities(authorities : Collection<?extendsGrantedAuthority>) : SortedSet<GrantedAuthority>
  equals(obj : Object) : boolean
  hashCode() : int
  toString() : String
  withUsername(username : String) : UserBuilder
  builder() : UserBuilder
  withDefaultPasswordEncoder() : UserBuilder
  withUserDetails(userDetails : UserDetails) : UserBuilder
}
class AuthorityComparator    {
  serialVersionUID : long
  compare(g1 : GrantedAuthority, g2 : GrantedAuthority) : int
}
class UserBuilder    {
  username : String
  password : String
  authorities : List<GrantedAuthority>
  accountExpired : boolean
  accountLocked : boolean
  credentialsExpired : boolean
  disabled : boolean
  passwordEncoder : Function<String,String>
  UserBuilder() : None
  username(username : String) : UserBuilder
  password(password : String) : UserBuilder
  passwordEncoder(encoder : Function<String,String>) : UserBuilder
  roles() : UserBuilder
  authorities() : UserBuilder
  authorities(authorities : Collection<?extendsGrantedAuthority>) : UserBuilder
  authorities() : UserBuilder
  accountExpired(accountExpired : boolean) : UserBuilder
  accountLocked(accountLocked : boolean) : UserBuilder
  credentialsExpired(credentialsExpired : boolean) : UserBuilder
  disabled(disabled : boolean) : UserBuilder
  build() : UserDetails
}
interface UserCache    {
  getUserFromCache(username : String) : UserDetails
  putUserInCache(user : UserDetails) : void
  removeUserFromCache(username : String) : void
}
interface UserDetails    {
  getAuthorities() : Collection<?extendsGrantedAuthority>
  getPassword() : String
  getUsername() : String
  isAccountNonExpired() : boolean
  isAccountNonLocked() : boolean
  isCredentialsNonExpired() : boolean
  isEnabled() : boolean
}
class UserDetailsByNameServiceWrapper    {
  userDetailsService : UserDetailsService
  UserDetailsByNameServiceWrapper() : None
  UserDetailsByNameServiceWrapper(userDetailsService : UserDetailsService) : None
  afterPropertiesSet() : void
  loadUserDetails(authentication : T) : UserDetails
  setUserDetailsService(aUserDetailsService : UserDetailsService) : void
}
interface UserDetailsChecker    {
  check(toCheck : UserDetails) : void
}
interface UserDetailsPasswordService    {
  updatePassword(user : UserDetails, newPassword : String) : UserDetails
}
interface UserDetailsService    {
  loadUserByUsername(username : String) : UserDetails
}
class UsernameNotFoundException extends org.springframework.security.core.AuthenticationException   {
  serialVersionUID : long
  UsernameNotFoundException(msg : String) : None
  UsernameNotFoundException(msg : String, cause : Throwable) : None
}
}
interface AuthenticatedPrincipal    {
  getName() : String
}
interface Authentication    {
  getAuthorities() : Collection<?extendsGrantedAuthority>
  getCredentials() : Object
  getDetails() : Object
  getPrincipal() : Object
  isAuthenticated() : boolean
  setAuthenticated(isAuthenticated : boolean) : void
}
class AuthenticationException    {
  serialVersionUID : long
  AuthenticationException(msg : String, cause : Throwable) : None
  AuthenticationException(msg : String) : None
}
class ComparableVersion    {
  MAX_INT_ITEM_LENGTH : int
  MAX_LONG_ITEM_LENGTH : int
  value : String
  canonical : String
  items : ListItem
}
interface Item    {
  compareTo(item : Item) : int
  getType() : int
  isNull() : boolean
}
class IntItem    {
  value : int
  ZERO : IntItem
  IntItem() : None
  IntItem(str : String) : None
  getType() : int
  isNull() : boolean
  compareTo(item : Item) : int
  equals(o : Object) : boolean
  hashCode() : int
  toString() : String
}
class LongItem    {
  value : long
  LongItem(str : String) : None
  getType() : int
  isNull() : boolean
  compareTo(item : Item) : int
  equals(o : Object) : boolean
  hashCode() : int
  toString() : String
}
class BigIntegerItem    {
  value : BigInteger
  BigIntegerItem(str : String) : None
  getType() : int
  isNull() : boolean
  compareTo(item : Item) : int
  equals(o : Object) : boolean
  hashCode() : int
  toString() : String
}
class StringItem    {
  QUALIFIERS : List<String>
  ALIASES : Properties
  RELEASE_VERSION_INDEX : String
  value : String
  StringItem(value : String, followedByDigit : boolean) : None
  getType() : int
  isNull() : boolean
  comparableQualifier(qualifier : String) : String
  compareTo(item : Item) : int
  equals(o : Object) : boolean
  hashCode() : int
  toString() : String
}
class ListItem    {
  getType() : int
  isNull() : boolean
  normalize() : void
  compareTo(item : Item) : int
  toString() : String
  ComparableVersion(version : String) : None
  parseVersion(version : String) : void
  parseItem(isDigit : boolean, buf : String) : Item
  stripLeadingZeroes(buf : String) : String
  compareTo(o : ComparableVersion) : int
  toString() : String
  getCanonical() : String
  equals(o : Object) : boolean
  hashCode() : int
  main() : void
}
interface CredentialsContainer    {
  eraseCredentials() : void
}
interface GrantedAuthority    {
  getAuthority() : String
}
class SpringSecurityCoreVersion    {
  DISABLE_CHECKS : String
  logger : Log
  SERIAL_VERSION_UID : long
  MIN_SPRING_VERSION : String
  SpringSecurityCoreVersion() : None
  performVersionChecks() : void
  performVersionChecks(minSpringVersion : String) : void
  getVersion() : String
  disableChecks(springVersion : String, springSecurityVersion : String) : boolean
  getSpringVersion() : String
}
class SpringSecurityMessageSource extends org.springframework.context.support.ResourceBundleMessageSource   {
  SpringSecurityMessageSource() : None
  getAccessor() : MessageSourceAccessor
}
}
package jackson2 {
class AbstractUnmodifiableCollectionDeserializer    {
  deserialize(jp : JsonParser, ctxt : DeserializationContext) : T
  createUnmodifiableCollection(values : Collection<Object>) : T
}
class AnonymousAuthenticationTokenMixin    {
  AnonymousAuthenticationTokenMixin(keyHash : Integer, principal : Object, authorities : Collection<?extendsGrantedAuthority>) : None
}
class BadCredentialsExceptionMixin    {
  BadCredentialsExceptionMixin(message : String) : None
}
class CoreJackson2Module extends com.fasterxml.jackson.databind.module.SimpleModule   {
  CoreJackson2Module() : None
  setupModule(context : SetupContext) : void
}
class RememberMeAuthenticationTokenMixin    {
  RememberMeAuthenticationTokenMixin(keyHash : Integer, principal : Object, authorities : Collection<?extendsGrantedAuthority>) : None
}
class SecurityJackson2Modules    {
  logger : Log
  securityJackson2ModuleClasses : List<String>
  webServletJackson2ModuleClass : String
  oauth2ClientJackson2ModuleClass : String
  javaTimeJackson2ModuleClass : String
  ldapJackson2ModuleClass : String
  saml2Jackson2ModuleClass : String
  casJackson2ModuleClass : String
  webServletPresent : boolean
  oauth2ClientPresent : boolean
  javaTimeJacksonPresent : boolean
  ldapJacksonPresent : boolean
  saml2JacksonPresent : boolean
  casJacksonPresent : boolean
  SecurityJackson2Modules() : None
  enableDefaultTyping(mapper : ObjectMapper) : void
  loadAndGetInstance(className : String, loader : ClassLoader) : Module
  getModules(loader : ClassLoader) : List<Module>
  addToModulesList(loader : ClassLoader, modules : List<Module>, className : String) : void
  createAllowlistedDefaultTyping() : TypeResolverBuilder<?extendsTypeResolverBuilder>
}
class AllowlistTypeResolverBuilder    {
  AllowlistTypeResolverBuilder(defaultTyping : ObjectMapper.DefaultTyping) : None
  idResolver(config : MapperConfig<?>, baseType : JavaType, subtypeValidator : PolymorphicTypeValidator, subtypes : Collection<NamedType>, forSer : boolean, forDeser : boolean) : TypeIdResolver
}
class AllowlistTypeIdResolver    {
  ALLOWLIST_CLASS_NAMES : Set<String>
  delegate : TypeIdResolver
  AllowlistTypeIdResolver(delegate : TypeIdResolver) : None
  init(baseType : JavaType) : void
  idFromValue(value : Object) : String
  idFromValueAndType(value : Object, suggestedType : Class<?>) : String
  idFromBaseType() : String
  typeFromId(context : DatabindContext, id : String) : JavaType
  isInAllowlist(id : String) : boolean
  getDescForKnownTypeIds() : String
  getMechanism() : JsonTypeInfo.Id
}
class SimpleGrantedAuthorityMixin    {
  SimpleGrantedAuthorityMixin(role : String) : None
}
class UnmodifiableListDeserializer    {
  createUnmodifiableCollection(values : Collection<Object>) : List
}
class UnmodifiableListMixin    {
  UnmodifiableListMixin(s : Set<?>) : None
}
class UnmodifiableMapDeserializer    {
  deserialize(jp : JsonParser, ctxt : DeserializationContext) : Map<?,?>
}
UnmodifiableMapDeserializer::deserialize --> com.fasterxml.jackson.core.JsonParser::getCodec : jp.getCodec() 
class UnmodifiableMapMixin    {
  UnmodifiableMapMixin(map : Map<?,?>) : None
}
class UnmodifiableSetDeserializer    {
  createUnmodifiableCollection(values : Collection<Object>) : Set
}
class UnmodifiableSetMixin    {
  UnmodifiableSetMixin(s : Set<?>) : None
}
class UserDeserializer    {
  SIMPLE_GRANTED_AUTHORITY_SET : TypeReference<Set<SimpleGrantedAuthority>>
  deserialize(jp : JsonParser, ctxt : DeserializationContext) : User
  readJsonNode(jsonNode : JsonNode, field : String) : JsonNode
}
UserDeserializer::deserialize --> com.fasterxml.jackson.databind.JsonNode::get : jsonNode.get("authorities") 
UserDeserializer::readJsonNode --> com.fasterxml.jackson.databind.JsonNode::has : jsonNode.has(field) 
UserDeserializer::readJsonNode --> com.fasterxml.jackson.databind.JsonNode::get : jsonNode.get(field) 
class UserMixin    {
}
class UsernamePasswordAuthenticationTokenDeserializer    {
  GRANTED_AUTHORITY_LIST : TypeReference<List<GrantedAuthority>>
  OBJECT : TypeReference<Object>
  deserialize(jp : JsonParser, ctxt : DeserializationContext) : UsernamePasswordAuthenticationToken
  getCredentials(credentialsNode : JsonNode) : Object
  getPrincipal(mapper : ObjectMapper, principalNode : JsonNode) : Object
  readJsonNode(jsonNode : JsonNode, field : String) : JsonNode
}
UsernamePasswordAuthenticationTokenDeserializer::readJsonNode --> com.fasterxml.jackson.databind.JsonNode::has : jsonNode.has(field) 
UsernamePasswordAuthenticationTokenDeserializer::readJsonNode --> com.fasterxml.jackson.databind.JsonNode::get : jsonNode.get(field) 
class UsernamePasswordAuthenticationTokenMixin    {
}
}
package provisioning {
interface GroupManager    {
  findAllGroups() : List<String>
  findUsersInGroup(groupName : String) : List<String>
  createGroup(groupName : String, authorities : List<GrantedAuthority>) : void
  deleteGroup(groupName : String) : void
  renameGroup(oldName : String, newName : String) : void
  addUserToGroup(username : String, group : String) : void
  removeUserFromGroup(username : String, groupName : String) : void
  findGroupAuthorities(groupName : String) : List<GrantedAuthority>
  addGroupAuthority(groupName : String, authority : GrantedAuthority) : void
  removeGroupAuthority(groupName : String, authority : GrantedAuthority) : void
}
class InMemoryUserDetailsManager    {
  logger : Log
  users : Map<String,MutableUserDetails>
  securityContextHolderStrategy : SecurityContextHolderStrategy
  authenticationManager : AuthenticationManager
  InMemoryUserDetailsManager() : None
  InMemoryUserDetailsManager(users : Collection<UserDetails>) : None
  InMemoryUserDetailsManager() : None
  InMemoryUserDetailsManager(users : Properties) : None
  createUserDetails(name : String, attr : UserAttribute) : User
  createUser(user : UserDetails) : void
  deleteUser(username : String) : void
  updateUser(user : UserDetails) : void
  userExists(username : String) : boolean
  changePassword(oldPassword : String, newPassword : String) : void
  updatePassword(user : UserDetails, newPassword : String) : UserDetails
  loadUserByUsername(username : String) : UserDetails
  setSecurityContextHolderStrategy(securityContextHolderStrategy : SecurityContextHolderStrategy) : void
  setAuthenticationManager(authenticationManager : AuthenticationManager) : void
}
InMemoryUserDetailsManager::changePassword --> org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : securityContextHolderStrategy.getContext().getAuthentication() 
InMemoryUserDetailsManager::changePassword --> org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : securityContextHolderStrategy.getContext() 
InMemoryUserDetailsManager::changePassword --> org.springframework.security.authentication.AuthenticationManager::authenticate : authenticationManager.authenticate(UsernamePasswordAuthenticationToken.unauthenticated(username,oldPassword)) 
class JdbcUserDetailsManager extends org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl   {
  DEF_CREATE_USER_SQL : String
  DEF_DELETE_USER_SQL : String
  DEF_UPDATE_USER_SQL : String
  DEF_INSERT_AUTHORITY_SQL : String
  DEF_DELETE_USER_AUTHORITIES_SQL : String
  DEF_USER_EXISTS_SQL : String
  DEF_CHANGE_PASSWORD_SQL : String
  DEF_FIND_GROUPS_SQL : String
  DEF_FIND_USERS_IN_GROUP_SQL : String
  DEF_INSERT_GROUP_SQL : String
  DEF_FIND_GROUP_ID_SQL : String
  DEF_INSERT_GROUP_AUTHORITY_SQL : String
  DEF_DELETE_GROUP_SQL : String
  DEF_DELETE_GROUP_AUTHORITIES_SQL : String
  DEF_DELETE_GROUP_MEMBERS_SQL : String
  DEF_RENAME_GROUP_SQL : String
  DEF_INSERT_GROUP_MEMBER_SQL : String
  DEF_DELETE_GROUP_MEMBER_SQL : String
  DEF_GROUP_AUTHORITIES_QUERY_SQL : String
  DEF_DELETE_GROUP_AUTHORITY_SQL : String
  logger : Log
  securityContextHolderStrategy : SecurityContextHolderStrategy
  createUserSql : String
  deleteUserSql : String
  updateUserSql : String
  createAuthoritySql : String
  deleteUserAuthoritiesSql : String
  userExistsSql : String
  changePasswordSql : String
  findAllGroupsSql : String
  findUsersInGroupSql : String
  insertGroupSql : String
  findGroupIdSql : String
  insertGroupAuthoritySql : String
  deleteGroupSql : String
  deleteGroupAuthoritiesSql : String
  deleteGroupMembersSql : String
  renameGroupSql : String
  insertGroupMemberSql : String
  deleteGroupMemberSql : String
  groupAuthoritiesSql : String
  deleteGroupAuthoritySql : String
  authenticationManager : AuthenticationManager
  userCache : UserCache
  userDetailsMapper : RowMapper<UserDetails>
  grantedAuthorityMapper : RowMapper<GrantedAuthority>
  JdbcUserDetailsManager() : None
  JdbcUserDetailsManager(dataSource : DataSource) : None
  setUserDetailsMapper(mapper : RowMapper<UserDetails>) : void
  setGrantedAuthorityMapper(mapper : RowMapper<GrantedAuthority>) : void
  initDao() : void
  loadUsersByUsername(username : String) : List<UserDetails>
  mapToUser(rs : ResultSet, rowNum : int) : UserDetails
  createUser(user : UserDetails) : void
  updateUser(user : UserDetails) : void
  insertUserAuthorities(user : UserDetails) : void
  deleteUser(username : String) : void
  deleteUserAuthorities(username : String) : void
  changePassword(oldPassword : String, newPassword : String) : void
  createNewAuthentication(currentAuth : Authentication, newPassword : String) : Authentication
  userExists(username : String) : boolean
  findAllGroups() : List<String>
  findUsersInGroup(groupName : String) : List<String>
  createGroup(groupName : String, authorities : List<GrantedAuthority>) : void
  deleteGroup(groupName : String) : void
  renameGroup(oldName : String, newName : String) : void
  addUserToGroup(username : String, groupName : String) : void
  removeUserFromGroup(username : String, groupName : String) : void
  findGroupAuthorities(groupName : String) : List<GrantedAuthority>
  mapToGrantedAuthority(rs : ResultSet, rowNum : int) : GrantedAuthority
  removeGroupAuthority(groupName : String, authority : GrantedAuthority) : void
  addGroupAuthority(groupName : String, authority : GrantedAuthority) : void
  findGroupId(group : String) : int
  setSecurityContextHolderStrategy(securityContextHolderStrategy : SecurityContextHolderStrategy) : void
  setAuthenticationManager(authenticationManager : AuthenticationManager) : void
  setCreateUserSql(createUserSql : String) : void
  setDeleteUserSql(deleteUserSql : String) : void
  setUpdateUserSql(updateUserSql : String) : void
  setCreateAuthoritySql(createAuthoritySql : String) : void
  setDeleteUserAuthoritiesSql(deleteUserAuthoritiesSql : String) : void
  setUserExistsSql(userExistsSql : String) : void
  setChangePasswordSql(changePasswordSql : String) : void
  setFindAllGroupsSql(findAllGroupsSql : String) : void
  setFindUsersInGroupSql(findUsersInGroupSql : String) : void
  setInsertGroupSql(insertGroupSql : String) : void
  setFindGroupIdSql(findGroupIdSql : String) : void
  setInsertGroupAuthoritySql(insertGroupAuthoritySql : String) : void
  setDeleteGroupSql(deleteGroupSql : String) : void
  setDeleteGroupAuthoritiesSql(deleteGroupAuthoritiesSql : String) : void
  setDeleteGroupMembersSql(deleteGroupMembersSql : String) : void
  setRenameGroupSql(renameGroupSql : String) : void
  setInsertGroupMemberSql(insertGroupMemberSql : String) : void
  setDeleteGroupMemberSql(deleteGroupMemberSql : String) : void
  setGroupAuthoritiesSql(groupAuthoritiesSql : String) : void
  setDeleteGroupAuthoritySql(deleteGroupAuthoritySql : String) : void
  setUserCache(userCache : UserCache) : void
  validateUserDetails(user : UserDetails) : void
  validateAuthorities(authorities : Collection<?extendsGrantedAuthority>) : void
}
JdbcUserDetailsManager::updateUser --> org.springframework.security.core.userdetails.UserCache::removeUserFromCache : userCache.removeUserFromCache(user.getUsername()) 
JdbcUserDetailsManager::deleteUser --> org.springframework.security.core.userdetails.UserCache::removeUserFromCache : userCache.removeUserFromCache(username) 
JdbcUserDetailsManager::changePassword --> org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : securityContextHolderStrategy.getContext().getAuthentication() 
JdbcUserDetailsManager::changePassword --> org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : securityContextHolderStrategy.getContext() 
JdbcUserDetailsManager::changePassword --> org.springframework.security.authentication.AuthenticationManager::authenticate : authenticationManager.authenticate(UsernamePasswordAuthenticationToken.unauthenticated(username,oldPassword)) 
JdbcUserDetailsManager::changePassword --> org.springframework.security.core.context.SecurityContextHolderStrategy::createEmptyContext : securityContextHolderStrategy.createEmptyContext() 
JdbcUserDetailsManager::changePassword --> org.springframework.security.core.context.SecurityContextHolderStrategy::setContext : securityContextHolderStrategy.setContext(context) 
JdbcUserDetailsManager::changePassword --> org.springframework.security.core.userdetails.UserCache::removeUserFromCache : userCache.removeUserFromCache(username) 
JdbcUserDetailsManager::addUserToGroup --> org.springframework.security.core.userdetails.UserCache::removeUserFromCache : userCache.removeUserFromCache(username) 
JdbcUserDetailsManager::removeUserFromGroup --> org.springframework.security.core.userdetails.UserCache::removeUserFromCache : userCache.removeUserFromCache(username) 
class MutableUser    {
  serialVersionUID : long
  password : String
  delegate : UserDetails
  MutableUser(user : UserDetails) : None
  getPassword() : String
  setPassword(password : String) : void
  getAuthorities() : Collection<?extendsGrantedAuthority>
  getUsername() : String
  isAccountNonExpired() : boolean
  isAccountNonLocked() : boolean
  isCredentialsNonExpired() : boolean
  isEnabled() : boolean
}
MutableUser::getAuthorities --> org.springframework.security.core.userdetails.UserDetails::getAuthorities : delegate.getAuthorities() 
MutableUser::getUsername --> org.springframework.security.core.userdetails.UserDetails::getUsername : delegate.getUsername() 
MutableUser::isAccountNonExpired --> org.springframework.security.core.userdetails.UserDetails::isAccountNonExpired : delegate.isAccountNonExpired() 
MutableUser::isAccountNonLocked --> org.springframework.security.core.userdetails.UserDetails::isAccountNonLocked : delegate.isAccountNonLocked() 
MutableUser::isCredentialsNonExpired --> org.springframework.security.core.userdetails.UserDetails::isCredentialsNonExpired : delegate.isCredentialsNonExpired() 
MutableUser::isEnabled --> org.springframework.security.core.userdetails.UserDetails::isEnabled : delegate.isEnabled() 
interface MutableUserDetails    {
  setPassword(password : String) : void
}
interface UserDetailsManager    {
  createUser(user : UserDetails) : void
  updateUser(user : UserDetails) : void
  deleteUser(username : String) : void
  changePassword(oldPassword : String, newPassword : String) : void
  userExists(username : String) : boolean
}
}
package scheduling {
class DelegatingSecurityContextSchedulingTaskExecutor extends org.springframework.security.task.DelegatingSecurityContextAsyncTaskExecutor implements org.springframework.scheduling.SchedulingTaskExecutor  {
  DelegatingSecurityContextSchedulingTaskExecutor(delegateSchedulingTaskExecutor : SchedulingTaskExecutor, securityContext : SecurityContext) : None
  DelegatingSecurityContextSchedulingTaskExecutor(delegateAsyncTaskExecutor : SchedulingTaskExecutor) : None
  prefersShortLivedTasks() : boolean
  getDelegate() : SchedulingTaskExecutor
}
class DelegatingSecurityContextTaskScheduler  implements org.springframework.scheduling.TaskScheduler  {
  delegate : TaskScheduler
  securityContext : SecurityContext
  DelegatingSecurityContextTaskScheduler(delegateTaskScheduler : TaskScheduler, securityContext : SecurityContext) : None
  DelegatingSecurityContextTaskScheduler(delegate : TaskScheduler) : None
  schedule(task : Runnable, trigger : Trigger) : ScheduledFuture<?>
  schedule(task : Runnable, startTime : Date) : ScheduledFuture<?>
  scheduleAtFixedRate(task : Runnable, startTime : Date, period : long) : ScheduledFuture<?>
  scheduleAtFixedRate(task : Runnable, period : long) : ScheduledFuture<?>
  scheduleWithFixedDelay(task : Runnable, startTime : Date, delay : long) : ScheduledFuture<?>
  scheduleWithFixedDelay(task : Runnable, delay : long) : ScheduledFuture<?>
  schedule(task : Runnable, startTime : Instant) : ScheduledFuture<?>
  scheduleAtFixedRate(task : Runnable, startTime : Instant, period : Duration) : ScheduledFuture<?>
  scheduleAtFixedRate(task : Runnable, period : Duration) : ScheduledFuture<?>
  scheduleWithFixedDelay(task : Runnable, startTime : Instant, delay : Duration) : ScheduledFuture<?>
  scheduleWithFixedDelay(task : Runnable, delay : Duration) : ScheduledFuture<?>
  getClock() : Clock
  wrap(delegate : Runnable) : Runnable
}
DelegatingSecurityContextTaskScheduler::schedule --> org.springframework.scheduling.TaskScheduler::schedule : delegate.schedule(wrap(task),trigger) 
DelegatingSecurityContextTaskScheduler::schedule --> org.springframework.scheduling.TaskScheduler::schedule : delegate.schedule(wrap(task),startTime) 
DelegatingSecurityContextTaskScheduler::scheduleAtFixedRate --> org.springframework.scheduling.TaskScheduler::scheduleAtFixedRate : delegate.scheduleAtFixedRate(wrap(task),startTime,period) 
DelegatingSecurityContextTaskScheduler::scheduleAtFixedRate --> org.springframework.scheduling.TaskScheduler::scheduleAtFixedRate : delegate.scheduleAtFixedRate(wrap(task),period) 
DelegatingSecurityContextTaskScheduler::scheduleWithFixedDelay --> org.springframework.scheduling.TaskScheduler::scheduleWithFixedDelay : delegate.scheduleWithFixedDelay(wrap(task),startTime,delay) 
DelegatingSecurityContextTaskScheduler::scheduleWithFixedDelay --> org.springframework.scheduling.TaskScheduler::scheduleWithFixedDelay : delegate.scheduleWithFixedDelay(wrap(task),delay) 
DelegatingSecurityContextTaskScheduler::schedule --> org.springframework.scheduling.TaskScheduler::schedule : delegate.schedule(wrap(task),startTime) 
DelegatingSecurityContextTaskScheduler::scheduleAtFixedRate --> org.springframework.scheduling.TaskScheduler::scheduleAtFixedRate : delegate.scheduleAtFixedRate(wrap(task),startTime,period) 
DelegatingSecurityContextTaskScheduler::scheduleAtFixedRate --> org.springframework.scheduling.TaskScheduler::scheduleAtFixedRate : delegate.scheduleAtFixedRate(wrap(task),period) 
DelegatingSecurityContextTaskScheduler::scheduleWithFixedDelay --> org.springframework.scheduling.TaskScheduler::scheduleWithFixedDelay : delegate.scheduleWithFixedDelay(wrap(task),startTime,delay) 
DelegatingSecurityContextTaskScheduler::scheduleWithFixedDelay --> org.springframework.scheduling.TaskScheduler::scheduleWithFixedDelay : delegate.scheduleWithFixedDelay(wrap(task),delay) 
DelegatingSecurityContextTaskScheduler::getClock --> org.springframework.scheduling.TaskScheduler::getClock : delegate.getClock() 
}
package task {
class DelegatingSecurityContextAsyncTaskExecutor  implements org.springframework.core.task.AsyncTaskExecutor  {
  DelegatingSecurityContextAsyncTaskExecutor(delegateAsyncTaskExecutor : AsyncTaskExecutor, securityContext : SecurityContext) : None
  DelegatingSecurityContextAsyncTaskExecutor(delegateAsyncTaskExecutor : AsyncTaskExecutor) : None
  execute(task : Runnable, startTimeout : long) : void
  submit(task : Runnable) : Future<?>
  submit(task : Callable<T>) : Future<T>
  getDelegate() : AsyncTaskExecutor
}
class DelegatingSecurityContextTaskExecutor extends org.springframework.security.concurrent.DelegatingSecurityContextExecutor implements org.springframework.core.task.TaskExecutor  {
  DelegatingSecurityContextTaskExecutor(delegateTaskExecutor : TaskExecutor, securityContext : SecurityContext) : None
  DelegatingSecurityContextTaskExecutor(delegate : TaskExecutor) : None
}
}
package util {
class FieldUtils    {
  FieldUtils() : None
  getField(clazz : Class<?>, fieldName : String) : Field
  getFieldValue(bean : Object, fieldName : String) : Object
  getProtectedFieldValue(protectedField : String, object : Object) : Object
  setProtectedFieldValue(protectedField : String, object : Object, newValue : Object) : void
}
class InMemoryResource extends org.springframework.core.io.AbstractResource   {
  source : byte[]
  description : String
  InMemoryResource(source : String) : None
  InMemoryResource(source : byte[]) : None
  InMemoryResource(source : byte[], description : String) : None
  getDescription() : String
  getInputStream() : InputStream
  equals(res : Object) : boolean
  hashCode() : int
}
class MethodInvocationUtils    {
  MethodInvocationUtils() : None
  create(object : Object, methodName : String) : MethodInvocation
  createFromClass(clazz : Class<?>, methodName : String) : MethodInvocation
  createFromClass(targetObject : Object, clazz : Class<?>, methodName : String, classArgs : Class<?>[], args : Object[]) : MethodInvocation
}
class SimpleMethodInvocation  implements org.aopalliance.intercept.MethodInvocation  {
  method : Method
  arguments : Object[]
  targetObject : Object
  SimpleMethodInvocation(targetObject : Object, method : Method) : None
  SimpleMethodInvocation() : None
  getArguments() : Object[]
  getMethod() : Method
  getStaticPart() : AccessibleObject
  getThis() : Object
  proceed() : Object
  toString() : String
}
}
}
}
}
@enduml
