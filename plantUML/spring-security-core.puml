@startuml
package org {
package springframework {
package security {
package access {
package annotation {
interface AnnotationMetadataExtractor    {
  extractAttributes(securityAnnotation : org.springframework.security.access.annotation.A) : java.util.Collection
}
class Jsr250MethodSecurityMetadataSource extends org.springframework.security.access.method.AbstractFallbackMethodSecurityMetadataSource   {
  defaultRolePrefix : java.lang.String
  setDefaultRolePrefix(defaultRolePrefix : java.lang.String) : void
  findAttributes(clazz : java.lang.Class) : java.util.Collection
  findAttributes(method : java.lang.reflect.Method, targetClass : java.lang.Class) : java.util.Collection
  getAllConfigAttributes() : java.util.Collection
  processAnnotations(annotations : org.springframework.security.access.annotation.Annotation[]) : java.util.List
  getRoleWithDefaultPrefix(role : java.lang.String) : java.lang.String
}
org.springframework.security.access.annotation.Jsr250MethodSecurityMetadataSource::findAttributes -- java.lang.Class::getAnnotations : clazz.getAnnotations() 
org.springframework.security.access.annotation.Jsr250MethodSecurityMetadataSource::findAttributes -- org.springframework.core.annotation.AnnotationUtils::getAnnotations : AnnotationUtils.getAnnotations(method) 
org.springframework.security.access.annotation.Jsr250MethodSecurityMetadataSource::getRoleWithDefaultPrefix -- java.lang.String::length : this.defaultRolePrefix.length() 
org.springframework.security.access.annotation.Jsr250MethodSecurityMetadataSource::getRoleWithDefaultPrefix -- java.lang.String::startsWith : role.startsWith(this.defaultRolePrefix) 
class Jsr250SecurityConfig extends org.springframework.security.access.SecurityConfig   {
  PERMIT_ALL_ATTRIBUTE : org.springframework.security.access.annotation.Jsr250SecurityConfig
  DENY_ALL_ATTRIBUTE : org.springframework.security.access.annotation.Jsr250SecurityConfig
  Jsr250SecurityConfig(role : java.lang.String) : None
}
class Jsr250Voter  implements org.springframework.security.access.AccessDecisionVoter  {
  supports(configAttribute : org.springframework.security.access.ConfigAttribute) : boolean
  supports(clazz : java.lang.Class) : boolean
  vote(authentication : org.springframework.security.core.Authentication, object : java.lang.Object, definition : java.util.Collection) : int
}
org.springframework.security.access.annotation.Jsr250Voter::vote -- org.springframework.security.core.Authentication::getAuthorities : authentication.getAuthorities() 
class SecuredAnnotationSecurityMetadataSource extends org.springframework.security.access.method.AbstractFallbackMethodSecurityMetadataSource   {
  annotationExtractor : org.springframework.security.access.annotation.AnnotationMetadataExtractor
  annotationType : java.lang.Class
  SecuredAnnotationSecurityMetadataSource() : None
  SecuredAnnotationSecurityMetadataSource(annotationMetadataExtractor : org.springframework.security.access.annotation.AnnotationMetadataExtractor) : None
  findAttributes(clazz : java.lang.Class) : java.util.Collection
  findAttributes(method : java.lang.reflect.Method, targetClass : java.lang.Class) : java.util.Collection
  getAllConfigAttributes() : java.util.Collection
  processAnnotation(annotation : java.lang.annotation.Annotation) : java.util.Collection
}
org.springframework.security.access.annotation.SecuredAnnotationSecurityMetadataSource::SecuredAnnotationSecurityMetadataSource -- org.springframework.util.Assert::notNull : Assert.notNull(annotationMetadataExtractor,"annotationMetadataExtractor cannot be null") 
org.springframework.security.access.annotation.SecuredAnnotationSecurityMetadataSource::SecuredAnnotationSecurityMetadataSource -- org.springframework.core.GenericTypeResolver::resolveTypeArgument : GenericTypeResolver.resolveTypeArgument(this.annotationExtractor.getClass(),AnnotationMetadataExtractor.class) 
org.springframework.security.access.annotation.SecuredAnnotationSecurityMetadataSource::SecuredAnnotationSecurityMetadataSource -- org.springframework.security.access.annotation.AnnotationMetadataExtractor::getClass : this.annotationExtractor.getClass() 
org.springframework.security.access.annotation.SecuredAnnotationSecurityMetadataSource::SecuredAnnotationSecurityMetadataSource -- org.springframework.util.Assert::notNull : Assert.notNull(this.annotationType,()->this.annotationExtractor.getClass().getName()+" must supply a generic parameter for AnnotationMetadataExtractor") 
org.springframework.security.access.annotation.SecuredAnnotationSecurityMetadataSource::SecuredAnnotationSecurityMetadataSource -- org.springframework.security.access.annotation.AnnotationMetadataExtractor::getClass : this.annotationExtractor.getClass().getName() 
org.springframework.security.access.annotation.SecuredAnnotationSecurityMetadataSource::SecuredAnnotationSecurityMetadataSource -- org.springframework.security.access.annotation.AnnotationMetadataExtractor::getClass : this.annotationExtractor.getClass() 
org.springframework.security.access.annotation.SecuredAnnotationSecurityMetadataSource::findAttributes -- org.springframework.core.annotation.AnnotationUtils::findAnnotation : AnnotationUtils.findAnnotation(clazz,this.annotationType) 
org.springframework.security.access.annotation.SecuredAnnotationSecurityMetadataSource::findAttributes -- org.springframework.core.annotation.AnnotationUtils::findAnnotation : AnnotationUtils.findAnnotation(method,this.annotationType) 
org.springframework.security.access.annotation.SecuredAnnotationSecurityMetadataSource::processAnnotation -- org.springframework.security.access.annotation.AnnotationMetadataExtractor::extractAttributes : this.annotationExtractor.extractAttributes(annotation) 
class SecuredAnnotationMetadataExtractor  implements org.springframework.security.access.annotation.AnnotationMetadataExtractor  {
  extractAttributes(secured : org.springframework.security.access.annotation.Secured) : org.springframework.security.access.annotation.Collection
}
org.springframework.security.access.annotation.SecuredAnnotationMetadataExtractor::extractAttributes -- org.springframework.security.access.annotation.Secured::value : secured.value() 
}
package event {
class AbstractAuthorizationEvent extends org.springframework.context.ApplicationEvent   {
  AbstractAuthorizationEvent(secureObject : java.lang.Object) : None
}
class AuthenticationCredentialsNotFoundEvent extends org.springframework.security.access.event.AbstractAuthorizationEvent   {
  credentialsNotFoundException : org.springframework.security.authentication.AuthenticationCredentialsNotFoundException
  configAttribs : java.util.Collection
  AuthenticationCredentialsNotFoundEvent(secureObject : java.lang.Object, attributes : java.util.Collection, credentialsNotFoundException : org.springframework.security.authentication.AuthenticationCredentialsNotFoundException) : None
  getConfigAttributes() : java.util.Collection
  getCredentialsNotFoundException() : org.springframework.security.authentication.AuthenticationCredentialsNotFoundException
}
org.springframework.security.access.event.AuthenticationCredentialsNotFoundEvent::AuthenticationCredentialsNotFoundEvent -- org.springframework.util.Assert::isTrue : Assert.isTrue(attributes!=null&&credentialsNotFoundException!=null,"All parameters are required and cannot be null") 
class AuthorizationFailureEvent extends org.springframework.security.access.event.AbstractAuthorizationEvent   {
  accessDeniedException : org.springframework.security.access.AccessDeniedException
  authentication : org.springframework.security.core.Authentication
  configAttributes : java.util.Collection
  AuthorizationFailureEvent(secureObject : java.lang.Object, attributes : java.util.Collection, authentication : org.springframework.security.core.Authentication, accessDeniedException : org.springframework.security.access.AccessDeniedException) : None
  getAccessDeniedException() : org.springframework.security.access.AccessDeniedException
  getAuthentication() : org.springframework.security.core.Authentication
  getConfigAttributes() : java.util.Collection
}
org.springframework.security.access.event.AuthorizationFailureEvent::AuthorizationFailureEvent -- org.springframework.util.Assert::isTrue : Assert.isTrue(attributes!=null&&authentication!=null&&accessDeniedException!=null,"All parameters are required and cannot be null") 
class AuthorizedEvent extends org.springframework.security.access.event.AbstractAuthorizationEvent   {
  authentication : org.springframework.security.core.Authentication
  configAttributes : java.util.Collection
  AuthorizedEvent(secureObject : java.lang.Object, attributes : java.util.Collection, authentication : org.springframework.security.core.Authentication) : None
  getAuthentication() : org.springframework.security.core.Authentication
  getConfigAttributes() : java.util.Collection
}
org.springframework.security.access.event.AuthorizedEvent::AuthorizedEvent -- org.springframework.util.Assert::isTrue : Assert.isTrue(attributes!=null&&authentication!=null,"All parameters are required and cannot be null") 
class LoggerListener  implements org.springframework.context.ApplicationListener  {
  logger : org.apache.commons.logging.Log
  onApplicationEvent(event : org.springframework.security.access.event.AbstractAuthorizationEvent) : void
  onAuthenticationCredentialsNotFoundEvent(authEvent : org.springframework.security.access.event.AuthenticationCredentialsNotFoundEvent) : void
  onPublicInvocationEvent(event : org.springframework.security.access.event.PublicInvocationEvent) : void
  onAuthorizedEvent(authEvent : org.springframework.security.access.event.AuthorizedEvent) : void
  onAuthorizationFailureEvent(authEvent : org.springframework.security.access.event.AuthorizationFailureEvent) : void
}
org.springframework.security.access.event.LoggerListener::onAuthenticationCredentialsNotFoundEvent -- org.apache.commons.logging.Log::warn : logger.warn(LogMessage.format("Security interception failed due to: %s; secure object: %s; configuration attributes: %s",authEvent.getCredentialsNotFoundException(),authEvent.getSource(),authEvent.getConfigAttributes())) 
org.springframework.security.access.event.LoggerListener::onAuthenticationCredentialsNotFoundEvent -- org.springframework.core.log.LogMessage::format : LogMessage.format("Security interception failed due to: %s; secure object: %s; configuration attributes: %s",authEvent.getCredentialsNotFoundException(),authEvent.getSource(),authEvent.getConfigAttributes()) 
org.springframework.security.access.event.LoggerListener::onAuthenticationCredentialsNotFoundEvent -- org.springframework.security.access.event.AuthenticationCredentialsNotFoundEvent::getCredentialsNotFoundException : authEvent.getCredentialsNotFoundException() 
org.springframework.security.access.event.LoggerListener::onAuthenticationCredentialsNotFoundEvent -- org.springframework.security.access.event.AuthenticationCredentialsNotFoundEvent::getSource : authEvent.getSource() 
org.springframework.security.access.event.LoggerListener::onAuthenticationCredentialsNotFoundEvent -- org.springframework.security.access.event.AuthenticationCredentialsNotFoundEvent::getConfigAttributes : authEvent.getConfigAttributes() 
org.springframework.security.access.event.LoggerListener::onPublicInvocationEvent -- org.apache.commons.logging.Log::info : logger.info(LogMessage.format("Security interception not required for public secure object: %s",event.getSource())) 
org.springframework.security.access.event.LoggerListener::onPublicInvocationEvent -- org.springframework.core.log.LogMessage::format : LogMessage.format("Security interception not required for public secure object: %s",event.getSource()) 
org.springframework.security.access.event.LoggerListener::onPublicInvocationEvent -- org.springframework.security.access.event.PublicInvocationEvent::getSource : event.getSource() 
org.springframework.security.access.event.LoggerListener::onAuthorizedEvent -- org.apache.commons.logging.Log::info : logger.info(LogMessage.format("Security authorized for authenticated principal: %s; secure object: %s; configuration attributes: %s",authEvent.getAuthentication(),authEvent.getSource(),authEvent.getConfigAttributes())) 
org.springframework.security.access.event.LoggerListener::onAuthorizedEvent -- org.springframework.core.log.LogMessage::format : LogMessage.format("Security authorized for authenticated principal: %s; secure object: %s; configuration attributes: %s",authEvent.getAuthentication(),authEvent.getSource(),authEvent.getConfigAttributes()) 
org.springframework.security.access.event.LoggerListener::onAuthorizedEvent -- org.springframework.security.access.event.AuthorizedEvent::getAuthentication : authEvent.getAuthentication() 
org.springframework.security.access.event.LoggerListener::onAuthorizedEvent -- org.springframework.security.access.event.AuthorizedEvent::getSource : authEvent.getSource() 
org.springframework.security.access.event.LoggerListener::onAuthorizedEvent -- org.springframework.security.access.event.AuthorizedEvent::getConfigAttributes : authEvent.getConfigAttributes() 
org.springframework.security.access.event.LoggerListener::onAuthorizationFailureEvent -- org.apache.commons.logging.Log::warn : logger.warn(LogMessage.format("Security authorization failed due to: %s; authenticated principal: %s; secure object: %s; configuration attributes: %s",authEvent.getAccessDeniedException(),authEvent.getAuthentication(),authEvent.getSource(),authEvent.getConfigAttributes())) 
org.springframework.security.access.event.LoggerListener::onAuthorizationFailureEvent -- org.springframework.core.log.LogMessage::format : LogMessage.format("Security authorization failed due to: %s; authenticated principal: %s; secure object: %s; configuration attributes: %s",authEvent.getAccessDeniedException(),authEvent.getAuthentication(),authEvent.getSource(),authEvent.getConfigAttributes()) 
org.springframework.security.access.event.LoggerListener::onAuthorizationFailureEvent -- org.springframework.security.access.event.AuthorizationFailureEvent::getAccessDeniedException : authEvent.getAccessDeniedException() 
org.springframework.security.access.event.LoggerListener::onAuthorizationFailureEvent -- org.springframework.security.access.event.AuthorizationFailureEvent::getAuthentication : authEvent.getAuthentication() 
org.springframework.security.access.event.LoggerListener::onAuthorizationFailureEvent -- org.springframework.security.access.event.AuthorizationFailureEvent::getSource : authEvent.getSource() 
org.springframework.security.access.event.LoggerListener::onAuthorizationFailureEvent -- org.springframework.security.access.event.AuthorizationFailureEvent::getConfigAttributes : authEvent.getConfigAttributes() 
class PublicInvocationEvent extends org.springframework.security.access.event.AbstractAuthorizationEvent   {
  PublicInvocationEvent(secureObject : java.lang.Object) : None
}
}
package expression {
package method {
class AbstractExpressionBasedMethodConfigAttribute  implements org.springframework.security.access.ConfigAttribute  {
  filterExpression : org.springframework.expression.Expression
  authorizeExpression : org.springframework.expression.Expression
  AbstractExpressionBasedMethodConfigAttribute(filterExpression : java.lang.String, authorizeExpression : java.lang.String) : None
  AbstractExpressionBasedMethodConfigAttribute(filterExpression : org.springframework.expression.Expression, authorizeExpression : org.springframework.expression.Expression) : None
  getFilterExpression() : org.springframework.expression.Expression
  getAuthorizeExpression() : org.springframework.expression.Expression
  getAttribute() : java.lang.String
}
org.springframework.security.access.expression.method.AbstractExpressionBasedMethodConfigAttribute::AbstractExpressionBasedMethodConfigAttribute -- org.springframework.util.Assert::isTrue : Assert.isTrue(filterExpression!=null||authorizeExpression!=null,"Filter and authorization Expressions cannot both be null") 
org.springframework.security.access.expression.method.AbstractExpressionBasedMethodConfigAttribute::AbstractExpressionBasedMethodConfigAttribute -- org.springframework.util.Assert::isTrue : Assert.isTrue(filterExpression!=null||authorizeExpression!=null,"Filter and authorization Expressions cannot both be null") 
class DefaultMethodSecurityExpressionHandler extends org.springframework.security.access.expression.AbstractSecurityExpressionHandler implements org.springframework.security.access.expression.method.MethodSecurityExpressionHandler  {
  logger : org.apache.commons.logging.Log
  trustResolver : org.springframework.security.authentication.AuthenticationTrustResolver
  parameterNameDiscoverer : org.springframework.core.ParameterNameDiscoverer
  permissionCacheOptimizer : org.springframework.security.access.PermissionCacheOptimizer
  defaultRolePrefix : java.lang.String
  DefaultMethodSecurityExpressionHandler() : None
  createEvaluationContextInternal(auth : org.springframework.security.core.Authentication, mi : org.aopalliance.intercept.MethodInvocation) : org.springframework.expression.spel.support.StandardEvaluationContext
  createEvaluationContext(authentication : java.util.function.Supplier, mi : org.aopalliance.intercept.MethodInvocation) : org.springframework.expression.EvaluationContext
  createSecurityExpressionRoot(authentication : org.springframework.security.core.Authentication, invocation : org.aopalliance.intercept.MethodInvocation) : org.springframework.security.access.expression.method.MethodSecurityExpressionOperations
  createSecurityExpressionRoot(authentication : java.util.function.Supplier, invocation : org.aopalliance.intercept.MethodInvocation) : org.springframework.security.access.expression.method.MethodSecurityExpressionOperations
  filter(filterTarget : java.lang.Object, filterExpression : org.springframework.expression.Expression, ctx : org.springframework.expression.EvaluationContext) : java.lang.Object
  filterCollection(filterTarget : java.util.Collection, filterExpression : org.springframework.expression.Expression, ctx : org.springframework.expression.EvaluationContext, rootObject : org.springframework.security.access.expression.method.MethodSecurityExpressionOperations) : java.lang.Object
  filterArray(filterTarget : org.springframework.security.access.expression.method.Object[], filterExpression : org.springframework.expression.Expression, ctx : org.springframework.expression.EvaluationContext, rootObject : org.springframework.security.access.expression.method.MethodSecurityExpressionOperations) : java.lang.Object
  filterMap(filterTarget : java.util.Map, filterExpression : org.springframework.expression.Expression, ctx : org.springframework.expression.EvaluationContext, rootObject : org.springframework.security.access.expression.method.MethodSecurityExpressionOperations) : java.lang.Object
  filterStream(filterTarget : java.util.stream.Stream, filterExpression : org.springframework.expression.Expression, ctx : org.springframework.expression.EvaluationContext, rootObject : org.springframework.security.access.expression.method.MethodSecurityExpressionOperations) : java.lang.Object
  setTrustResolver(trustResolver : org.springframework.security.authentication.AuthenticationTrustResolver) : void
  getTrustResolver() : org.springframework.security.authentication.AuthenticationTrustResolver
  setParameterNameDiscoverer(parameterNameDiscoverer : org.springframework.core.ParameterNameDiscoverer) : void
  getParameterNameDiscoverer() : org.springframework.core.ParameterNameDiscoverer
  setPermissionCacheOptimizer(permissionCacheOptimizer : org.springframework.security.access.PermissionCacheOptimizer) : void
  setReturnObject(returnObject : java.lang.Object, ctx : org.springframework.expression.EvaluationContext) : void
  setDefaultRolePrefix(defaultRolePrefix : java.lang.String) : void
  getDefaultRolePrefix() : java.lang.String
}
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::createSecurityExpressionRoot -- org.aopalliance.intercept.MethodInvocation::getThis : invocation.getThis() 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filter -- org.springframework.expression.EvaluationContext::getRootObject : ctx.getRootObject().getValue() 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filter -- org.springframework.expression.EvaluationContext::getRootObject : ctx.getRootObject() 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filter -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.format("Filtering with expression: %s",filterExpression.getExpressionString())) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filter -- org.springframework.core.log.LogMessage::format : LogMessage.format("Filtering with expression: %s",filterExpression.getExpressionString()) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filter -- org.springframework.expression.Expression::getExpressionString : filterExpression.getExpressionString() 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filter -- java.lang.Object::getClass : filterTarget.getClass().isArray() 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filter -- java.lang.Object::getClass : filterTarget.getClass() 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterCollection -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.format("Filtering collection with %s elements",filterTarget.size())) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterCollection -- org.springframework.core.log.LogMessage::format : LogMessage.format("Filtering collection with %s elements",filterTarget.size()) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterCollection -- java.util.Collection::size : filterTarget.size() 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterCollection -- java.util.Collection::size : filterTarget.size() 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterCollection -- org.springframework.security.access.PermissionCacheOptimizer::cachePermissionsFor : this.permissionCacheOptimizer.cachePermissionsFor(rootObject.getAuthentication(),filterTarget) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterCollection -- org.springframework.security.access.expression.method.MethodSecurityExpressionOperations::getAuthentication : rootObject.getAuthentication() 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterCollection -- org.springframework.security.access.expression.method.MethodSecurityExpressionOperations::setFilterObject : rootObject.setFilterObject(filterObject) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterCollection -- org.springframework.security.access.expression.ExpressionUtils::evaluateAsBoolean : ExpressionUtils.evaluateAsBoolean(filterExpression,ctx) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterCollection -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.format("Retaining elements: %s",retain)) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterCollection -- org.springframework.core.log.LogMessage::format : LogMessage.format("Retaining elements: %s",retain) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterCollection -- java.util.Collection::clear : filterTarget.clear() 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterCollection -- java.util.Collection::addAll : filterTarget.addAll(retain) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterCollection -- org.apache.commons.logging.Log::trace : this.logger.trace(LogMessage.format("Collection threw exception: %s. Will return a new instance instead of mutating its state.",readonly.getMessage())) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterCollection -- org.springframework.core.log.LogMessage::format : LogMessage.format("Collection threw exception: %s. Will return a new instance instead of mutating its state.",readonly.getMessage()) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterArray -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.format("Filtering array with %s elements",filterTarget.length)) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterArray -- org.springframework.core.log.LogMessage::format : LogMessage.format("Filtering array with %s elements",filterTarget.length) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterArray -- org.springframework.security.access.PermissionCacheOptimizer::cachePermissionsFor : this.permissionCacheOptimizer.cachePermissionsFor(rootObject.getAuthentication(),Arrays.asList(filterTarget)) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterArray -- org.springframework.security.access.expression.method.MethodSecurityExpressionOperations::getAuthentication : rootObject.getAuthentication() 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterArray -- java.util.Arrays::asList : Arrays.asList(filterTarget) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterArray -- org.springframework.security.access.expression.method.MethodSecurityExpressionOperations::setFilterObject : rootObject.setFilterObject(filterObject) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterArray -- org.springframework.security.access.expression.ExpressionUtils::evaluateAsBoolean : ExpressionUtils.evaluateAsBoolean(filterExpression,ctx) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterArray -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.format("Retaining elements: %s",retain)) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterArray -- org.springframework.core.log.LogMessage::format : LogMessage.format("Retaining elements: %s",retain) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterArray -- java.lang.reflect.Array::newInstance : Array.newInstance(filterTarget.getClass().getComponentType(),retain.size()) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterArray -- org.springframework.security.access.expression.method.Object[]::getClass : filterTarget.getClass().getComponentType() 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterArray -- org.springframework.security.access.expression.method.Object[]::getClass : filterTarget.getClass() 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterMap -- java.util.Map::size : filterTarget.size() 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterMap -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.format("Filtering map with %s elements",filterTarget.size())) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterMap -- org.springframework.core.log.LogMessage::format : LogMessage.format("Filtering map with %s elements",filterTarget.size()) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterMap -- java.util.Map::size : filterTarget.size() 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterMap -- java.util.Map::entrySet : filterTarget.entrySet() 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterMap -- org.springframework.security.access.expression.method.MethodSecurityExpressionOperations::setFilterObject : rootObject.setFilterObject(filterObject) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterMap -- org.springframework.security.access.expression.ExpressionUtils::evaluateAsBoolean : ExpressionUtils.evaluateAsBoolean(filterExpression,ctx) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterMap -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.format("Retaining elements: %s",retain)) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterMap -- org.springframework.core.log.LogMessage::format : LogMessage.format("Retaining elements: %s",retain) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterMap -- java.util.Map::clear : filterTarget.clear() 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterMap -- java.util.Map::putAll : filterTarget.putAll(retain) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterMap -- org.apache.commons.logging.Log::trace : this.logger.trace(LogMessage.format("Map threw exception: %s. Will return a new instance instead of mutating its state.",readonly.getMessage())) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterMap -- org.springframework.core.log.LogMessage::format : LogMessage.format("Map threw exception: %s. Will return a new instance instead of mutating its state.",readonly.getMessage()) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterStream -- java.util.stream.Stream::filter : filterTarget.filter((filterObject)->{rootObject.setFilterObject(filterObject);returnExpressionUtils.evaluateAsBoolean(filterExpression,ctx);}).onClose(filterTarget::close) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterStream -- java.util.stream.Stream::filter : filterTarget.filter((filterObject)->{rootObject.setFilterObject(filterObject);returnExpressionUtils.evaluateAsBoolean(filterExpression,ctx);}) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterStream -- org.springframework.security.access.expression.method.MethodSecurityExpressionOperations::setFilterObject : rootObject.setFilterObject(filterObject) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::filterStream -- org.springframework.security.access.expression.ExpressionUtils::evaluateAsBoolean : ExpressionUtils.evaluateAsBoolean(filterExpression,ctx) 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::setTrustResolver -- org.springframework.util.Assert::notNull : Assert.notNull(trustResolver,"trustResolver cannot be null") 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::setReturnObject -- org.springframework.expression.EvaluationContext::getRootObject : ctx.getRootObject().getValue() 
org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler::setReturnObject -- org.springframework.expression.EvaluationContext::getRootObject : ctx.getRootObject() 
class ExpressionBasedAnnotationAttributeFactory  implements org.springframework.security.access.prepost.PrePostInvocationAttributeFactory  {
  parserLock : java.lang.Object
  parser : org.springframework.expression.ExpressionParser
  handler : org.springframework.security.access.expression.method.MethodSecurityExpressionHandler
  ExpressionBasedAnnotationAttributeFactory(handler : org.springframework.security.access.expression.method.MethodSecurityExpressionHandler) : None
  createPreInvocationAttribute(preFilterAttribute : java.lang.String, filterObject : java.lang.String, preAuthorizeAttribute : java.lang.String) : org.springframework.security.access.prepost.PreInvocationAttribute
  createPostInvocationAttribute(postFilterAttribute : java.lang.String, postAuthorizeAttribute : java.lang.String) : org.springframework.security.access.prepost.PostInvocationAttribute
  getParser() : org.springframework.expression.ExpressionParser
}
org.springframework.security.access.expression.method.ExpressionBasedAnnotationAttributeFactory::createPreInvocationAttribute -- org.springframework.expression.ExpressionParser::parseExpression : parser.parseExpression(preAuthorizeAttribute) 
org.springframework.security.access.expression.method.ExpressionBasedAnnotationAttributeFactory::createPreInvocationAttribute -- org.springframework.expression.ExpressionParser::parseExpression : parser.parseExpression("permitAll") 
org.springframework.security.access.expression.method.ExpressionBasedAnnotationAttributeFactory::createPreInvocationAttribute -- org.springframework.expression.ExpressionParser::parseExpression : parser.parseExpression(preFilterAttribute) 
org.springframework.security.access.expression.method.ExpressionBasedAnnotationAttributeFactory::createPostInvocationAttribute -- org.springframework.expression.ExpressionParser::parseExpression : parser.parseExpression(postAuthorizeAttribute) 
org.springframework.security.access.expression.method.ExpressionBasedAnnotationAttributeFactory::createPostInvocationAttribute -- org.springframework.expression.ExpressionParser::parseExpression : parser.parseExpression(postFilterAttribute) 
org.springframework.security.access.expression.method.ExpressionBasedAnnotationAttributeFactory::getParser -- org.springframework.security.access.expression.method.MethodSecurityExpressionHandler::getExpressionParser : this.handler.getExpressionParser() 
class ExpressionBasedPostInvocationAdvice  implements org.springframework.security.access.prepost.PostInvocationAuthorizationAdvice  {
  logger : org.apache.commons.logging.Log
  expressionHandler : org.springframework.security.access.expression.method.MethodSecurityExpressionHandler
  ExpressionBasedPostInvocationAdvice(expressionHandler : org.springframework.security.access.expression.method.MethodSecurityExpressionHandler) : None
  after(authentication : org.springframework.security.core.Authentication, mi : org.aopalliance.intercept.MethodInvocation, postAttr : org.springframework.security.access.prepost.PostInvocationAttribute, returnedObject : java.lang.Object) : java.lang.Object
}
org.springframework.security.access.expression.method.ExpressionBasedPostInvocationAdvice::after -- org.springframework.security.access.expression.method.MethodSecurityExpressionHandler::createEvaluationContext : this.expressionHandler.createEvaluationContext(authentication,mi) 
org.springframework.security.access.expression.method.ExpressionBasedPostInvocationAdvice::after -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.format("Applying PostFilter expression %s",postFilter)) 
org.springframework.security.access.expression.method.ExpressionBasedPostInvocationAdvice::after -- org.springframework.core.log.LogMessage::format : LogMessage.format("Applying PostFilter expression %s",postFilter) 
org.springframework.security.access.expression.method.ExpressionBasedPostInvocationAdvice::after -- org.springframework.security.access.expression.method.MethodSecurityExpressionHandler::filter : this.expressionHandler.filter(returnedObject,postFilter,ctx) 
org.springframework.security.access.expression.method.ExpressionBasedPostInvocationAdvice::after -- org.apache.commons.logging.Log::debug : this.logger.debug("Return object is null, filtering will be skipped") 
org.springframework.security.access.expression.method.ExpressionBasedPostInvocationAdvice::after -- org.springframework.security.access.expression.method.MethodSecurityExpressionHandler::setReturnObject : this.expressionHandler.setReturnObject(returnedObject,ctx) 
org.springframework.security.access.expression.method.ExpressionBasedPostInvocationAdvice::after -- org.springframework.security.access.expression.ExpressionUtils::evaluateAsBoolean : ExpressionUtils.evaluateAsBoolean(postAuthorize,ctx) 
org.springframework.security.access.expression.method.ExpressionBasedPostInvocationAdvice::after -- org.apache.commons.logging.Log::debug : this.logger.debug("PostAuthorize expression rejected access") 
class ExpressionBasedPreInvocationAdvice  implements org.springframework.security.access.prepost.PreInvocationAuthorizationAdvice  {
  expressionHandler : org.springframework.security.access.expression.method.MethodSecurityExpressionHandler
  before(authentication : org.springframework.security.core.Authentication, mi : org.aopalliance.intercept.MethodInvocation, attr : org.springframework.security.access.prepost.PreInvocationAttribute) : boolean
  findFilterTarget(filterTargetName : java.lang.String, ctx : org.springframework.expression.EvaluationContext, invocation : org.aopalliance.intercept.MethodInvocation) : java.lang.Object
  setExpressionHandler(expressionHandler : org.springframework.security.access.expression.method.MethodSecurityExpressionHandler) : void
}
org.springframework.security.access.expression.method.ExpressionBasedPreInvocationAdvice::before -- org.springframework.security.access.expression.method.MethodSecurityExpressionHandler::createEvaluationContext : this.expressionHandler.createEvaluationContext(authentication,mi) 
org.springframework.security.access.expression.method.ExpressionBasedPreInvocationAdvice::before -- org.springframework.security.access.expression.method.MethodSecurityExpressionHandler::filter : this.expressionHandler.filter(filterTarget,preFilter,ctx) 
org.springframework.security.access.expression.method.ExpressionBasedPreInvocationAdvice::before -- org.springframework.security.access.expression.ExpressionUtils::evaluateAsBoolean : ExpressionUtils.evaluateAsBoolean(preAuthorize,ctx) 
org.springframework.security.access.expression.method.ExpressionBasedPreInvocationAdvice::findFilterTarget -- java.lang.String::length : filterTargetName.length() 
org.springframework.security.access.expression.method.ExpressionBasedPreInvocationAdvice::findFilterTarget -- org.springframework.expression.EvaluationContext::lookupVariable : ctx.lookupVariable(filterTargetName) 
org.springframework.security.access.expression.method.ExpressionBasedPreInvocationAdvice::findFilterTarget -- org.springframework.util.Assert::notNull : Assert.notNull(filterTarget,()->"Filter target was null, or no argument with name "+filterTargetName+" found in method") 
org.springframework.security.access.expression.method.ExpressionBasedPreInvocationAdvice::findFilterTarget -- org.aopalliance.intercept.MethodInvocation::getArguments : invocation.getArguments().length 
org.springframework.security.access.expression.method.ExpressionBasedPreInvocationAdvice::findFilterTarget -- org.aopalliance.intercept.MethodInvocation::getArguments : invocation.getArguments() 
org.springframework.security.access.expression.method.ExpressionBasedPreInvocationAdvice::findFilterTarget -- org.aopalliance.intercept.MethodInvocation::getArguments : invocation.getArguments() 
org.springframework.security.access.expression.method.ExpressionBasedPreInvocationAdvice::findFilterTarget -- org.springframework.util.Assert::notNull : Assert.notNull(filterTarget,()->"A PreFilter expression was set but the method argument type"+arg.getClass()+" is not filterable") 
org.springframework.security.access.expression.method.ExpressionBasedPreInvocationAdvice::findFilterTarget -- org.aopalliance.intercept.MethodInvocation::getArguments : invocation.getArguments().length 
org.springframework.security.access.expression.method.ExpressionBasedPreInvocationAdvice::findFilterTarget -- org.aopalliance.intercept.MethodInvocation::getArguments : invocation.getArguments() 
org.springframework.security.access.expression.method.ExpressionBasedPreInvocationAdvice::findFilterTarget -- org.springframework.util.Assert::isTrue : Assert.isTrue(!filterTarget.getClass().isArray(),"Pre-filtering on array types is not supported. Using a Collection will solve this problem") 
class MethodSecurityEvaluationContext extends org.springframework.context.expression.MethodBasedEvaluationContext   {
  MethodSecurityEvaluationContext(user : org.springframework.security.core.Authentication, mi : org.aopalliance.intercept.MethodInvocation) : None
  MethodSecurityEvaluationContext(user : org.springframework.security.core.Authentication, mi : org.aopalliance.intercept.MethodInvocation, parameterNameDiscoverer : org.springframework.core.ParameterNameDiscoverer) : None
  MethodSecurityEvaluationContext(root : org.springframework.security.access.expression.method.MethodSecurityExpressionOperations, mi : org.aopalliance.intercept.MethodInvocation, parameterNameDiscoverer : org.springframework.core.ParameterNameDiscoverer) : None
  getSpecificMethod(mi : org.aopalliance.intercept.MethodInvocation) : java.lang.reflect.Method
}
org.springframework.security.access.expression.method.MethodSecurityEvaluationContext::MethodSecurityEvaluationContext -- org.aopalliance.intercept.MethodInvocation::getThis : mi.getThis() 
org.springframework.security.access.expression.method.MethodSecurityEvaluationContext::MethodSecurityEvaluationContext -- org.aopalliance.intercept.MethodInvocation::getArguments : mi.getArguments() 
org.springframework.security.access.expression.method.MethodSecurityEvaluationContext::MethodSecurityEvaluationContext -- org.aopalliance.intercept.MethodInvocation::getArguments : mi.getArguments() 
org.springframework.security.access.expression.method.MethodSecurityEvaluationContext::getSpecificMethod -- org.springframework.aop.support.AopUtils::getMostSpecificMethod : AopUtils.getMostSpecificMethod(mi.getMethod(),AopProxyUtils.ultimateTargetClass(mi.getThis())) 
org.springframework.security.access.expression.method.MethodSecurityEvaluationContext::getSpecificMethod -- org.aopalliance.intercept.MethodInvocation::getMethod : mi.getMethod() 
org.springframework.security.access.expression.method.MethodSecurityEvaluationContext::getSpecificMethod -- org.springframework.aop.framework.AopProxyUtils::ultimateTargetClass : AopProxyUtils.ultimateTargetClass(mi.getThis()) 
org.springframework.security.access.expression.method.MethodSecurityEvaluationContext::getSpecificMethod -- org.aopalliance.intercept.MethodInvocation::getThis : mi.getThis() 
interface MethodSecurityExpressionHandler    {
  filter(filterTarget : java.lang.Object, filterExpression : org.springframework.expression.Expression, ctx : org.springframework.expression.EvaluationContext) : java.lang.Object
  setReturnObject(returnObject : java.lang.Object, ctx : org.springframework.expression.EvaluationContext) : void
}
interface MethodSecurityExpressionOperations    {
  setFilterObject(filterObject : java.lang.Object) : void
  getFilterObject() : java.lang.Object
  setReturnObject(returnObject : java.lang.Object) : void
  getReturnObject() : java.lang.Object
  getThis() : java.lang.Object
}
class MethodSecurityExpressionRoot extends org.springframework.security.access.expression.SecurityExpressionRoot implements org.springframework.security.access.expression.method.MethodSecurityExpressionOperations  {
  filterObject : java.lang.Object
  returnObject : java.lang.Object
  target : java.lang.Object
  MethodSecurityExpressionRoot(a : org.springframework.security.core.Authentication) : None
  MethodSecurityExpressionRoot(authentication : java.util.function.Supplier) : None
  setFilterObject(filterObject : java.lang.Object) : void
  getFilterObject() : java.lang.Object
  setReturnObject(returnObject : java.lang.Object) : void
  getReturnObject() : java.lang.Object
  setThis(target : java.lang.Object) : void
  getThis() : java.lang.Object
}
class PostInvocationExpressionAttribute extends org.springframework.security.access.expression.method.AbstractExpressionBasedMethodConfigAttribute implements org.springframework.security.access.prepost.PostInvocationAttribute  {
  PostInvocationExpressionAttribute(filterExpression : java.lang.String, authorizeExpression : java.lang.String) : None
  PostInvocationExpressionAttribute(filterExpression : org.springframework.expression.Expression, authorizeExpression : org.springframework.expression.Expression) : None
  toString() : java.lang.String
}
class PreInvocationExpressionAttribute extends org.springframework.security.access.expression.method.AbstractExpressionBasedMethodConfigAttribute implements org.springframework.security.access.prepost.PreInvocationAttribute  {
  filterTarget : java.lang.String
  PreInvocationExpressionAttribute(filterExpression : java.lang.String, filterTarget : java.lang.String, authorizeExpression : java.lang.String) : None
  PreInvocationExpressionAttribute(filterExpression : org.springframework.expression.Expression, filterTarget : java.lang.String, authorizeExpression : org.springframework.expression.Expression) : None
  getFilterTarget() : java.lang.String
  toString() : java.lang.String
}
}
class AbstractSecurityExpressionHandler  implements org.springframework.security.access.expression.SecurityExpressionHandler  {
  expressionParser : org.springframework.expression.ExpressionParser
  beanResolver : org.springframework.expression.BeanResolver
  roleHierarchy : org.springframework.security.access.hierarchicalroles.RoleHierarchy
  permissionEvaluator : org.springframework.security.access.PermissionEvaluator
  getExpressionParser() : org.springframework.expression.ExpressionParser
  setExpressionParser(expressionParser : org.springframework.expression.ExpressionParser) : void
  createEvaluationContext(authentication : org.springframework.security.core.Authentication, invocation : org.springframework.security.access.expression.T) : org.springframework.expression.EvaluationContext
  createEvaluationContextInternal(authentication : org.springframework.security.core.Authentication, invocation : org.springframework.security.access.expression.T) : org.springframework.expression.spel.support.StandardEvaluationContext
  createSecurityExpressionRoot(authentication : org.springframework.security.core.Authentication, invocation : org.springframework.security.access.expression.T) : org.springframework.security.access.expression.SecurityExpressionOperations
  getRoleHierarchy() : org.springframework.security.access.hierarchicalroles.RoleHierarchy
  setRoleHierarchy(roleHierarchy : org.springframework.security.access.hierarchicalroles.RoleHierarchy) : void
  getPermissionEvaluator() : org.springframework.security.access.PermissionEvaluator
  setPermissionEvaluator(permissionEvaluator : org.springframework.security.access.PermissionEvaluator) : void
  getBeanResolver() : org.springframework.expression.BeanResolver
  setApplicationContext(applicationContext : org.springframework.context.ApplicationContext) : void
}
org.springframework.security.access.expression.AbstractSecurityExpressionHandler::setExpressionParser -- org.springframework.util.Assert::notNull : Assert.notNull(expressionParser,"expressionParser cannot be null") 
class DenyAllPermissionEvaluator  implements org.springframework.security.access.PermissionEvaluator  {
  logger : org.apache.commons.logging.Log
  hasPermission(authentication : org.springframework.security.core.Authentication, target : java.lang.Object, permission : java.lang.Object) : boolean
  hasPermission(authentication : org.springframework.security.core.Authentication, targetId : java.io.Serializable, targetType : java.lang.String, permission : java.lang.Object) : boolean
}
org.springframework.security.access.expression.DenyAllPermissionEvaluator::hasPermission -- org.apache.commons.logging.Log::warn : this.logger.warn(LogMessage.format("Denying user %s permission '%s' on object %s",authentication.getName(),permission,target)) 
org.springframework.security.access.expression.DenyAllPermissionEvaluator::hasPermission -- org.springframework.core.log.LogMessage::format : LogMessage.format("Denying user %s permission '%s' on object %s",authentication.getName(),permission,target) 
org.springframework.security.access.expression.DenyAllPermissionEvaluator::hasPermission -- org.springframework.security.core.Authentication::getName : authentication.getName() 
org.springframework.security.access.expression.DenyAllPermissionEvaluator::hasPermission -- org.apache.commons.logging.Log::warn : this.logger.warn(LogMessage.format("Denying user %s permission '%s' on object with Id %s",authentication.getName(),permission,targetId)) 
org.springframework.security.access.expression.DenyAllPermissionEvaluator::hasPermission -- org.springframework.core.log.LogMessage::format : LogMessage.format("Denying user %s permission '%s' on object with Id %s",authentication.getName(),permission,targetId) 
org.springframework.security.access.expression.DenyAllPermissionEvaluator::hasPermission -- org.springframework.security.core.Authentication::getName : authentication.getName() 
class ExpressionUtils    {
  ExpressionUtils() : None
  evaluateAsBoolean(expr : org.springframework.expression.Expression, ctx : org.springframework.expression.EvaluationContext) : boolean
}
org.springframework.security.access.expression.ExpressionUtils::evaluateAsBoolean -- org.springframework.expression.Expression::getValue : expr.getValue(ctx,Boolean.class) 
org.springframework.security.access.expression.ExpressionUtils::evaluateAsBoolean -- org.springframework.expression.Expression::getExpressionString : expr.getExpressionString() 
interface SecurityExpressionHandler    {
  getExpressionParser() : org.springframework.expression.ExpressionParser
  createEvaluationContext(authentication : org.springframework.security.core.Authentication, invocation : org.springframework.security.access.expression.T) : org.springframework.expression.EvaluationContext
  createEvaluationContext(authentication : java.util.function.Supplier, invocation : org.springframework.security.access.expression.T) : org.springframework.expression.EvaluationContext
}
org.springframework.security.access.expression.SecurityExpressionHandler::createEvaluationContext -- java.util.function.Supplier::get : authentication.get() 
interface SecurityExpressionOperations    {
  getAuthentication() : org.springframework.security.core.Authentication
  hasAuthority(authority : java.lang.String) : boolean
  hasAnyAuthority() : boolean
  hasRole(role : java.lang.String) : boolean
  hasAnyRole() : boolean
  permitAll() : boolean
  denyAll() : boolean
  isAnonymous() : boolean
  isAuthenticated() : boolean
  isRememberMe() : boolean
  isFullyAuthenticated() : boolean
  hasPermission(target : java.lang.Object, permission : java.lang.Object) : boolean
  hasPermission(targetId : java.lang.Object, targetType : java.lang.String, permission : java.lang.Object) : boolean
}
class SecurityExpressionRoot  implements org.springframework.security.access.expression.SecurityExpressionOperations  {
  authentication : java.util.function.Supplier
  trustResolver : org.springframework.security.authentication.AuthenticationTrustResolver
  roleHierarchy : org.springframework.security.access.hierarchicalroles.RoleHierarchy
  roles : java.util.Set
  defaultRolePrefix : java.lang.String
  permitAll : boolean
  denyAll : boolean
  permissionEvaluator : org.springframework.security.access.PermissionEvaluator
  read : java.lang.String
  write : java.lang.String
  create : java.lang.String
  delete : java.lang.String
  admin : java.lang.String
  SecurityExpressionRoot(authentication : org.springframework.security.core.Authentication) : None
  SecurityExpressionRoot(authentication : java.util.function.Supplier) : None
  hasAuthority(authority : java.lang.String) : boolean
  hasAnyAuthority() : boolean
  hasRole(role : java.lang.String) : boolean
  hasAnyRole() : boolean
  hasAnyAuthorityName(prefix : java.lang.String) : boolean
  getAuthentication() : org.springframework.security.core.Authentication
  permitAll() : boolean
  denyAll() : boolean
  isAnonymous() : boolean
  isAuthenticated() : boolean
  isRememberMe() : boolean
  isFullyAuthenticated() : boolean
  getPrincipal() : java.lang.Object
  setTrustResolver(trustResolver : org.springframework.security.authentication.AuthenticationTrustResolver) : void
  setRoleHierarchy(roleHierarchy : org.springframework.security.access.hierarchicalroles.RoleHierarchy) : void
  setDefaultRolePrefix(defaultRolePrefix : java.lang.String) : void
  getAuthoritySet() : java.util.Set
  hasPermission(target : java.lang.Object, permission : java.lang.Object) : boolean
  hasPermission(targetId : java.lang.Object, targetType : java.lang.String, permission : java.lang.Object) : boolean
  setPermissionEvaluator(permissionEvaluator : org.springframework.security.access.PermissionEvaluator) : void
  getRoleWithDefaultPrefix(defaultRolePrefix : java.lang.String, role : java.lang.String) : java.lang.String
}
org.springframework.security.access.expression.SecurityExpressionRoot::SecurityExpressionRoot -- org.springframework.util.function.SingletonSupplier::of : SingletonSupplier.of(()->{Authenticationvalue=authentication.get();Assert.notNull(value,"Authentication object cannot be null");returnvalue;}) 
org.springframework.security.access.expression.SecurityExpressionRoot::SecurityExpressionRoot -- java.util.function.Supplier::get : authentication.get() 
org.springframework.security.access.expression.SecurityExpressionRoot::SecurityExpressionRoot -- org.springframework.util.Assert::notNull : Assert.notNull(value,"Authentication object cannot be null") 
org.springframework.security.access.expression.SecurityExpressionRoot::getAuthentication -- java.util.function.Supplier::get : this.authentication.get() 
org.springframework.security.access.expression.SecurityExpressionRoot::isAnonymous -- org.springframework.security.authentication.AuthenticationTrustResolver::isAnonymous : this.trustResolver.isAnonymous(getAuthentication()) 
org.springframework.security.access.expression.SecurityExpressionRoot::isAuthenticated -- org.springframework.security.authentication.AuthenticationTrustResolver::isAuthenticated : this.trustResolver.isAuthenticated(getAuthentication()) 
org.springframework.security.access.expression.SecurityExpressionRoot::isRememberMe -- org.springframework.security.authentication.AuthenticationTrustResolver::isRememberMe : this.trustResolver.isRememberMe(getAuthentication()) 
org.springframework.security.access.expression.SecurityExpressionRoot::isFullyAuthenticated -- org.springframework.security.authentication.AuthenticationTrustResolver::isFullyAuthenticated : this.trustResolver.isFullyAuthenticated(authentication) 
org.springframework.security.access.expression.SecurityExpressionRoot::getPrincipal -- org.springframework.security.access.expression.SecurityExpressionRoot::getAuthentication : getAuthentication().getPrincipal() 
org.springframework.security.access.expression.SecurityExpressionRoot::getAuthoritySet -- org.springframework.security.access.expression.SecurityExpressionRoot::getAuthentication : getAuthentication().getAuthorities() 
org.springframework.security.access.expression.SecurityExpressionRoot::getAuthoritySet -- org.springframework.security.access.hierarchicalroles.RoleHierarchy::getReachableGrantedAuthorities : this.roleHierarchy.getReachableGrantedAuthorities(userAuthorities) 
org.springframework.security.access.expression.SecurityExpressionRoot::getAuthoritySet -- org.springframework.security.core.authority.AuthorityUtils::authorityListToSet : AuthorityUtils.authorityListToSet(userAuthorities) 
org.springframework.security.access.expression.SecurityExpressionRoot::hasPermission -- org.springframework.security.access.PermissionEvaluator::hasPermission : this.permissionEvaluator.hasPermission(getAuthentication(),target,permission) 
org.springframework.security.access.expression.SecurityExpressionRoot::hasPermission -- org.springframework.security.access.PermissionEvaluator::hasPermission : this.permissionEvaluator.hasPermission(getAuthentication(),(Serializable)targetId,targetType,permission) 
org.springframework.security.access.expression.SecurityExpressionRoot::getRoleWithDefaultPrefix -- java.lang.String::length : defaultRolePrefix.length() 
org.springframework.security.access.expression.SecurityExpressionRoot::getRoleWithDefaultPrefix -- java.lang.String::startsWith : role.startsWith(defaultRolePrefix) 
}
package hierarchicalroles {
class CycleInRoleHierarchyException extends org.springframework.security.access.hierarchicalroles.RuntimeException   {
  serialVersionUID : long
  CycleInRoleHierarchyException() : None
}
class NullRoleHierarchy  implements org.springframework.security.access.hierarchicalroles.RoleHierarchy  {
  getReachableGrantedAuthorities(authorities : java.util.Collection) : java.util.Collection
}
interface RoleHierarchy    {
  getReachableGrantedAuthorities(authorities : java.util.Collection) : java.util.Collection
}
class RoleHierarchyAuthoritiesMapper  implements org.springframework.security.core.authority.mapping.GrantedAuthoritiesMapper  {
  roleHierarchy : org.springframework.security.access.hierarchicalroles.RoleHierarchy
  RoleHierarchyAuthoritiesMapper(roleHierarchy : org.springframework.security.access.hierarchicalroles.RoleHierarchy) : None
  mapAuthorities(authorities : java.util.Collection) : java.util.Collection
}
org.springframework.security.access.hierarchicalroles.RoleHierarchyAuthoritiesMapper::mapAuthorities -- org.springframework.security.access.hierarchicalroles.RoleHierarchy::getReachableGrantedAuthorities : this.roleHierarchy.getReachableGrantedAuthorities(authorities) 
class RoleHierarchyImpl  implements org.springframework.security.access.hierarchicalroles.RoleHierarchy  {
  logger : org.apache.commons.logging.Log
  rolesReachableInOneOrMoreStepsMap : java.util.Map
  RoleHierarchyImpl() : None
  RoleHierarchyImpl(hierarchy : java.util.Map) : None
  fromHierarchy(hierarchy : java.lang.String) : org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl
  withDefaultRolePrefix() : org.springframework.security.access.hierarchicalroles.Builder
  withRolePrefix(rolePrefix : java.lang.String) : org.springframework.security.access.hierarchicalroles.Builder
  setHierarchy(roleHierarchyStringRepresentation : java.lang.String) : void
  getReachableGrantedAuthorities(authorities : java.util.Collection) : java.util.Collection
  buildRolesReachableInOneStepMap(hierarchy : java.lang.String) : java.util.Map
  buildRolesReachableInOneOrMoreStepsMap(hierarchy : java.util.Map) : java.util.Map
}
org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl::withRolePrefix -- org.springframework.util.Assert::notNull : Assert.notNull(rolePrefix,"rolePrefix must not be null") 
org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl::setHierarchy -- org.apache.commons.logging.Log::debug : logger.debug(LogMessage.format("setHierarchy() - The following role hierarchy was set: %s",roleHierarchyStringRepresentation)) 
org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl::setHierarchy -- org.springframework.core.log.LogMessage::format : LogMessage.format("setHierarchy() - The following role hierarchy was set: %s",roleHierarchyStringRepresentation) 
org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl::getReachableGrantedAuthorities -- java.util.Collection::isEmpty : authorities.isEmpty() 
org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl::getReachableGrantedAuthorities -- java.util.Map::get : this.rolesReachableInOneOrMoreStepsMap.get(authority.getAuthority()) 
org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl::getReachableGrantedAuthorities -- org.apache.commons.logging.Log::debug : logger.debug(LogMessage.format("getReachableGrantedAuthorities() - From the roles %s one can reach %s in zero or more steps.",authorities,reachableRoles)) 
org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl::getReachableGrantedAuthorities -- org.springframework.core.log.LogMessage::format : LogMessage.format("getReachableGrantedAuthorities() - From the roles %s one can reach %s in zero or more steps.",authorities,reachableRoles) 
org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl::buildRolesReachableInOneStepMap -- java.lang.String::split : hierarchy.split("\n") 
org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl::buildRolesReachableInOneStepMap -- org.apache.commons.logging.Log::debug : logger.debug(LogMessage.format("buildRolesReachableInOneStepMap() - From role %s one can reach role %s in one step.",higherRole,lowerRole)) 
org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl::buildRolesReachableInOneStepMap -- org.springframework.core.log.LogMessage::format : LogMessage.format("buildRolesReachableInOneStepMap() - From role %s one can reach role %s in one step.",higherRole,lowerRole) 
org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl::buildRolesReachableInOneOrMoreStepsMap -- java.util.Map::keySet : hierarchy.keySet() 
org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl::buildRolesReachableInOneOrMoreStepsMap -- java.util.Map::get : hierarchy.get(roleName) 
org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl::buildRolesReachableInOneOrMoreStepsMap -- java.util.Map::containsKey : hierarchy.containsKey(lowerRole.getAuthority()) 
org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl::buildRolesReachableInOneOrMoreStepsMap -- java.util.Map::get : hierarchy.get(lowerRole.getAuthority()) 
org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl::buildRolesReachableInOneOrMoreStepsMap -- java.util.Map::put : rolesReachableInOneOrMoreStepsMap.put(roleName,visitedRolesSet) 
org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl::buildRolesReachableInOneOrMoreStepsMap -- org.apache.commons.logging.Log::debug : logger.debug(LogMessage.format("buildRolesReachableInOneOrMoreStepsMap() - From role %s one can reach %s in one or more steps.",roleName,visitedRolesSet)) 
org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl::buildRolesReachableInOneOrMoreStepsMap -- org.springframework.core.log.LogMessage::format : LogMessage.format("buildRolesReachableInOneOrMoreStepsMap() - From role %s one can reach %s in one or more steps.",roleName,visitedRolesSet) 
class Builder    {
  rolePrefix : java.lang.String
  hierarchy : org.springframework.security.access.hierarchicalroles.Map
  Builder(rolePrefix : java.lang.String) : None
  role(role : java.lang.String) : org.springframework.security.access.hierarchicalroles.ImpliedRoles
  build() : org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl
  addHierarchy(role : java.lang.String) : org.springframework.security.access.hierarchicalroles.Builder
}
org.springframework.security.access.hierarchicalroles.Builder::role -- org.springframework.security.access.hierarchicalroles.Assert::hasText : Assert.hasText(role,"role must not be empty") 
org.springframework.security.access.hierarchicalroles.Builder::addHierarchy -- org.springframework.security.access.hierarchicalroles.Map::computeIfAbsent : this.hierarchy.computeIfAbsent(this.rolePrefix.concat(role),(r)->newHashSet<>()) 
org.springframework.security.access.hierarchicalroles.Builder::addHierarchy -- java.lang.String::concat : this.rolePrefix.concat(role) 
org.springframework.security.access.hierarchicalroles.Builder::addHierarchy -- java.lang.String::concat : this.rolePrefix.concat(impliedRole) 
class ImpliedRoles    {
  role : java.lang.String
  ImpliedRoles(role : java.lang.String) : None
  implies() : org.springframework.security.access.hierarchicalroles.Builder
}
org.springframework.security.access.hierarchicalroles.ImpliedRoles::implies -- org.springframework.security.access.hierarchicalroles.Assert::notEmpty : Assert.notEmpty(impliedRoles,"at least one implied role must be provided") 
org.springframework.security.access.hierarchicalroles.ImpliedRoles::implies -- org.springframework.security.access.hierarchicalroles.Assert::noNullElements : Assert.noNullElements(impliedRoles,"implied role name(s) cannot be empty") 
org.springframework.security.access.hierarchicalroles.ImpliedRoles::implies -- org.springframework.security.access.hierarchicalroles.Builder::addHierarchy : Builder.this.addHierarchy(this.role,impliedRoles) 
class RoleHierarchyUtils    {
  RoleHierarchyUtils() : None
  roleHierarchyFromMap(roleHierarchyMap : java.util.Map) : java.lang.String
}
org.springframework.security.access.hierarchicalroles.RoleHierarchyUtils::roleHierarchyFromMap -- org.springframework.util.Assert::notEmpty : Assert.notEmpty(roleHierarchyMap,"roleHierarchyMap cannot be empty") 
org.springframework.security.access.hierarchicalroles.RoleHierarchyUtils::roleHierarchyFromMap -- java.util.Map::forEach : roleHierarchyMap.forEach((role,impliedRoles)->{Assert.hasLength(role,"role name must be supplied");Assert.notEmpty(impliedRoles,"implied role name(s) cannot be empty");for(StringimpliedRole:impliedRoles){writer.println(role+" > "+impliedRole);}}) 
org.springframework.security.access.hierarchicalroles.RoleHierarchyUtils::roleHierarchyFromMap -- org.springframework.util.Assert::hasLength : Assert.hasLength(role,"role name must be supplied") 
org.springframework.security.access.hierarchicalroles.RoleHierarchyUtils::roleHierarchyFromMap -- org.springframework.util.Assert::notEmpty : Assert.notEmpty(impliedRoles,"implied role name(s) cannot be empty") 
}
package intercept {
package aopalliance {
class MethodSecurityInterceptor extends org.springframework.security.access.intercept.AbstractSecurityInterceptor implements org.aopalliance.intercept.MethodInterceptor  {
  securityMetadataSource : org.springframework.security.access.method.MethodSecurityMetadataSource
  getSecureObjectClass() : java.lang.Class
  invoke(mi : org.aopalliance.intercept.MethodInvocation) : java.lang.Object
  getSecurityMetadataSource() : org.springframework.security.access.method.MethodSecurityMetadataSource
  obtainSecurityMetadataSource() : org.springframework.security.access.SecurityMetadataSource
  setSecurityMetadataSource(newSource : org.springframework.security.access.method.MethodSecurityMetadataSource) : void
}
org.springframework.security.access.intercept.aopalliance.MethodSecurityInterceptor::invoke -- org.aopalliance.intercept.MethodInvocation::proceed : mi.proceed() 
class MethodSecurityMetadataSourceAdvisor extends org.springframework.aop.support.AbstractPointcutAdvisor implements org.springframework.beans.factory.BeanFactoryAware  {
  attributeSource : org.springframework.security.access.method.MethodSecurityMetadataSource
  interceptor : org.aopalliance.intercept.MethodInterceptor
  pointcut : org.springframework.aop.Pointcut
  beanFactory : org.springframework.beans.factory.BeanFactory
  adviceBeanName : java.lang.String
  metadataSourceBeanName : java.lang.String
  adviceMonitor : java.lang.Object
  MethodSecurityMetadataSourceAdvisor(adviceBeanName : java.lang.String, attributeSource : org.springframework.security.access.method.MethodSecurityMetadataSource, attributeSourceBeanName : java.lang.String) : None
  getPointcut() : org.springframework.aop.Pointcut
  getAdvice() : org.aopalliance.aop.Advice
  setBeanFactory(beanFactory : org.springframework.beans.factory.BeanFactory) : void
  readObject(ois : java.io.ObjectInputStream) : void
}
org.springframework.security.access.intercept.aopalliance.MethodSecurityMetadataSourceAdvisor::MethodSecurityMetadataSourceAdvisor -- org.springframework.util.Assert::notNull : Assert.notNull(adviceBeanName,"The adviceBeanName cannot be null") 
org.springframework.security.access.intercept.aopalliance.MethodSecurityMetadataSourceAdvisor::MethodSecurityMetadataSourceAdvisor -- org.springframework.util.Assert::notNull : Assert.notNull(attributeSource,"The attributeSource cannot be null") 
org.springframework.security.access.intercept.aopalliance.MethodSecurityMetadataSourceAdvisor::MethodSecurityMetadataSourceAdvisor -- org.springframework.util.Assert::notNull : Assert.notNull(attributeSourceBeanName,"The attributeSourceBeanName cannot be null") 
org.springframework.security.access.intercept.aopalliance.MethodSecurityMetadataSourceAdvisor::getAdvice -- org.springframework.util.Assert::notNull : Assert.notNull(this.adviceBeanName,"'adviceBeanName' must be set for use with bean factory lookup.") 
org.springframework.security.access.intercept.aopalliance.MethodSecurityMetadataSourceAdvisor::getAdvice -- org.springframework.util.Assert::state : Assert.state(this.beanFactory!=null,"BeanFactory must be set to resolve 'adviceBeanName'") 
org.springframework.security.access.intercept.aopalliance.MethodSecurityMetadataSourceAdvisor::getAdvice -- org.springframework.beans.factory.BeanFactory::getBean : this.beanFactory.getBean(this.adviceBeanName,MethodInterceptor.class) 
org.springframework.security.access.intercept.aopalliance.MethodSecurityMetadataSourceAdvisor::readObject -- java.io.ObjectInputStream::defaultReadObject : ois.defaultReadObject() 
org.springframework.security.access.intercept.aopalliance.MethodSecurityMetadataSourceAdvisor::readObject -- org.springframework.beans.factory.BeanFactory::getBean : this.beanFactory.getBean(this.metadataSourceBeanName,MethodSecurityMetadataSource.class) 
class MethodSecurityMetadataSourcePointcut extends org.springframework.security.access.intercept.aopalliance.StaticMethodMatcherPointcut implements org.springframework.security.access.intercept.aopalliance.Serializable  {
  matches(m : org.springframework.security.access.intercept.aopalliance.Method, targetClass : java.lang.Class) : boolean
}
org.springframework.security.access.intercept.aopalliance.MethodSecurityMetadataSourcePointcut::matches -- org.springframework.security.access.intercept.aopalliance.CollectionUtils::isEmpty : CollectionUtils.isEmpty(source.getAttributes(m,targetClass)) 
}
package aspectj {
interface AspectJCallback    {
  proceedWithObject() : java.lang.Object
}
class AspectJMethodSecurityInterceptor extends org.springframework.security.access.intercept.aopalliance.MethodSecurityInterceptor   {
  invoke(jp : org.aspectj.lang.JoinPoint) : java.lang.Object
  invoke(jp : org.aspectj.lang.JoinPoint, advisorProceed : org.springframework.security.access.intercept.aspectj.AspectJCallback) : java.lang.Object
}
org.springframework.security.access.intercept.aspectj.AspectJMethodSecurityInterceptor::invoke -- org.springframework.security.access.intercept.aspectj.AspectJCallback::proceedWithObject : advisorProceed.proceedWithObject() 
class MethodInvocationAdapter  implements org.aopalliance.intercept.MethodInvocation  {
  jp : org.aspectj.lang.ProceedingJoinPoint
  method : java.lang.reflect.Method
  target : java.lang.Object
  MethodInvocationAdapter(jp : org.aspectj.lang.JoinPoint) : None
  findMethod(name : java.lang.String, declaringType : java.lang.Class, params : java.lang.Class) : java.lang.reflect.Method
  getMethod() : java.lang.reflect.Method
  getArguments() : org.springframework.security.access.intercept.aspectj.Object[]
  getStaticPart() : java.lang.reflect.AccessibleObject
  getThis() : java.lang.Object
  proceed() : java.lang.Object
}
org.springframework.security.access.intercept.aspectj.MethodInvocationAdapter::MethodInvocationAdapter -- org.aspectj.lang.ProceedingJoinPoint::getTarget : jp.getTarget() 
org.springframework.security.access.intercept.aspectj.MethodInvocationAdapter::MethodInvocationAdapter -- org.aspectj.lang.ProceedingJoinPoint::getTarget : jp.getTarget() 
org.springframework.security.access.intercept.aspectj.MethodInvocationAdapter::MethodInvocationAdapter -- org.aspectj.lang.ProceedingJoinPoint::getSignature : jp.getSignature().getDeclaringType() 
org.springframework.security.access.intercept.aspectj.MethodInvocationAdapter::MethodInvocationAdapter -- org.aspectj.lang.ProceedingJoinPoint::getSignature : jp.getSignature() 
org.springframework.security.access.intercept.aspectj.MethodInvocationAdapter::MethodInvocationAdapter -- org.aspectj.lang.ProceedingJoinPoint::getStaticPart : jp.getStaticPart().getSignature().getName() 
org.springframework.security.access.intercept.aspectj.MethodInvocationAdapter::MethodInvocationAdapter -- org.aspectj.lang.ProceedingJoinPoint::getStaticPart : jp.getStaticPart().getSignature() 
org.springframework.security.access.intercept.aspectj.MethodInvocationAdapter::MethodInvocationAdapter -- org.aspectj.lang.ProceedingJoinPoint::getStaticPart : jp.getStaticPart() 
org.springframework.security.access.intercept.aspectj.MethodInvocationAdapter::MethodInvocationAdapter -- org.aspectj.lang.ProceedingJoinPoint::getStaticPart : jp.getStaticPart().getSignature() 
org.springframework.security.access.intercept.aspectj.MethodInvocationAdapter::MethodInvocationAdapter -- org.aspectj.lang.ProceedingJoinPoint::getStaticPart : jp.getStaticPart() 
org.springframework.security.access.intercept.aspectj.MethodInvocationAdapter::MethodInvocationAdapter -- org.aspectj.lang.ProceedingJoinPoint::getStaticPart : jp.getStaticPart().getSignature().getDeclaringType() 
org.springframework.security.access.intercept.aspectj.MethodInvocationAdapter::MethodInvocationAdapter -- org.aspectj.lang.ProceedingJoinPoint::getStaticPart : jp.getStaticPart().getSignature() 
org.springframework.security.access.intercept.aspectj.MethodInvocationAdapter::MethodInvocationAdapter -- org.aspectj.lang.ProceedingJoinPoint::getStaticPart : jp.getStaticPart() 
org.springframework.security.access.intercept.aspectj.MethodInvocationAdapter::MethodInvocationAdapter -- org.springframework.util.Assert::notNull : Assert.notNull(this.method,()->"Could not obtain target method from JoinPoint: '"+jp+"'") 
org.springframework.security.access.intercept.aspectj.MethodInvocationAdapter::findMethod -- java.lang.Class::getMethod : declaringType.getMethod(name,params) 
org.springframework.security.access.intercept.aspectj.MethodInvocationAdapter::findMethod -- java.lang.Class::getDeclaredMethod : declaringType.getDeclaredMethod(name,params) 
org.springframework.security.access.intercept.aspectj.MethodInvocationAdapter::getArguments -- org.aspectj.lang.ProceedingJoinPoint::getArgs : this.jp.getArgs() 
org.springframework.security.access.intercept.aspectj.MethodInvocationAdapter::proceed -- org.aspectj.lang.ProceedingJoinPoint::proceed : this.jp.proceed() 
}
class AbstractSecurityInterceptor  implements org.springframework.security.access.intercept.InitializingBean,ApplicationEventPublisherAware,MessageSourceAware  {
  logger : org.apache.commons.logging.Log
  messages : org.springframework.context.support.MessageSourceAccessor
  securityContextHolderStrategy : org.springframework.security.core.context.SecurityContextHolderStrategy
  eventPublisher : org.springframework.context.ApplicationEventPublisher
  accessDecisionManager : org.springframework.security.access.AccessDecisionManager
  afterInvocationManager : org.springframework.security.access.intercept.AfterInvocationManager
  authenticationManager : org.springframework.security.authentication.AuthenticationManager
  runAsManager : org.springframework.security.access.intercept.RunAsManager
  alwaysReauthenticate : boolean
  rejectPublicInvocations : boolean
  validateConfigAttributes : boolean
  publishAuthorizationSuccess : boolean
  afterPropertiesSet() : void
  validateAttributeDefs(attributeDefs : java.util.Collection) : void
  beforeInvocation(object : java.lang.Object) : org.springframework.security.access.intercept.InterceptorStatusToken
  attemptAuthorization(object : java.lang.Object, attributes : java.util.Collection, authenticated : org.springframework.security.core.Authentication) : void
  finallyInvocation(token : org.springframework.security.access.intercept.InterceptorStatusToken) : void
  afterInvocation(token : org.springframework.security.access.intercept.InterceptorStatusToken, returnedObject : java.lang.Object) : java.lang.Object
  authenticateIfRequired() : org.springframework.security.core.Authentication
  credentialsNotFound(reason : java.lang.String, secureObject : java.lang.Object, configAttribs : java.util.Collection) : void
  getAccessDecisionManager() : org.springframework.security.access.AccessDecisionManager
  getAfterInvocationManager() : org.springframework.security.access.intercept.AfterInvocationManager
  getAuthenticationManager() : org.springframework.security.authentication.AuthenticationManager
  getRunAsManager() : org.springframework.security.access.intercept.RunAsManager
  getSecureObjectClass() : java.lang.Class
  isAlwaysReauthenticate() : boolean
  isRejectPublicInvocations() : boolean
  isValidateConfigAttributes() : boolean
  obtainSecurityMetadataSource() : org.springframework.security.access.SecurityMetadataSource
  setSecurityContextHolderStrategy(securityContextHolderStrategy : org.springframework.security.core.context.SecurityContextHolderStrategy) : void
  setAccessDecisionManager(accessDecisionManager : org.springframework.security.access.AccessDecisionManager) : void
  setAfterInvocationManager(afterInvocationManager : org.springframework.security.access.intercept.AfterInvocationManager) : void
  setAlwaysReauthenticate(alwaysReauthenticate : boolean) : void
  setApplicationEventPublisher(applicationEventPublisher : org.springframework.context.ApplicationEventPublisher) : void
  setAuthenticationManager(newManager : org.springframework.security.authentication.AuthenticationManager) : void
  setMessageSource(messageSource : org.springframework.context.MessageSource) : void
  setPublishAuthorizationSuccess(publishAuthorizationSuccess : boolean) : void
  setRejectPublicInvocations(rejectPublicInvocations : boolean) : void
  setRunAsManager(runAsManager : org.springframework.security.access.intercept.RunAsManager) : void
  setValidateConfigAttributes(validateConfigAttributes : boolean) : void
  publishEvent(event : org.springframework.context.ApplicationEvent) : void
}
org.springframework.security.access.intercept.AbstractSecurityInterceptor::afterPropertiesSet -- org.springframework.util.Assert::notNull : Assert.notNull(getSecureObjectClass(),"Subclass must provide a non-null response to getSecureObjectClass()") 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::afterPropertiesSet -- org.springframework.util.Assert::notNull : Assert.notNull(this.messages,"A message source must be set") 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::afterPropertiesSet -- org.springframework.util.Assert::notNull : Assert.notNull(this.authenticationManager,"An AuthenticationManager is required") 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::afterPropertiesSet -- org.springframework.util.Assert::notNull : Assert.notNull(this.accessDecisionManager,"An AccessDecisionManager is required") 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::afterPropertiesSet -- org.springframework.util.Assert::notNull : Assert.notNull(this.runAsManager,"A RunAsManager is required") 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::afterPropertiesSet -- org.springframework.util.Assert::notNull : Assert.notNull(this.obtainSecurityMetadataSource(),"An SecurityMetadataSource is required") 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::afterPropertiesSet -- org.springframework.util.Assert::isTrue : Assert.isTrue(this.obtainSecurityMetadataSource().supports(getSecureObjectClass()),()->"SecurityMetadataSource does not support secure object class: "+getSecureObjectClass()) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::afterPropertiesSet -- org.springframework.security.access.intercept.AbstractSecurityInterceptor::obtainSecurityMetadataSource : this.obtainSecurityMetadataSource().supports(getSecureObjectClass()) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::afterPropertiesSet -- org.springframework.util.Assert::isTrue : Assert.isTrue(this.runAsManager.supports(getSecureObjectClass()),()->"RunAsManager does not support secure object class: "+getSecureObjectClass()) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::afterPropertiesSet -- org.springframework.security.access.intercept.RunAsManager::supports : this.runAsManager.supports(getSecureObjectClass()) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::afterPropertiesSet -- org.springframework.util.Assert::isTrue : Assert.isTrue(this.accessDecisionManager.supports(getSecureObjectClass()),()->"AccessDecisionManager does not support secure object class: "+getSecureObjectClass()) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::afterPropertiesSet -- org.springframework.security.access.AccessDecisionManager::supports : this.accessDecisionManager.supports(getSecureObjectClass()) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::afterPropertiesSet -- org.springframework.util.Assert::isTrue : Assert.isTrue(this.afterInvocationManager.supports(getSecureObjectClass()),()->"AfterInvocationManager does not support secure object class: "+getSecureObjectClass()) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::afterPropertiesSet -- org.springframework.security.access.intercept.AfterInvocationManager::supports : this.afterInvocationManager.supports(getSecureObjectClass()) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::afterPropertiesSet -- org.springframework.security.access.intercept.AbstractSecurityInterceptor::obtainSecurityMetadataSource : this.obtainSecurityMetadataSource().getAllConfigAttributes() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::afterPropertiesSet -- org.apache.commons.logging.Log::warn : this.logger.warn("Could not validate configuration attributes as the "+"SecurityMetadataSource did not return any attributes from getAllConfigAttributes()") 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::validateAttributeDefs -- org.springframework.security.access.intercept.RunAsManager::supports : this.runAsManager.supports(attr) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::validateAttributeDefs -- org.springframework.security.access.AccessDecisionManager::supports : this.accessDecisionManager.supports(attr) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::validateAttributeDefs -- org.springframework.security.access.intercept.AfterInvocationManager::supports : this.afterInvocationManager.supports(attr) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::validateAttributeDefs -- org.apache.commons.logging.Log::trace : this.logger.trace("Did not validate configuration attributes since validateConfigurationAttributes is false") 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::validateAttributeDefs -- org.apache.commons.logging.Log::trace : this.logger.trace("Validated configuration attributes") 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- org.springframework.util.Assert::notNull : Assert.notNull(object,"Object was null") 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- org.springframework.security.access.intercept.AbstractSecurityInterceptor::getSecureObjectClass : getSecureObjectClass().isAssignableFrom(object.getClass()) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- java.lang.Object::getClass : object.getClass() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- java.lang.Object::getClass : object.getClass().getName() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- java.lang.Object::getClass : object.getClass() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- org.springframework.security.access.intercept.AbstractSecurityInterceptor::obtainSecurityMetadataSource : this.obtainSecurityMetadataSource().getAttributes(object) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- org.springframework.util.CollectionUtils::isEmpty : CollectionUtils.isEmpty(attributes) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- org.springframework.util.Assert::isTrue : Assert.isTrue(!this.rejectPublicInvocations,()->"Secure object invocation "+object+" was denied as public invocations are not allowed via this interceptor. "+"This indicates a configuration error because the "+"rejectPublicInvocations property is set to 'true'") 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- org.apache.commons.logging.Log::isDebugEnabled : this.logger.isDebugEnabled() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.format("Authorized public object %s",object)) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- org.springframework.core.log.LogMessage::format : LogMessage.format("Authorized public object %s",object) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : this.securityContextHolderStrategy.getContext().getAuthentication() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : this.securityContextHolderStrategy.getContext() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- org.springframework.context.support.MessageSourceAccessor::getMessage : this.messages.getMessage("AbstractSecurityInterceptor.authenticationNotFound","An Authentication object was not found in the SecurityContext") 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- org.apache.commons.logging.Log::isTraceEnabled : this.logger.isTraceEnabled() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- org.apache.commons.logging.Log::trace : this.logger.trace(LogMessage.format("Authorizing %s with attributes %s",object,attributes)) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- org.springframework.core.log.LogMessage::format : LogMessage.format("Authorizing %s with attributes %s",object,attributes) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- org.apache.commons.logging.Log::isDebugEnabled : this.logger.isDebugEnabled() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.format("Authorized %s with attributes %s",object,attributes)) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- org.springframework.core.log.LogMessage::format : LogMessage.format("Authorized %s with attributes %s",object,attributes) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- org.springframework.security.access.intercept.RunAsManager::buildRunAs : this.runAsManager.buildRunAs(authenticated,object,attributes) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : this.securityContextHolderStrategy.getContext() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- org.springframework.security.core.context.SecurityContextHolderStrategy::createEmptyContext : this.securityContextHolderStrategy.createEmptyContext() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- org.springframework.security.core.context.SecurityContextHolderStrategy::setContext : this.securityContextHolderStrategy.setContext(newCtx) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- org.apache.commons.logging.Log::isDebugEnabled : this.logger.isDebugEnabled() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.format("Switched to RunAs authentication %s",runAs)) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- org.springframework.core.log.LogMessage::format : LogMessage.format("Switched to RunAs authentication %s",runAs) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- org.apache.commons.logging.Log::trace : this.logger.trace("Did not switch RunAs authentication since RunAsManager returned null") 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::beforeInvocation -- org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : this.securityContextHolderStrategy.getContext() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::attemptAuthorization -- org.springframework.security.access.AccessDecisionManager::decide : this.accessDecisionManager.decide(authenticated,object,attributes) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::attemptAuthorization -- org.apache.commons.logging.Log::isTraceEnabled : this.logger.isTraceEnabled() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::attemptAuthorization -- org.apache.commons.logging.Log::trace : this.logger.trace(LogMessage.format("Failed to authorize %s with attributes %s using %s",object,attributes,this.accessDecisionManager)) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::attemptAuthorization -- org.springframework.core.log.LogMessage::format : LogMessage.format("Failed to authorize %s with attributes %s using %s",object,attributes,this.accessDecisionManager) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::attemptAuthorization -- org.apache.commons.logging.Log::isDebugEnabled : this.logger.isDebugEnabled() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::attemptAuthorization -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.format("Failed to authorize %s with attributes %s",object,attributes)) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::attemptAuthorization -- org.springframework.core.log.LogMessage::format : LogMessage.format("Failed to authorize %s with attributes %s",object,attributes) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::finallyInvocation -- org.springframework.security.access.intercept.InterceptorStatusToken::isContextHolderRefreshRequired : token.isContextHolderRefreshRequired() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::finallyInvocation -- org.springframework.security.core.context.SecurityContextHolderStrategy::setContext : this.securityContextHolderStrategy.setContext(token.getSecurityContext()) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::finallyInvocation -- org.springframework.security.access.intercept.InterceptorStatusToken::getSecurityContext : token.getSecurityContext() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::finallyInvocation -- org.apache.commons.logging.Log::isDebugEnabled : this.logger.isDebugEnabled() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::finallyInvocation -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.of(()->"Reverted to original authentication "+token.getSecurityContext().getAuthentication())) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::finallyInvocation -- org.springframework.core.log.LogMessage::of : LogMessage.of(()->"Reverted to original authentication "+token.getSecurityContext().getAuthentication()) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::finallyInvocation -- org.springframework.security.access.intercept.InterceptorStatusToken::getSecurityContext : token.getSecurityContext().getAuthentication() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::finallyInvocation -- org.springframework.security.access.intercept.InterceptorStatusToken::getSecurityContext : token.getSecurityContext() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::afterInvocation -- org.springframework.security.access.intercept.AfterInvocationManager::decide : this.afterInvocationManager.decide(token.getSecurityContext().getAuthentication(),token.getSecureObject(),token.getAttributes(),returnedObject) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::afterInvocation -- org.springframework.security.access.intercept.InterceptorStatusToken::getSecurityContext : token.getSecurityContext().getAuthentication() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::afterInvocation -- org.springframework.security.access.intercept.InterceptorStatusToken::getSecurityContext : token.getSecurityContext() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::afterInvocation -- org.springframework.security.access.intercept.InterceptorStatusToken::getSecureObject : token.getSecureObject() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::afterInvocation -- org.springframework.security.access.intercept.InterceptorStatusToken::getAttributes : token.getAttributes() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::afterInvocation -- org.springframework.security.access.intercept.InterceptorStatusToken::getSecureObject : token.getSecureObject() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::afterInvocation -- org.springframework.security.access.intercept.InterceptorStatusToken::getAttributes : token.getAttributes() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::afterInvocation -- org.springframework.security.access.intercept.InterceptorStatusToken::getSecurityContext : token.getSecurityContext().getAuthentication() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::afterInvocation -- org.springframework.security.access.intercept.InterceptorStatusToken::getSecurityContext : token.getSecurityContext() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::authenticateIfRequired -- org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : this.securityContextHolderStrategy.getContext().getAuthentication() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::authenticateIfRequired -- org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : this.securityContextHolderStrategy.getContext() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::authenticateIfRequired -- org.apache.commons.logging.Log::isTraceEnabled : this.logger.isTraceEnabled() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::authenticateIfRequired -- org.apache.commons.logging.Log::trace : this.logger.trace(LogMessage.format("Did not re-authenticate %s before authorizing",authentication)) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::authenticateIfRequired -- org.springframework.core.log.LogMessage::format : LogMessage.format("Did not re-authenticate %s before authorizing",authentication) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::authenticateIfRequired -- org.springframework.security.authentication.AuthenticationManager::authenticate : this.authenticationManager.authenticate(authentication) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::authenticateIfRequired -- org.apache.commons.logging.Log::isDebugEnabled : this.logger.isDebugEnabled() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::authenticateIfRequired -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.format("Re-authenticated %s before authorizing",authentication)) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::authenticateIfRequired -- org.springframework.core.log.LogMessage::format : LogMessage.format("Re-authenticated %s before authorizing",authentication) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::authenticateIfRequired -- org.springframework.security.core.context.SecurityContextHolderStrategy::createEmptyContext : this.securityContextHolderStrategy.createEmptyContext() 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::authenticateIfRequired -- org.springframework.security.core.context.SecurityContextHolderStrategy::setContext : this.securityContextHolderStrategy.setContext(context) 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::setSecurityContextHolderStrategy -- org.springframework.util.Assert::notNull : Assert.notNull(securityContextHolderStrategy,"securityContextHolderStrategy cannot be null") 
org.springframework.security.access.intercept.AbstractSecurityInterceptor::publishEvent -- org.springframework.context.ApplicationEventPublisher::publishEvent : this.eventPublisher.publishEvent(event) 
class NoOpAuthenticationManager  implements org.springframework.security.access.intercept.AuthenticationManager  {
  authenticate(authentication : org.springframework.security.access.intercept.Authentication) : org.springframework.security.access.intercept.Authentication
}
interface AfterInvocationManager    {
  decide(authentication : org.springframework.security.core.Authentication, object : java.lang.Object, attributes : java.util.Collection, returnedObject : java.lang.Object) : java.lang.Object
  supports(attribute : org.springframework.security.access.ConfigAttribute) : boolean
  supports(clazz : java.lang.Class) : boolean
}
class AfterInvocationProviderManager  implements org.springframework.security.access.intercept.AfterInvocationManager,InitializingBean  {
  logger : org.apache.commons.logging.Log
  providers : java.util.List
  afterPropertiesSet() : void
  decide(authentication : org.springframework.security.core.Authentication, object : java.lang.Object, config : java.util.Collection, returnedObject : java.lang.Object) : java.lang.Object
  getProviders() : java.util.List
  setProviders(newList : java.util.List) : void
  checkIfValidList(listToCheck : java.util.List) : void
  supports(attribute : org.springframework.security.access.ConfigAttribute) : boolean
  supports(clazz : java.lang.Class) : boolean
}
org.springframework.security.access.intercept.AfterInvocationProviderManager::setProviders -- java.util.List::size : newList.size() 
org.springframework.security.access.intercept.AfterInvocationProviderManager::setProviders -- org.springframework.util.Assert::isInstanceOf : Assert.isInstanceOf(AfterInvocationProvider.class,currentObject,()->"AfterInvocationProvider "+currentObject.getClass().getName()+" must implement AfterInvocationProvider") 
org.springframework.security.access.intercept.AfterInvocationProviderManager::setProviders -- java.util.List::add : this.providers.add((AfterInvocationProvider)currentObject) 
org.springframework.security.access.intercept.AfterInvocationProviderManager::checkIfValidList -- org.springframework.util.Assert::isTrue : Assert.isTrue(!CollectionUtils.isEmpty(listToCheck),"A list of AfterInvocationProviders is required") 
org.springframework.security.access.intercept.AfterInvocationProviderManager::checkIfValidList -- org.springframework.util.CollectionUtils::isEmpty : CollectionUtils.isEmpty(listToCheck) 
org.springframework.security.access.intercept.AfterInvocationProviderManager::supports -- org.apache.commons.logging.Log::debug : logger.debug(LogMessage.format("Evaluating %s against %s",attribute,provider)) 
org.springframework.security.access.intercept.AfterInvocationProviderManager::supports -- org.springframework.core.log.LogMessage::format : LogMessage.format("Evaluating %s against %s",attribute,provider) 
class InterceptorStatusToken    {
  securityContext : org.springframework.security.core.context.SecurityContext
  attr : java.util.Collection
  secureObject : java.lang.Object
  contextHolderRefreshRequired : boolean
  InterceptorStatusToken(securityContext : org.springframework.security.core.context.SecurityContext, contextHolderRefreshRequired : boolean, attributes : java.util.Collection, secureObject : java.lang.Object) : None
  getAttributes() : java.util.Collection
  getSecurityContext() : org.springframework.security.core.context.SecurityContext
  getSecureObject() : java.lang.Object
  isContextHolderRefreshRequired() : boolean
}
class MethodInvocationPrivilegeEvaluator  implements org.springframework.beans.factory.InitializingBean  {
  logger : org.apache.commons.logging.Log
  securityInterceptor : org.springframework.security.access.intercept.AbstractSecurityInterceptor
  afterPropertiesSet() : void
  isAllowed(invocation : org.aopalliance.intercept.MethodInvocation, authentication : org.springframework.security.core.Authentication) : boolean
  setSecurityInterceptor(securityInterceptor : org.springframework.security.access.intercept.AbstractSecurityInterceptor) : void
}
org.springframework.security.access.intercept.MethodInvocationPrivilegeEvaluator::afterPropertiesSet -- org.springframework.util.Assert::notNull : Assert.notNull(this.securityInterceptor,"SecurityInterceptor required") 
org.springframework.security.access.intercept.MethodInvocationPrivilegeEvaluator::isAllowed -- org.springframework.util.Assert::notNull : Assert.notNull(invocation,"MethodInvocation required") 
org.springframework.security.access.intercept.MethodInvocationPrivilegeEvaluator::isAllowed -- org.springframework.util.Assert::notNull : Assert.notNull(invocation.getMethod(),"MethodInvocation must provide a non-null getMethod()") 
org.springframework.security.access.intercept.MethodInvocationPrivilegeEvaluator::isAllowed -- org.aopalliance.intercept.MethodInvocation::getMethod : invocation.getMethod() 
org.springframework.security.access.intercept.MethodInvocationPrivilegeEvaluator::isAllowed -- org.springframework.security.access.intercept.AbstractSecurityInterceptor::obtainSecurityMetadataSource : this.securityInterceptor.obtainSecurityMetadataSource().getAttributes(invocation) 
org.springframework.security.access.intercept.MethodInvocationPrivilegeEvaluator::isAllowed -- org.springframework.security.access.intercept.AbstractSecurityInterceptor::obtainSecurityMetadataSource : this.securityInterceptor.obtainSecurityMetadataSource() 
org.springframework.security.access.intercept.MethodInvocationPrivilegeEvaluator::isAllowed -- org.springframework.security.access.intercept.AbstractSecurityInterceptor::isRejectPublicInvocations : this.securityInterceptor.isRejectPublicInvocations() 
org.springframework.security.access.intercept.MethodInvocationPrivilegeEvaluator::isAllowed -- org.springframework.security.core.Authentication::getAuthorities : authentication.getAuthorities().isEmpty() 
org.springframework.security.access.intercept.MethodInvocationPrivilegeEvaluator::isAllowed -- org.springframework.security.core.Authentication::getAuthorities : authentication.getAuthorities() 
org.springframework.security.access.intercept.MethodInvocationPrivilegeEvaluator::isAllowed -- org.springframework.security.access.intercept.AbstractSecurityInterceptor::getAccessDecisionManager : this.securityInterceptor.getAccessDecisionManager().decide(authentication,invocation,attrs) 
org.springframework.security.access.intercept.MethodInvocationPrivilegeEvaluator::isAllowed -- org.springframework.security.access.intercept.AbstractSecurityInterceptor::getAccessDecisionManager : this.securityInterceptor.getAccessDecisionManager() 
org.springframework.security.access.intercept.MethodInvocationPrivilegeEvaluator::isAllowed -- org.apache.commons.logging.Log::debug : logger.debug(LogMessage.format("%s denied for %s",invocation,authentication),unauthorized) 
org.springframework.security.access.intercept.MethodInvocationPrivilegeEvaluator::isAllowed -- org.springframework.core.log.LogMessage::format : LogMessage.format("%s denied for %s",invocation,authentication) 
org.springframework.security.access.intercept.MethodInvocationPrivilegeEvaluator::setSecurityInterceptor -- org.springframework.util.Assert::notNull : Assert.notNull(securityInterceptor,"AbstractSecurityInterceptor cannot be null") 
org.springframework.security.access.intercept.MethodInvocationPrivilegeEvaluator::setSecurityInterceptor -- org.springframework.util.Assert::isTrue : Assert.isTrue(MethodInvocation.class.equals(securityInterceptor.getSecureObjectClass()),"AbstractSecurityInterceptor does not support MethodInvocations") 
org.springframework.security.access.intercept.MethodInvocationPrivilegeEvaluator::setSecurityInterceptor -- org.springframework.security.access.intercept.AbstractSecurityInterceptor::getSecureObjectClass : securityInterceptor.getSecureObjectClass() 
org.springframework.security.access.intercept.MethodInvocationPrivilegeEvaluator::setSecurityInterceptor -- org.springframework.util.Assert::notNull : Assert.notNull(securityInterceptor.getAccessDecisionManager(),"AbstractSecurityInterceptor must provide a non-null AccessDecisionManager") 
org.springframework.security.access.intercept.MethodInvocationPrivilegeEvaluator::setSecurityInterceptor -- org.springframework.security.access.intercept.AbstractSecurityInterceptor::getAccessDecisionManager : securityInterceptor.getAccessDecisionManager() 
class NullRunAsManager  implements org.springframework.security.access.intercept.RunAsManager  {
  buildRunAs(authentication : org.springframework.security.core.Authentication, object : java.lang.Object, config : java.util.Collection) : org.springframework.security.core.Authentication
  supports(attribute : org.springframework.security.access.ConfigAttribute) : boolean
  supports(clazz : java.lang.Class) : boolean
}
class RunAsImplAuthenticationProvider  implements org.springframework.security.access.intercept.InitializingBean,AuthenticationProvider,MessageSourceAware  {
  messages : org.springframework.context.support.MessageSourceAccessor
  key : java.lang.String
  afterPropertiesSet() : void
  authenticate(authentication : org.springframework.security.core.Authentication) : org.springframework.security.core.Authentication
  getKey() : java.lang.String
  setKey(key : java.lang.String) : void
  setMessageSource(messageSource : org.springframework.context.MessageSource) : void
  supports(authentication : java.lang.Class) : boolean
}
org.springframework.security.access.intercept.RunAsImplAuthenticationProvider::afterPropertiesSet -- org.springframework.util.Assert::notNull : Assert.notNull(this.key,"A Key is required and should match that configured for the RunAsManagerImpl") 
org.springframework.security.access.intercept.RunAsImplAuthenticationProvider::authenticate -- java.lang.String::hashCode : this.key.hashCode() 
org.springframework.security.access.intercept.RunAsImplAuthenticationProvider::authenticate -- org.springframework.context.support.MessageSourceAccessor::getMessage : this.messages.getMessage("RunAsImplAuthenticationProvider.incorrectKey","The presented RunAsUserToken does not contain the expected key") 
interface RunAsManager    {
  buildRunAs(authentication : org.springframework.security.core.Authentication, object : java.lang.Object, attributes : java.util.Collection) : org.springframework.security.core.Authentication
  supports(attribute : org.springframework.security.access.ConfigAttribute) : boolean
  supports(clazz : java.lang.Class) : boolean
}
class RunAsManagerImpl  implements org.springframework.security.access.intercept.RunAsManager,InitializingBean  {
  key : java.lang.String
  rolePrefix : java.lang.String
  afterPropertiesSet() : void
  buildRunAs(authentication : org.springframework.security.core.Authentication, object : java.lang.Object, attributes : java.util.Collection) : org.springframework.security.core.Authentication
  getKey() : java.lang.String
  getRolePrefix() : java.lang.String
  setKey(key : java.lang.String) : void
  setRolePrefix(rolePrefix : java.lang.String) : void
  supports(attribute : org.springframework.security.access.ConfigAttribute) : boolean
  supports(clazz : java.lang.Class) : boolean
}
org.springframework.security.access.intercept.RunAsManagerImpl::afterPropertiesSet -- org.springframework.util.Assert::notNull : Assert.notNull(this.key,"A Key is required and should match that configured for the RunAsImplAuthenticationProvider") 
org.springframework.security.access.intercept.RunAsManagerImpl::buildRunAs -- org.springframework.security.core.Authentication::getAuthorities : authentication.getAuthorities() 
org.springframework.security.access.intercept.RunAsManagerImpl::buildRunAs -- org.springframework.security.core.Authentication::getPrincipal : authentication.getPrincipal() 
org.springframework.security.access.intercept.RunAsManagerImpl::buildRunAs -- org.springframework.security.core.Authentication::getCredentials : authentication.getCredentials() 
org.springframework.security.access.intercept.RunAsManagerImpl::buildRunAs -- org.springframework.security.core.Authentication::getClass : authentication.getClass() 
org.springframework.security.access.intercept.RunAsManagerImpl::supports -- org.springframework.security.access.ConfigAttribute::getAttribute : attribute.getAttribute() 
org.springframework.security.access.intercept.RunAsManagerImpl::supports -- org.springframework.security.access.ConfigAttribute::getAttribute : attribute.getAttribute().startsWith("RUN_AS_") 
org.springframework.security.access.intercept.RunAsManagerImpl::supports -- org.springframework.security.access.ConfigAttribute::getAttribute : attribute.getAttribute() 
class RunAsUserToken extends org.springframework.security.authentication.AbstractAuthenticationToken   {
  serialVersionUID : long
  originalAuthentication : java.lang.Class
  credentials : java.lang.Object
  principal : java.lang.Object
  keyHash : int
  RunAsUserToken(key : java.lang.String, principal : java.lang.Object, credentials : java.lang.Object, authorities : java.util.Collection, originalAuthentication : java.lang.Class) : None
  getCredentials() : java.lang.Object
  getKeyHash() : int
  getOriginalAuthentication() : java.lang.Class
  getPrincipal() : java.lang.Object
  toString() : java.lang.String
}
org.springframework.security.access.intercept.RunAsUserToken::RunAsUserToken -- java.lang.String::hashCode : key.hashCode() 
org.springframework.security.access.intercept.RunAsUserToken::toString -- java.lang.Class::getName : this.originalAuthentication.getName() 
}
package method {
class AbstractFallbackMethodSecurityMetadataSource extends org.springframework.security.access.method.AbstractMethodSecurityMetadataSource   {
  getAttributes(method : java.lang.reflect.Method, targetClass : java.lang.Class) : java.util.Collection
  findAttributes(method : java.lang.reflect.Method, targetClass : java.lang.Class) : java.util.Collection
  findAttributes(clazz : java.lang.Class) : java.util.Collection
}
org.springframework.security.access.method.AbstractFallbackMethodSecurityMetadataSource::getAttributes -- org.springframework.aop.support.AopUtils::getMostSpecificMethod : AopUtils.getMostSpecificMethod(method,targetClass) 
org.springframework.security.access.method.AbstractFallbackMethodSecurityMetadataSource::getAttributes -- java.lang.reflect.Method::getDeclaringClass : method.getDeclaringClass() 
org.springframework.security.access.method.AbstractFallbackMethodSecurityMetadataSource::getAttributes -- java.lang.reflect.Method::getDeclaringClass : method.getDeclaringClass() 
org.springframework.security.access.method.AbstractFallbackMethodSecurityMetadataSource::getAttributes -- java.util.Collections::emptyList : Collections.emptyList() 
class AbstractMethodSecurityMetadataSource  implements org.springframework.security.access.method.MethodSecurityMetadataSource  {
  logger : org.apache.commons.logging.Log
  getAttributes(object : java.lang.Object) : java.util.Collection
  supports(clazz : java.lang.Class) : boolean
}
org.springframework.security.access.method.AbstractMethodSecurityMetadataSource::getAttributes -- org.springframework.aop.framework.AopProxyUtils::ultimateTargetClass : AopProxyUtils.ultimateTargetClass(target) 
class DelegatingMethodSecurityMetadataSource extends org.springframework.security.access.method.AbstractMethodSecurityMetadataSource   {
  NULL_CONFIG_ATTRIBUTE : java.util.List
  methodSecurityMetadataSources : java.util.List
  attributeCache : java.util.Map
  DelegatingMethodSecurityMetadataSource(methodSecurityMetadataSources : java.util.List) : None
  getAttributes(method : java.lang.reflect.Method, targetClass : java.lang.Class) : java.util.Collection
  getAllConfigAttributes() : java.util.Collection
  getMethodSecurityMetadataSources() : java.util.List
}
org.springframework.security.access.method.DelegatingMethodSecurityMetadataSource::DelegatingMethodSecurityMetadataSource -- org.springframework.util.Assert::notNull : Assert.notNull(methodSecurityMetadataSources,"MethodSecurityMetadataSources cannot be null") 
org.springframework.security.access.method.DelegatingMethodSecurityMetadataSource::getAttributes -- java.util.Map::get : this.attributeCache.get(cacheKey) 
org.springframework.security.access.method.DelegatingMethodSecurityMetadataSource::getAttributes -- java.util.Map::put : this.attributeCache.put(cacheKey,NULL_CONFIG_ATTRIBUTE) 
org.springframework.security.access.method.DelegatingMethodSecurityMetadataSource::getAttributes -- org.springframework.core.log.LogMessage::format : LogMessage.format("Caching method [%s] with attributes %s",cacheKey,attributes) 
org.springframework.security.access.method.DelegatingMethodSecurityMetadataSource::getAttributes -- java.util.Map::put : this.attributeCache.put(cacheKey,attributes) 
class DefaultCacheKey    {
  method : org.springframework.security.access.method.Method
  targetClass : java.lang.Class
  DefaultCacheKey(method : org.springframework.security.access.method.Method, targetClass : java.lang.Class) : None
  equals(other : java.lang.Object) : boolean
  hashCode() : int
  toString() : java.lang.String
}
org.springframework.security.access.method.DefaultCacheKey::equals -- org.springframework.security.access.method.Method::equals : this.method.equals(otherKey.method) 
org.springframework.security.access.method.DefaultCacheKey::equals -- org.springframework.security.access.method.ObjectUtils::nullSafeEquals : ObjectUtils.nullSafeEquals(this.targetClass,otherKey.targetClass) 
org.springframework.security.access.method.DefaultCacheKey::hashCode -- org.springframework.security.access.method.Method::hashCode : this.method.hashCode() 
org.springframework.security.access.method.DefaultCacheKey::hashCode -- java.lang.Class::hashCode : this.targetClass.hashCode() 
org.springframework.security.access.method.DefaultCacheKey::toString -- java.lang.Class::getName : this.targetClass.getName() 
class MapBasedMethodSecurityMetadataSource extends org.springframework.security.access.method.AbstractFallbackMethodSecurityMetadataSource implements org.springframework.beans.factory.BeanClassLoaderAware  {
  beanClassLoader : org.springframework.security.access.method.ClassLoader
  methodMap : java.util.Map
  nameMap : java.util.Map
  MapBasedMethodSecurityMetadataSource() : None
  MapBasedMethodSecurityMetadataSource(methodMap : java.util.Map) : None
  findAttributes(clazz : java.lang.Class) : java.util.Collection
  findAttributes(method : java.lang.reflect.Method, targetClass : java.lang.Class) : java.util.Collection
  findAttributesSpecifiedAgainst(method : java.lang.reflect.Method, clazz : java.lang.Class) : java.util.List
  addSecureMethod(name : java.lang.String, attr : java.util.List) : void
  addSecureMethod(javaType : java.lang.Class, mappedName : java.lang.String, attr : java.util.List) : void
  registerAllMatchingMethods(javaType : java.lang.Class, attr : java.util.List, name : java.lang.String, matchingMethods : java.util.List) : void
  addSecureMethod(javaType : java.lang.Class, method : java.lang.reflect.Method, attr : java.util.List) : void
  addSecureMethod(method : org.springframework.security.access.method.RegisteredMethod, attr : java.util.List) : void
  getAllConfigAttributes() : java.util.Collection
  isMatch(methodName : java.lang.String, mappedName : java.lang.String) : boolean
  setBeanClassLoader(beanClassLoader : org.springframework.security.access.method.ClassLoader) : void
  getMethodMapSize() : int
}
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::MapBasedMethodSecurityMetadataSource -- java.util.Map::entrySet : methodMap.entrySet() 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::findAttributesSpecifiedAgainst -- java.util.Map::containsKey : this.methodMap.containsKey(registeredMethod) 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::findAttributesSpecifiedAgainst -- java.util.Map::get : this.methodMap.get(registeredMethod) 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::findAttributesSpecifiedAgainst -- java.lang.Class::getSuperclass : clazz.getSuperclass() 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::findAttributesSpecifiedAgainst -- java.lang.Class::getSuperclass : clazz.getSuperclass() 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::addSecureMethod -- java.lang.String::lastIndexOf : name.lastIndexOf(".") 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::addSecureMethod -- org.springframework.util.Assert::isTrue : Assert.isTrue(lastDotIndex!=-1,()->"'"+name+"' is not a valid method name: format is FQN.methodName") 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::addSecureMethod -- java.lang.String::substring : name.substring(lastDotIndex+1) 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::addSecureMethod -- org.springframework.util.Assert::hasText : Assert.hasText(methodName,()->"Method not found for '"+name+"'") 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::addSecureMethod -- java.lang.String::substring : name.substring(0,lastDotIndex) 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::addSecureMethod -- org.springframework.util.ClassUtils::resolveClassName : ClassUtils.resolveClassName(typeName,this.beanClassLoader) 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::addSecureMethod -- java.lang.Class::getName : javaType.getName() 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::addSecureMethod -- org.springframework.core.log.LogMessage::format : LogMessage.format("Request to add secure method [%s] with attributes [%s]",name,attr) 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::addSecureMethod -- java.lang.Class::getMethods : javaType.getMethods() 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::addSecureMethod -- org.springframework.util.Assert::notEmpty : Assert.notEmpty(matchingMethods,()->"Couldn't find method '"+mappedName+"' on '"+javaType+"'") 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::registerAllMatchingMethods -- java.util.Map::get : this.nameMap.get(registeredMethod) 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::registerAllMatchingMethods -- java.lang.String::length : name.length() 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::registerAllMatchingMethods -- org.springframework.core.log.LogMessage::format : LogMessage.format("Replacing attributes for secure method [%s]: current name [%s] is more specific than [%s]",method,name,regMethodName) 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::registerAllMatchingMethods -- java.util.Map::put : this.nameMap.put(registeredMethod,name) 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::registerAllMatchingMethods -- org.springframework.core.log.LogMessage::format : LogMessage.format("Keeping attributes for secure method [%s]: current name [%s] is not more specific than [%s]",method,name,regMethodName) 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::addSecureMethod -- java.util.Map::containsKey : this.methodMap.containsKey(key) 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::addSecureMethod -- org.springframework.core.log.LogMessage::format : LogMessage.format("Method [%s] is already registered with attributes [%s]",method,this.methodMap.get(key)) 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::addSecureMethod -- java.util.Map::get : this.methodMap.get(key) 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::addSecureMethod -- java.util.Map::put : this.methodMap.put(key,attr) 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::addSecureMethod -- org.springframework.util.Assert::notNull : Assert.notNull(method,"RegisteredMethod required") 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::addSecureMethod -- org.springframework.util.Assert::notNull : Assert.notNull(attr,"Configuration attribute required") 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::addSecureMethod -- org.springframework.core.log.LogMessage::format : LogMessage.format("Adding secure method [%s] with attributes [%s]",method,attr) 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::addSecureMethod -- java.util.Map::put : this.methodMap.put(method,attr) 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::getAllConfigAttributes -- java.util.Map::values : this.methodMap.values().forEach(allAttributes::addAll) 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::getAllConfigAttributes -- java.util.Map::values : this.methodMap.values() 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::isMatch -- java.lang.String::endsWith : mappedName.endsWith("*") 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::isMatch -- java.lang.String::startsWith : methodName.startsWith(mappedName.substring(0,mappedName.length()-1)) 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::isMatch -- java.lang.String::substring : mappedName.substring(0,mappedName.length()-1) 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::isMatch -- java.lang.String::length : mappedName.length() 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::isMatch -- java.lang.String::startsWith : mappedName.startsWith("*") 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::isMatch -- java.lang.String::endsWith : methodName.endsWith(mappedName.substring(1,mappedName.length())) 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::isMatch -- java.lang.String::substring : mappedName.substring(1,mappedName.length()) 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::isMatch -- java.lang.String::length : mappedName.length() 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::setBeanClassLoader -- org.springframework.util.Assert::notNull : Assert.notNull(beanClassLoader,"Bean class loader required") 
org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource::getMethodMapSize -- java.util.Map::size : this.methodMap.size() 
class RegisteredMethod    {
  method : org.springframework.security.access.method.Method
  registeredJavaType : java.lang.Class
  RegisteredMethod(method : org.springframework.security.access.method.Method, registeredJavaType : java.lang.Class) : None
  equals(obj : java.lang.Object) : boolean
  hashCode() : int
  toString() : java.lang.String
}
org.springframework.security.access.method.RegisteredMethod::RegisteredMethod -- org.springframework.security.access.method.Assert::notNull : Assert.notNull(method,"Method required") 
org.springframework.security.access.method.RegisteredMethod::RegisteredMethod -- org.springframework.security.access.method.Assert::notNull : Assert.notNull(registeredJavaType,"Registered Java Type required") 
org.springframework.security.access.method.RegisteredMethod::equals -- org.springframework.security.access.method.Method::equals : this.method.equals(rhs.method) 
org.springframework.security.access.method.RegisteredMethod::equals -- java.lang.Class::equals : this.registeredJavaType.equals(rhs.registeredJavaType) 
org.springframework.security.access.method.RegisteredMethod::hashCode -- org.springframework.security.access.method.Method::hashCode : this.method.hashCode() 
org.springframework.security.access.method.RegisteredMethod::hashCode -- java.lang.Class::hashCode : this.registeredJavaType.hashCode() 
org.springframework.security.access.method.RegisteredMethod::toString -- java.lang.Class::getName : this.registeredJavaType.getName() 
interface MethodSecurityMetadataSource    {
  getAttributes(method : java.lang.reflect.Method, targetClass : java.lang.Class) : java.util.Collection
}
}
package prepost {
class PostInvocationAdviceProvider  implements org.springframework.security.access.AfterInvocationProvider  {
  logger : org.apache.commons.logging.Log
  postAdvice : org.springframework.security.access.prepost.PostInvocationAuthorizationAdvice
  PostInvocationAdviceProvider(postAdvice : org.springframework.security.access.prepost.PostInvocationAuthorizationAdvice) : None
  decide(authentication : org.springframework.security.core.Authentication, object : java.lang.Object, config : java.util.Collection, returnedObject : java.lang.Object) : java.lang.Object
  findPostInvocationAttribute(config : java.util.Collection) : org.springframework.security.access.prepost.PostInvocationAttribute
  supports(attribute : org.springframework.security.access.ConfigAttribute) : boolean
  supports(clazz : java.lang.Class) : boolean
}
org.springframework.security.access.prepost.PostInvocationAdviceProvider::decide -- org.springframework.security.access.prepost.PostInvocationAuthorizationAdvice::after : this.postAdvice.after(authentication,(MethodInvocation)object,postInvocationAttribute,returnedObject) 
interface PostInvocationAttribute    {
}
interface PostInvocationAuthorizationAdvice    {
  after(authentication : org.springframework.security.core.Authentication, mi : org.aopalliance.intercept.MethodInvocation, pia : org.springframework.security.access.prepost.PostInvocationAttribute, returnedObject : java.lang.Object) : java.lang.Object
}
interface PreInvocationAttribute    {
}
interface PreInvocationAuthorizationAdvice    {
  before(authentication : org.springframework.security.core.Authentication, mi : org.aopalliance.intercept.MethodInvocation, preInvocationAttribute : org.springframework.security.access.prepost.PreInvocationAttribute) : boolean
}
class PreInvocationAuthorizationAdviceVoter  implements org.springframework.security.access.AccessDecisionVoter  {
  logger : org.apache.commons.logging.Log
  preAdvice : org.springframework.security.access.prepost.PreInvocationAuthorizationAdvice
  PreInvocationAuthorizationAdviceVoter(pre : org.springframework.security.access.prepost.PreInvocationAuthorizationAdvice) : None
  supports(attribute : org.springframework.security.access.ConfigAttribute) : boolean
  supports(clazz : java.lang.Class) : boolean
  vote(authentication : org.springframework.security.core.Authentication, method : org.aopalliance.intercept.MethodInvocation, attributes : java.util.Collection) : int
  findPreInvocationAttribute(config : java.util.Collection) : org.springframework.security.access.prepost.PreInvocationAttribute
}
org.springframework.security.access.prepost.PreInvocationAuthorizationAdviceVoter::vote -- org.springframework.security.access.prepost.PreInvocationAuthorizationAdvice::before : this.preAdvice.before(authentication,method,preAttr) 
class PrePostAdviceReactiveMethodInterceptor  implements org.aopalliance.intercept.MethodInterceptor  {
  anonymous : org.springframework.security.core.Authentication
  attributeSource : org.springframework.security.access.method.MethodSecurityMetadataSource
  preInvocationAdvice : org.springframework.security.access.prepost.PreInvocationAuthorizationAdvice
  postAdvice : org.springframework.security.access.prepost.PostInvocationAuthorizationAdvice
  COROUTINES_FLOW_CLASS_NAME : java.lang.String
  RETURN_TYPE_METHOD_PARAMETER_INDEX : int
  PrePostAdviceReactiveMethodInterceptor(attributeSource : org.springframework.security.access.method.MethodSecurityMetadataSource, preInvocationAdvice : org.springframework.security.access.prepost.PreInvocationAuthorizationAdvice, postInvocationAdvice : org.springframework.security.access.prepost.PostInvocationAuthorizationAdvice) : None
  invoke(invocation : org.aopalliance.intercept.MethodInvocation) : java.lang.Object
  proceed(invocation : org.aopalliance.intercept.MethodInvocation) : org.springframework.security.access.prepost.T
  flowProceed(invocation : org.aopalliance.intercept.MethodInvocation) : java.lang.Object
  findPostInvocationAttribute(config : java.util.Collection) : org.springframework.security.access.prepost.PostInvocationAttribute
  findPreInvocationAttribute(config : java.util.Collection) : org.springframework.security.access.prepost.PreInvocationAttribute
}
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::PrePostAdviceReactiveMethodInterceptor -- org.springframework.util.Assert::notNull : Assert.notNull(attributeSource,"attributeSource cannot be null") 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::PrePostAdviceReactiveMethodInterceptor -- org.springframework.util.Assert::notNull : Assert.notNull(preInvocationAdvice,"preInvocationAdvice cannot be null") 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::PrePostAdviceReactiveMethodInterceptor -- org.springframework.util.Assert::notNull : Assert.notNull(postInvocationAdvice,"postInvocationAdvice cannot be null") 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.aopalliance.intercept.MethodInvocation::getMethod : invocation.getMethod() 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.core.KotlinDetector::isSuspendingFunction : KotlinDetector.isSuspendingFunction(method) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.security.access.prepost.COROUTINES_FLOW_CLASS_NAME::equals : COROUTINES_FLOW_CLASS_NAME.equals(newMethodParameter(method,RETURN_TYPE_METHOD_PARAMETER_INDEX).getParameterType().getName()) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::newMethodParameter : newMethodParameter(method,RETURN_TYPE_METHOD_PARAMETER_INDEX).getParameterType().getName() 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::newMethodParameter : newMethodParameter(method,RETURN_TYPE_METHOD_PARAMETER_INDEX).getParameterType() 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.util.Assert::state : Assert.state(hasReactiveReturnType,()->"The returnType "+returnType+" on "+method+" must return an instance of org.reactivestreams.Publisher "+"(i.e. Mono / Flux) or the function must be a Kotlin coroutine "+"function in order to support Reactor Context") 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.aopalliance.intercept.MethodInvocation::getThis : invocation.getThis().getClass() 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.aopalliance.intercept.MethodInvocation::getThis : invocation.getThis() 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.security.access.method.MethodSecurityMetadataSource::getAttributes : this.attributeSource.getAttributes(method,targetClass) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.security.core.context.ReactiveSecurityContextHolder::getContext : ReactiveSecurityContextHolder.getContext().map(SecurityContext::getAuthentication).defaultIfEmpty(this.anonymous).filter((auth)->this.preInvocationAdvice.before(auth,invocation,preAttr)).switchIfEmpty(Mono.defer(()->Mono.error(newAccessDeniedException("Denied")))) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.security.core.context.ReactiveSecurityContextHolder::getContext : ReactiveSecurityContextHolder.getContext().map(SecurityContext::getAuthentication).defaultIfEmpty(this.anonymous).filter((auth)->this.preInvocationAdvice.before(auth,invocation,preAttr)) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.security.core.context.ReactiveSecurityContextHolder::getContext : ReactiveSecurityContextHolder.getContext().map(SecurityContext::getAuthentication).defaultIfEmpty(this.anonymous) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.security.core.context.ReactiveSecurityContextHolder::getContext : ReactiveSecurityContextHolder.getContext().map(SecurityContext::getAuthentication) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.security.core.context.ReactiveSecurityContextHolder::getContext : ReactiveSecurityContextHolder.getContext() 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.security.access.prepost.PreInvocationAuthorizationAdvice::before : this.preInvocationAdvice.before(auth,invocation,preAttr) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- reactor.core.publisher.Mono::defer : Mono.defer(()->Mono.error(newAccessDeniedException("Denied"))) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- reactor.core.publisher.Mono::error : Mono.error(newAccessDeniedException("Denied")) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::<Mono<?>>proceed : PrePostAdviceReactiveMethodInterceptor.<Mono<?>>proceed(invocation).map((r)->(attr!=null)?this.postAdvice.after(auth,invocation,attr,r):r) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::<Mono<?>>proceed : PrePostAdviceReactiveMethodInterceptor.<Mono<?>>proceed(invocation) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.security.access.prepost.PostInvocationAuthorizationAdvice::after : this.postAdvice.after(auth,invocation,attr,r) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::<Flux<?>>proceed : PrePostAdviceReactiveMethodInterceptor.<Flux<?>>proceed(invocation).map((r)->(attr!=null)?this.postAdvice.after(auth,invocation,attr,r):r) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::<Flux<?>>proceed : PrePostAdviceReactiveMethodInterceptor.<Flux<?>>proceed(invocation) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.security.access.prepost.PostInvocationAuthorizationAdvice::after : this.postAdvice.after(auth,invocation,attr,r) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- reactor.core.publisher.Flux::from : Flux.from(PrePostAdviceReactiveMethodInterceptor.proceed(invocation)).map((r)->(attr!=null)?this.postAdvice.after(auth,invocation,attr,r):r) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- reactor.core.publisher.Flux::from : Flux.from(PrePostAdviceReactiveMethodInterceptor.proceed(invocation)) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::proceed : PrePostAdviceReactiveMethodInterceptor.proceed(invocation) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.security.access.prepost.PostInvocationAuthorizationAdvice::after : this.postAdvice.after(auth,invocation,attr,r) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.core.ReactiveAdapterRegistry::getSharedInstance : ReactiveAdapterRegistry.getSharedInstance().getAdapter(returnType) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.core.ReactiveAdapterRegistry::getSharedInstance : ReactiveAdapterRegistry.getSharedInstance() 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.util.Assert::state : Assert.state(adapter!=null,()->"The returnType "+returnType+" on "+method+" must have a org.springframework.core.ReactiveAdapter registered") 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- reactor.core.publisher.Flux::from : Flux.from(adapter.toPublisher(PrePostAdviceReactiveMethodInterceptor.flowProceed(invocation))).map((r)->(attr!=null)?this.postAdvice.after(auth,invocation,attr,r):r) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- reactor.core.publisher.Flux::from : Flux.from(adapter.toPublisher(PrePostAdviceReactiveMethodInterceptor.flowProceed(invocation))) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::flowProceed : PrePostAdviceReactiveMethodInterceptor.flowProceed(invocation) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.security.access.prepost.PostInvocationAuthorizationAdvice::after : this.postAdvice.after(auth,invocation,attr,r) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.security.access.prepost.KotlinDelegate::asFlow : KotlinDelegate.asFlow(response) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- reactor.core.publisher.Mono::from : Mono.from(PrePostAdviceReactiveMethodInterceptor.proceed(invocation)).map((r)->(attr!=null)?this.postAdvice.after(auth,invocation,attr,r):r) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- reactor.core.publisher.Mono::from : Mono.from(PrePostAdviceReactiveMethodInterceptor.proceed(invocation)) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::proceed : PrePostAdviceReactiveMethodInterceptor.proceed(invocation) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::invoke -- org.springframework.security.access.prepost.PostInvocationAuthorizationAdvice::after : this.postAdvice.after(auth,invocation,attr,r) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::proceed -- org.aopalliance.intercept.MethodInvocation::proceed : invocation.proceed() 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::proceed -- reactor.core.Exceptions::propagate : Exceptions.propagate(throwable) 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::flowProceed -- org.aopalliance.intercept.MethodInvocation::proceed : invocation.proceed() 
org.springframework.security.access.prepost.PrePostAdviceReactiveMethodInterceptor::flowProceed -- reactor.core.Exceptions::propagate : Exceptions.propagate(throwable) 
class KotlinDelegate    {
  asFlow(publisher : org.springframework.security.access.prepost.Publisher) : java.lang.Object
}
org.springframework.security.access.prepost.KotlinDelegate::asFlow -- org.springframework.security.access.prepost.ReactiveFlowKt::asFlow : ReactiveFlowKt.asFlow(publisher) 
class PrePostAnnotationSecurityMetadataSource extends org.springframework.security.access.method.AbstractMethodSecurityMetadataSource   {
  attributeFactory : org.springframework.security.access.prepost.PrePostInvocationAttributeFactory
  PrePostAnnotationSecurityMetadataSource(attributeFactory : org.springframework.security.access.prepost.PrePostInvocationAttributeFactory) : None
  getAttributes(method : java.lang.reflect.Method, targetClass : java.lang.Class) : java.util.Collection
  getAllConfigAttributes() : java.util.Collection
  findAnnotation(method : java.lang.reflect.Method, targetClass : java.lang.Class, annotationClass : java.lang.Class) : org.springframework.security.access.prepost.A
}
org.springframework.security.access.prepost.PrePostAnnotationSecurityMetadataSource::getAttributes -- java.lang.reflect.Method::getDeclaringClass : method.getDeclaringClass() 
org.springframework.security.access.prepost.PrePostAnnotationSecurityMetadataSource::getAttributes -- java.util.Collections::emptyList : Collections.emptyList() 
org.springframework.security.access.prepost.PrePostAnnotationSecurityMetadataSource::getAttributes -- java.util.Collections::emptyList : Collections.emptyList() 
org.springframework.security.access.prepost.PrePostAnnotationSecurityMetadataSource::getAttributes -- org.springframework.security.access.prepost.PrePostInvocationAttributeFactory::createPreInvocationAttribute : this.attributeFactory.createPreInvocationAttribute(preFilterAttribute,filterObject,preAuthorizeAttribute) 
org.springframework.security.access.prepost.PrePostAnnotationSecurityMetadataSource::getAttributes -- org.springframework.security.access.prepost.PrePostInvocationAttributeFactory::createPostInvocationAttribute : this.attributeFactory.createPostInvocationAttribute(postFilterAttribute,postAuthorizeAttribute) 
org.springframework.security.access.prepost.PrePostAnnotationSecurityMetadataSource::findAnnotation -- org.springframework.util.ClassUtils::getMostSpecificMethod : ClassUtils.getMostSpecificMethod(method,targetClass) 
org.springframework.security.access.prepost.PrePostAnnotationSecurityMetadataSource::findAnnotation -- org.springframework.core.annotation.AnnotationUtils::findAnnotation : AnnotationUtils.findAnnotation(specificMethod,annotationClass) 
org.springframework.security.access.prepost.PrePostAnnotationSecurityMetadataSource::findAnnotation -- org.springframework.core.log.LogMessage::format : LogMessage.format("%s found on specific method: %s",annotation,specificMethod) 
org.springframework.security.access.prepost.PrePostAnnotationSecurityMetadataSource::findAnnotation -- org.springframework.core.annotation.AnnotationUtils::findAnnotation : AnnotationUtils.findAnnotation(method,annotationClass) 
org.springframework.security.access.prepost.PrePostAnnotationSecurityMetadataSource::findAnnotation -- org.springframework.core.log.LogMessage::format : LogMessage.format("%s found on: %s",annotation,method) 
org.springframework.security.access.prepost.PrePostAnnotationSecurityMetadataSource::findAnnotation -- org.springframework.core.annotation.AnnotationUtils::findAnnotation : AnnotationUtils.findAnnotation(specificMethod.getDeclaringClass(),annotationClass) 
org.springframework.security.access.prepost.PrePostAnnotationSecurityMetadataSource::findAnnotation -- org.springframework.core.log.LogMessage::format : LogMessage.format("%s found on: %s",annotation,specificMethod.getDeclaringClass().getName()) 
interface PrePostInvocationAttributeFactory    {
  createPreInvocationAttribute(preFilterAttribute : java.lang.String, filterObject : java.lang.String, preAuthorizeAttribute : java.lang.String) : org.springframework.security.access.prepost.PreInvocationAttribute
  createPostInvocationAttribute(postFilterAttribute : java.lang.String, postAuthorizeAttribute : java.lang.String) : org.springframework.security.access.prepost.PostInvocationAttribute
}
}
package vote {
class AbstractAccessDecisionManager  implements org.springframework.security.access.vote.AccessDecisionManager,InitializingBean,MessageSourceAware  {
  logger : org.apache.commons.logging.Log
  decisionVoters : java.util.List
  messages : org.springframework.context.support.MessageSourceAccessor
  allowIfAllAbstainDecisions : boolean
  AbstractAccessDecisionManager(decisionVoters : java.util.List) : None
  afterPropertiesSet() : void
  checkAllowIfAllAbstainDecisions() : void
  getDecisionVoters() : java.util.List
  isAllowIfAllAbstainDecisions() : boolean
  setAllowIfAllAbstainDecisions(allowIfAllAbstainDecisions : boolean) : void
  setMessageSource(messageSource : org.springframework.context.MessageSource) : void
  supports(attribute : org.springframework.security.access.ConfigAttribute) : boolean
  supports(clazz : java.lang.Class) : boolean
  toString() : java.lang.String
}
org.springframework.security.access.vote.AbstractAccessDecisionManager::AbstractAccessDecisionManager -- org.springframework.util.Assert::notEmpty : Assert.notEmpty(decisionVoters,"A list of AccessDecisionVoters is required") 
org.springframework.security.access.vote.AbstractAccessDecisionManager::afterPropertiesSet -- org.springframework.util.Assert::notEmpty : Assert.notEmpty(this.decisionVoters,"A list of AccessDecisionVoters is required") 
org.springframework.security.access.vote.AbstractAccessDecisionManager::afterPropertiesSet -- org.springframework.util.Assert::notNull : Assert.notNull(this.messages,"A message source must be set") 
org.springframework.security.access.vote.AbstractAccessDecisionManager::checkAllowIfAllAbstainDecisions -- org.springframework.context.support.MessageSourceAccessor::getMessage : this.messages.getMessage("AbstractAccessDecisionManager.accessDenied","Access is denied") 
org.springframework.security.access.vote.AbstractAccessDecisionManager::toString -- org.springframework.security.access.vote.AbstractAccessDecisionManager::getClass : this.getClass().getSimpleName() 
class AbstractAclVoter  implements org.springframework.security.access.AccessDecisionVoter  {
  processDomainObjectClass : java.lang.Class
  getDomainObjectInstance(invocation : org.aopalliance.intercept.MethodInvocation) : java.lang.Object
  getProcessDomainObjectClass() : java.lang.Class
  setProcessDomainObjectClass(processDomainObjectClass : java.lang.Class) : void
  supports(clazz : java.lang.Class) : boolean
}
org.springframework.security.access.vote.AbstractAclVoter::getDomainObjectInstance -- org.aopalliance.intercept.MethodInvocation::getArguments : invocation.getArguments() 
org.springframework.security.access.vote.AbstractAclVoter::getDomainObjectInstance -- org.aopalliance.intercept.MethodInvocation::getMethod : invocation.getMethod().getParameterTypes() 
org.springframework.security.access.vote.AbstractAclVoter::getDomainObjectInstance -- org.aopalliance.intercept.MethodInvocation::getMethod : invocation.getMethod() 
org.springframework.security.access.vote.AbstractAclVoter::getDomainObjectInstance -- java.lang.Class::isAssignableFrom : this.processDomainObjectClass.isAssignableFrom(params[i]) 
org.springframework.security.access.vote.AbstractAclVoter::setProcessDomainObjectClass -- org.springframework.util.Assert::notNull : Assert.notNull(processDomainObjectClass,"processDomainObjectClass cannot be set to null") 
class AffirmativeBased extends org.springframework.security.access.vote.AbstractAccessDecisionManager   {
  AffirmativeBased(decisionVoters : java.util.List) : None
  decide(authentication : org.springframework.security.core.Authentication, object : java.lang.Object, configAttributes : java.util.Collection) : void
}
class AuthenticatedVoter  implements org.springframework.security.access.AccessDecisionVoter  {
  IS_AUTHENTICATED_FULLY : java.lang.String
  IS_AUTHENTICATED_REMEMBERED : java.lang.String
  IS_AUTHENTICATED_ANONYMOUSLY : java.lang.String
  authenticationTrustResolver : org.springframework.security.authentication.AuthenticationTrustResolver
  isFullyAuthenticated(authentication : org.springframework.security.core.Authentication) : boolean
  setAuthenticationTrustResolver(authenticationTrustResolver : org.springframework.security.authentication.AuthenticationTrustResolver) : void
  supports(attribute : org.springframework.security.access.ConfigAttribute) : boolean
  supports(clazz : java.lang.Class) : boolean
  vote(authentication : org.springframework.security.core.Authentication, object : java.lang.Object, attributes : java.util.Collection) : int
}
org.springframework.security.access.vote.AuthenticatedVoter::isFullyAuthenticated -- org.springframework.security.authentication.AuthenticationTrustResolver::isFullyAuthenticated : this.authenticationTrustResolver.isFullyAuthenticated(authentication) 
org.springframework.security.access.vote.AuthenticatedVoter::setAuthenticationTrustResolver -- org.springframework.util.Assert::notNull : Assert.notNull(authenticationTrustResolver,"AuthenticationTrustResolver cannot be set to null") 
org.springframework.security.access.vote.AuthenticatedVoter::supports -- org.springframework.security.access.ConfigAttribute::getAttribute : attribute.getAttribute() 
org.springframework.security.access.vote.AuthenticatedVoter::supports -- org.springframework.security.access.vote.IS_AUTHENTICATED_FULLY::equals : IS_AUTHENTICATED_FULLY.equals(attribute.getAttribute()) 
org.springframework.security.access.vote.AuthenticatedVoter::supports -- org.springframework.security.access.ConfigAttribute::getAttribute : attribute.getAttribute() 
org.springframework.security.access.vote.AuthenticatedVoter::supports -- org.springframework.security.access.vote.IS_AUTHENTICATED_REMEMBERED::equals : IS_AUTHENTICATED_REMEMBERED.equals(attribute.getAttribute()) 
org.springframework.security.access.vote.AuthenticatedVoter::supports -- org.springframework.security.access.ConfigAttribute::getAttribute : attribute.getAttribute() 
org.springframework.security.access.vote.AuthenticatedVoter::supports -- org.springframework.security.access.vote.IS_AUTHENTICATED_ANONYMOUSLY::equals : IS_AUTHENTICATED_ANONYMOUSLY.equals(attribute.getAttribute()) 
org.springframework.security.access.vote.AuthenticatedVoter::supports -- org.springframework.security.access.ConfigAttribute::getAttribute : attribute.getAttribute() 
org.springframework.security.access.vote.AuthenticatedVoter::vote -- org.springframework.security.access.vote.IS_AUTHENTICATED_FULLY::equals : IS_AUTHENTICATED_FULLY.equals(attribute.getAttribute()) 
org.springframework.security.access.vote.AuthenticatedVoter::vote -- org.springframework.security.access.vote.IS_AUTHENTICATED_REMEMBERED::equals : IS_AUTHENTICATED_REMEMBERED.equals(attribute.getAttribute()) 
org.springframework.security.access.vote.AuthenticatedVoter::vote -- org.springframework.security.authentication.AuthenticationTrustResolver::isRememberMe : this.authenticationTrustResolver.isRememberMe(authentication) 
org.springframework.security.access.vote.AuthenticatedVoter::vote -- org.springframework.security.access.vote.IS_AUTHENTICATED_ANONYMOUSLY::equals : IS_AUTHENTICATED_ANONYMOUSLY.equals(attribute.getAttribute()) 
org.springframework.security.access.vote.AuthenticatedVoter::vote -- org.springframework.security.authentication.AuthenticationTrustResolver::isAnonymous : this.authenticationTrustResolver.isAnonymous(authentication) 
org.springframework.security.access.vote.AuthenticatedVoter::vote -- org.springframework.security.authentication.AuthenticationTrustResolver::isRememberMe : this.authenticationTrustResolver.isRememberMe(authentication) 
class ConsensusBased extends org.springframework.security.access.vote.AbstractAccessDecisionManager   {
  allowIfEqualGrantedDeniedDecisions : boolean
  ConsensusBased(decisionVoters : java.util.List) : None
  decide(authentication : org.springframework.security.core.Authentication, object : java.lang.Object, configAttributes : java.util.Collection) : void
  isAllowIfEqualGrantedDeniedDecisions() : boolean
  setAllowIfEqualGrantedDeniedDecisions(allowIfEqualGrantedDeniedDecisions : boolean) : void
}
class RoleHierarchyVoter extends org.springframework.security.access.vote.RoleVoter   {
  roleHierarchy : org.springframework.security.access.hierarchicalroles.RoleHierarchy
  RoleHierarchyVoter(roleHierarchy : org.springframework.security.access.hierarchicalroles.RoleHierarchy) : None
  extractAuthorities(authentication : org.springframework.security.core.Authentication) : java.util.Collection
}
org.springframework.security.access.vote.RoleHierarchyVoter::RoleHierarchyVoter -- org.springframework.util.Assert::notNull : Assert.notNull(roleHierarchy,"RoleHierarchy must not be null") 
org.springframework.security.access.vote.RoleHierarchyVoter::extractAuthorities -- org.springframework.security.access.hierarchicalroles.RoleHierarchy::getReachableGrantedAuthorities : this.roleHierarchy.getReachableGrantedAuthorities(authentication.getAuthorities()) 
org.springframework.security.access.vote.RoleHierarchyVoter::extractAuthorities -- org.springframework.security.core.Authentication::getAuthorities : authentication.getAuthorities() 
class RoleVoter  implements org.springframework.security.access.AccessDecisionVoter  {
  rolePrefix : java.lang.String
  getRolePrefix() : java.lang.String
  setRolePrefix(rolePrefix : java.lang.String) : void
  supports(attribute : org.springframework.security.access.ConfigAttribute) : boolean
  supports(clazz : java.lang.Class) : boolean
  vote(authentication : org.springframework.security.core.Authentication, object : java.lang.Object, attributes : java.util.Collection) : int
  extractAuthorities(authentication : org.springframework.security.core.Authentication) : java.util.Collection
}
org.springframework.security.access.vote.RoleVoter::supports -- org.springframework.security.access.ConfigAttribute::getAttribute : attribute.getAttribute() 
org.springframework.security.access.vote.RoleVoter::supports -- org.springframework.security.access.ConfigAttribute::getAttribute : attribute.getAttribute().startsWith(getRolePrefix()) 
org.springframework.security.access.vote.RoleVoter::supports -- org.springframework.security.access.ConfigAttribute::getAttribute : attribute.getAttribute() 
org.springframework.security.access.vote.RoleVoter::extractAuthorities -- org.springframework.security.core.Authentication::getAuthorities : authentication.getAuthorities() 
class UnanimousBased extends org.springframework.security.access.vote.AbstractAccessDecisionManager   {
  UnanimousBased(decisionVoters : java.util.List) : None
  decide(authentication : org.springframework.security.core.Authentication, object : java.lang.Object, attributes : java.util.Collection) : void
}
}
interface AccessDecisionManager    {
  decide(authentication : org.springframework.security.core.Authentication, object : java.lang.Object, configAttributes : java.util.Collection) : void
  supports(attribute : org.springframework.security.access.ConfigAttribute) : boolean
  supports(clazz : java.lang.Class) : boolean
}
interface AccessDecisionVoter    {
  supports(attribute : org.springframework.security.access.ConfigAttribute) : boolean
  supports(clazz : java.lang.Class) : boolean
  vote(authentication : org.springframework.security.core.Authentication, object : org.springframework.security.access.S, attributes : java.util.Collection) : int
}
class AccessDeniedException extends org.springframework.security.access.RuntimeException   {
  serialVersionUID : long
  AccessDeniedException(msg : java.lang.String) : None
  AccessDeniedException(msg : java.lang.String, cause : java.lang.Throwable) : None
}
interface AfterInvocationProvider    {
  decide(authentication : org.springframework.security.core.Authentication, object : java.lang.Object, attributes : java.util.Collection, returnedObject : java.lang.Object) : java.lang.Object
  supports(attribute : org.springframework.security.access.ConfigAttribute) : boolean
  supports(clazz : java.lang.Class) : boolean
}
class AuthorizationServiceException extends org.springframework.security.access.AccessDeniedException   {
  serialVersionUID : long
  AuthorizationServiceException(msg : java.lang.String) : None
  AuthorizationServiceException(msg : java.lang.String, cause : java.lang.Throwable) : None
}
interface ConfigAttribute    {
  getAttribute() : java.lang.String
}
interface PermissionCacheOptimizer    {
  cachePermissionsFor(a : org.springframework.security.core.Authentication, objects : java.util.Collection) : void
}
interface PermissionEvaluator    {
  hasPermission(authentication : org.springframework.security.core.Authentication, targetDomainObject : java.lang.Object, permission : java.lang.Object) : boolean
  hasPermission(authentication : org.springframework.security.core.Authentication, targetId : java.io.Serializable, targetType : java.lang.String, permission : java.lang.Object) : boolean
}
class SecurityConfig  implements org.springframework.security.access.ConfigAttribute  {
  serialVersionUID : long
  attrib : java.lang.String
  SecurityConfig(config : java.lang.String) : None
  equals(obj : java.lang.Object) : boolean
  getAttribute() : java.lang.String
  hashCode() : int
  toString() : java.lang.String
  createListFromCommaDelimitedString(access : java.lang.String) : java.util.List
  createList() : java.util.List
}
org.springframework.security.access.SecurityConfig::SecurityConfig -- org.springframework.util.Assert::hasText : Assert.hasText(config,"You must provide a configuration attribute") 
org.springframework.security.access.SecurityConfig::equals -- java.lang.String::equals : this.attrib.equals(attr.getAttribute()) 
org.springframework.security.access.SecurityConfig::hashCode -- java.lang.String::hashCode : this.attrib.hashCode() 
org.springframework.security.access.SecurityConfig::createListFromCommaDelimitedString -- org.springframework.util.StringUtils::commaDelimitedListToStringArray : StringUtils.commaDelimitedListToStringArray(access) 
org.springframework.security.access.SecurityConfig::createList -- org.springframework.util.Assert::notNull : Assert.notNull(attributeNames,"You must supply an array of attribute names") 
interface SecurityMetadataSource    {
  getAttributes(object : java.lang.Object) : java.util.Collection
  getAllConfigAttributes() : java.util.Collection
  supports(clazz : java.lang.Class) : boolean
}
}
package aot {
package hint {
class AuthorizeReturnObjectCoreHintsRegistrar  implements org.springframework.security.aot.hint.SecurityHintsRegistrar  {
  proxyFactory : org.springframework.security.authorization.AuthorizationProxyFactory
  scanner : org.springframework.security.core.annotation.SecurityAnnotationScanner
  visitedClasses : java.util.Set
  AuthorizeReturnObjectCoreHintsRegistrar(proxyFactory : org.springframework.security.authorization.AuthorizationProxyFactory) : None
  registerHints(hints : org.springframework.aot.hint.RuntimeHints, beanFactory : org.springframework.beans.factory.config.ConfigurableListableBeanFactory) : void
}
org.springframework.security.aot.hint.AuthorizeReturnObjectCoreHintsRegistrar::AuthorizeReturnObjectCoreHintsRegistrar -- org.springframework.util.Assert::notNull : Assert.notNull(proxyFactory,"proxyFactory cannot be null") 
org.springframework.security.aot.hint.AuthorizeReturnObjectCoreHintsRegistrar::registerHints -- org.springframework.beans.factory.config.ConfigurableListableBeanFactory::getBeanDefinitionNames : beanFactory.getBeanDefinitionNames() 
org.springframework.security.aot.hint.AuthorizeReturnObjectCoreHintsRegistrar::registerHints -- org.springframework.beans.factory.config.ConfigurableListableBeanFactory::getType : beanFactory.getType(name,false) 
org.springframework.security.aot.hint.AuthorizeReturnObjectCoreHintsRegistrar::registerHints -- org.springframework.security.core.annotation.SecurityAnnotationScanner::scan : this.scanner.scan(method,clazz) 
org.springframework.security.aot.hint.AuthorizeReturnObjectCoreHintsRegistrar::registerHints -- org.springframework.security.aot.hint.AuthorizeReturnObjectCoreHintsRegistrar::newAuthorizeReturnObjectHintsRegistrar : newAuthorizeReturnObjectHintsRegistrar(this.proxyFactory,toProxy).registerHints(hints,beanFactory) 
class AuthorizeReturnObjectHintsRegistrar  implements org.springframework.security.aot.hint.SecurityHintsRegistrar  {
  proxyFactory : org.springframework.security.authorization.AuthorizationProxyFactory
  scanner : org.springframework.security.core.annotation.SecurityAnnotationScanner
  visitedClasses : java.util.Set
  classesToProxy : java.util.List
  AuthorizeReturnObjectHintsRegistrar(proxyFactory : org.springframework.security.authorization.AuthorizationProxyFactory) : None
  AuthorizeReturnObjectHintsRegistrar(proxyFactory : org.springframework.security.authorization.AuthorizationProxyFactory, classes : java.util.List) : None
  registerHints(hints : org.springframework.aot.hint.RuntimeHints, beanFactory : org.springframework.beans.factory.config.ConfigurableListableBeanFactory) : void
  registerProxy(hints : org.springframework.aot.hint.RuntimeHints, clazz : java.lang.Class) : void
  traverseType(toProxy : java.util.List, clazz : java.lang.Class) : void
}
org.springframework.security.aot.hint.AuthorizeReturnObjectHintsRegistrar::AuthorizeReturnObjectHintsRegistrar -- org.springframework.util.Assert::notNull : Assert.notNull(proxyFactory,"proxyFactory cannot be null") 
org.springframework.security.aot.hint.AuthorizeReturnObjectHintsRegistrar::AuthorizeReturnObjectHintsRegistrar -- org.springframework.util.Assert::noNullElements : Assert.noNullElements(classes,"classes cannot contain null elements") 
org.springframework.security.aot.hint.AuthorizeReturnObjectHintsRegistrar::AuthorizeReturnObjectHintsRegistrar -- java.util.List::of : List.of(classes) 
org.springframework.security.aot.hint.AuthorizeReturnObjectHintsRegistrar::registerProxy -- org.springframework.security.authorization.AuthorizationProxyFactory::proxy : this.proxyFactory.proxy(clazz) 
org.springframework.security.aot.hint.AuthorizeReturnObjectHintsRegistrar::registerProxy -- java.lang.reflect.Proxy::isProxyClass : Proxy.isProxyClass(proxied) 
org.springframework.security.aot.hint.AuthorizeReturnObjectHintsRegistrar::registerProxy -- org.springframework.aot.hint.RuntimeHints::proxies : hints.proxies().registerJdkProxy(proxied.getInterfaces()) 
org.springframework.security.aot.hint.AuthorizeReturnObjectHintsRegistrar::registerProxy -- org.springframework.aot.hint.RuntimeHints::proxies : hints.proxies() 
org.springframework.security.aot.hint.AuthorizeReturnObjectHintsRegistrar::registerProxy -- org.springframework.aot.hint.RuntimeHints::reflection : hints.reflection().registerType(clazz,MemberCategory.INVOKE_DECLARED_CONSTRUCTORS,MemberCategory.INVOKE_DECLARED_METHODS).registerType(proxied,MemberCategory.INVOKE_DECLARED_CONSTRUCTORS,MemberCategory.INVOKE_DECLARED_METHODS,MemberCategory.DECLARED_FIELDS) 
org.springframework.security.aot.hint.AuthorizeReturnObjectHintsRegistrar::registerProxy -- org.springframework.aot.hint.RuntimeHints::reflection : hints.reflection().registerType(clazz,MemberCategory.INVOKE_DECLARED_CONSTRUCTORS,MemberCategory.INVOKE_DECLARED_METHODS) 
org.springframework.security.aot.hint.AuthorizeReturnObjectHintsRegistrar::registerProxy -- org.springframework.aot.hint.RuntimeHints::reflection : hints.reflection() 
org.springframework.security.aot.hint.AuthorizeReturnObjectHintsRegistrar::traverseType -- java.util.Set::contains : this.visitedClasses.contains(clazz) 
org.springframework.security.aot.hint.AuthorizeReturnObjectHintsRegistrar::traverseType -- java.util.Set::add : this.visitedClasses.add(clazz) 
org.springframework.security.aot.hint.AuthorizeReturnObjectHintsRegistrar::traverseType -- java.lang.Class::getDeclaredMethods : clazz.getDeclaredMethods() 
org.springframework.security.aot.hint.AuthorizeReturnObjectHintsRegistrar::traverseType -- org.springframework.security.core.annotation.SecurityAnnotationScanner::scan : this.scanner.scan(m,clazz) 
org.springframework.security.aot.hint.AuthorizeReturnObjectHintsRegistrar::traverseType -- java.util.List::add : toProxy.add(returnType) 
class CoreSecurityRuntimeHints  implements org.springframework.aot.hint.RuntimeHintsRegistrar  {
  registerHints(hints : org.springframework.aot.hint.RuntimeHints, classLoader : org.springframework.security.aot.hint.ClassLoader) : void
  registerMethodSecurityHints(hints : org.springframework.aot.hint.RuntimeHints) : void
  registerExpressionEvaluationHints(hints : org.springframework.aot.hint.RuntimeHints) : void
  registerExceptionEventsHints(hints : org.springframework.aot.hint.RuntimeHints) : void
  getDefaultAuthenticationExceptionEventPublisherTypes() : java.util.List
  registerDefaultJdbcSchemaFileHint(hints : org.springframework.aot.hint.RuntimeHints) : void
  registerSecurityContextHints(hints : org.springframework.aot.hint.RuntimeHints) : void
}
org.springframework.security.aot.hint.CoreSecurityRuntimeHints::registerHints -- org.springframework.aot.hint.RuntimeHints::resources : hints.resources().registerResourceBundle("org.springframework.security.messages") 
org.springframework.security.aot.hint.CoreSecurityRuntimeHints::registerHints -- org.springframework.aot.hint.RuntimeHints::resources : hints.resources() 
org.springframework.security.aot.hint.CoreSecurityRuntimeHints::registerMethodSecurityHints -- org.springframework.aot.hint.RuntimeHints::reflection : hints.reflection().registerType(TypeReference.of("org.springframework.security.access.expression.method.MethodSecurityExpressionRoot"),(builder)->builder.withMembers(MemberCategory.INVOKE_PUBLIC_METHODS)) 
org.springframework.security.aot.hint.CoreSecurityRuntimeHints::registerMethodSecurityHints -- org.springframework.aot.hint.RuntimeHints::reflection : hints.reflection() 
org.springframework.security.aot.hint.CoreSecurityRuntimeHints::registerMethodSecurityHints -- org.springframework.aot.hint.TypeReference::of : TypeReference.of("org.springframework.security.access.expression.method.MethodSecurityExpressionRoot") 
org.springframework.security.aot.hint.CoreSecurityRuntimeHints::registerMethodSecurityHints -- org.springframework.aot.hint.RuntimeHints::reflection : hints.reflection().registerType(AbstractAuthenticationToken.class,(builder)->builder.withMembers(MemberCategory.INVOKE_PUBLIC_METHODS)) 
org.springframework.security.aot.hint.CoreSecurityRuntimeHints::registerMethodSecurityHints -- org.springframework.aot.hint.RuntimeHints::reflection : hints.reflection() 
org.springframework.security.aot.hint.CoreSecurityRuntimeHints::registerExpressionEvaluationHints -- org.springframework.aot.hint.RuntimeHints::reflection : hints.reflection().registerTypes(List.of(TypeReference.of(SecurityExpressionOperations.class),TypeReference.of(SecurityExpressionRoot.class)),(builder)->builder.withMembers(MemberCategory.DECLARED_FIELDS,MemberCategory.INVOKE_DECLARED_METHODS)) 
org.springframework.security.aot.hint.CoreSecurityRuntimeHints::registerExpressionEvaluationHints -- org.springframework.aot.hint.RuntimeHints::reflection : hints.reflection() 
org.springframework.security.aot.hint.CoreSecurityRuntimeHints::registerExpressionEvaluationHints -- java.util.List::of : List.of(TypeReference.of(SecurityExpressionOperations.class),TypeReference.of(SecurityExpressionRoot.class)) 
org.springframework.security.aot.hint.CoreSecurityRuntimeHints::registerExpressionEvaluationHints -- org.springframework.aot.hint.TypeReference::of : TypeReference.of(SecurityExpressionOperations.class) 
org.springframework.security.aot.hint.CoreSecurityRuntimeHints::registerExpressionEvaluationHints -- org.springframework.aot.hint.TypeReference::of : TypeReference.of(SecurityExpressionRoot.class) 
org.springframework.security.aot.hint.CoreSecurityRuntimeHints::registerExceptionEventsHints -- org.springframework.aot.hint.RuntimeHints::reflection : hints.reflection().registerTypes(getDefaultAuthenticationExceptionEventPublisherTypes(),(builder)->builder.withMembers(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)) 
org.springframework.security.aot.hint.CoreSecurityRuntimeHints::registerExceptionEventsHints -- org.springframework.aot.hint.RuntimeHints::reflection : hints.reflection() 
org.springframework.security.aot.hint.CoreSecurityRuntimeHints::getDefaultAuthenticationExceptionEventPublisherTypes -- java.util.stream.Stream::of : Stream.of(AuthenticationFailureBadCredentialsEvent.class,AuthenticationFailureCredentialsExpiredEvent.class,AuthenticationFailureDisabledEvent.class,AuthenticationFailureExpiredEvent.class,AuthenticationFailureLockedEvent.class,AuthenticationFailureProviderNotFoundEvent.class,AuthenticationFailureProxyUntrustedEvent.class,AuthenticationFailureServiceExceptionEvent.class,AuthenticationServiceException.class,AccountExpiredException.class,BadCredentialsException.class,CredentialsExpiredException.class,DisabledException.class,LockedException.class,UsernameNotFoundException.class,ProviderNotFoundException.class).map(TypeReference::of).toList() 
org.springframework.security.aot.hint.CoreSecurityRuntimeHints::getDefaultAuthenticationExceptionEventPublisherTypes -- java.util.stream.Stream::of : Stream.of(AuthenticationFailureBadCredentialsEvent.class,AuthenticationFailureCredentialsExpiredEvent.class,AuthenticationFailureDisabledEvent.class,AuthenticationFailureExpiredEvent.class,AuthenticationFailureLockedEvent.class,AuthenticationFailureProviderNotFoundEvent.class,AuthenticationFailureProxyUntrustedEvent.class,AuthenticationFailureServiceExceptionEvent.class,AuthenticationServiceException.class,AccountExpiredException.class,BadCredentialsException.class,CredentialsExpiredException.class,DisabledException.class,LockedException.class,UsernameNotFoundException.class,ProviderNotFoundException.class).map(TypeReference::of) 
org.springframework.security.aot.hint.CoreSecurityRuntimeHints::getDefaultAuthenticationExceptionEventPublisherTypes -- java.util.stream.Stream::of : Stream.of(AuthenticationFailureBadCredentialsEvent.class,AuthenticationFailureCredentialsExpiredEvent.class,AuthenticationFailureDisabledEvent.class,AuthenticationFailureExpiredEvent.class,AuthenticationFailureLockedEvent.class,AuthenticationFailureProviderNotFoundEvent.class,AuthenticationFailureProxyUntrustedEvent.class,AuthenticationFailureServiceExceptionEvent.class,AuthenticationServiceException.class,AccountExpiredException.class,BadCredentialsException.class,CredentialsExpiredException.class,DisabledException.class,LockedException.class,UsernameNotFoundException.class,ProviderNotFoundException.class) 
org.springframework.security.aot.hint.CoreSecurityRuntimeHints::registerDefaultJdbcSchemaFileHint -- org.springframework.aot.hint.RuntimeHints::resources : hints.resources().registerPattern(JdbcDaoImpl.DEFAULT_USER_SCHEMA_DDL_LOCATION) 
org.springframework.security.aot.hint.CoreSecurityRuntimeHints::registerDefaultJdbcSchemaFileHint -- org.springframework.aot.hint.RuntimeHints::resources : hints.resources() 
org.springframework.security.aot.hint.CoreSecurityRuntimeHints::registerSecurityContextHints -- org.springframework.aot.hint.RuntimeHints::reflection : hints.reflection().registerType(SecurityContextImpl.class,(builder)->builder.withMembers(MemberCategory.INVOKE_PUBLIC_METHODS)) 
org.springframework.security.aot.hint.CoreSecurityRuntimeHints::registerSecurityContextHints -- org.springframework.aot.hint.RuntimeHints::reflection : hints.reflection() 
class OneTimeTokenRuntimeHints  implements org.springframework.aot.hint.RuntimeHintsRegistrar  {
  registerHints(hints : org.springframework.aot.hint.RuntimeHints, classLoader : org.springframework.security.aot.hint.ClassLoader) : void
}
org.springframework.security.aot.hint.OneTimeTokenRuntimeHints::registerHints -- org.springframework.aot.hint.RuntimeHints::resources : hints.resources().registerPattern("org/springframework/security/core/ott/jdbc/one-time-tokens-schema.sql") 
org.springframework.security.aot.hint.OneTimeTokenRuntimeHints::registerHints -- org.springframework.aot.hint.RuntimeHints::resources : hints.resources() 
class PrePostAuthorizeExpressionBeanHintsRegistrar  implements org.springframework.security.aot.hint.SecurityHintsRegistrar  {
  preAuthorizeScanner : org.springframework.security.core.annotation.SecurityAnnotationScanner
  postAuthorizeScanner : org.springframework.security.core.annotation.SecurityAnnotationScanner
  authorizeReturnObjectScanner : org.springframework.security.core.annotation.SecurityAnnotationScanner
  expressionParser : org.springframework.expression.spel.standard.SpelExpressionParser
  visitedClasses : java.util.Set
  toVisit : java.util.List
  PrePostAuthorizeExpressionBeanHintsRegistrar() : None
  PrePostAuthorizeExpressionBeanHintsRegistrar(toVisit : java.util.List) : None
  registerHints(hints : org.springframework.aot.hint.RuntimeHints, beanFactory : org.springframework.beans.factory.config.ConfigurableListableBeanFactory) : void
  extractSecurityExpressions(clazz : java.lang.Class) : java.util.Set
  extractBeanNames(rawExpression : java.lang.String) : java.util.Set
  resolveBeanNames(beanNames : java.util.Set, node : org.springframework.expression.spel.SpelNode) : void
}
org.springframework.security.aot.hint.PrePostAuthorizeExpressionBeanHintsRegistrar::PrePostAuthorizeExpressionBeanHintsRegistrar -- java.util.Arrays::asList : Arrays.asList(toVisit) 
org.springframework.security.aot.hint.PrePostAuthorizeExpressionBeanHintsRegistrar::PrePostAuthorizeExpressionBeanHintsRegistrar -- org.springframework.util.Assert::notEmpty : Assert.notEmpty(toVisit,"toVisit cannot be empty") 
org.springframework.security.aot.hint.PrePostAuthorizeExpressionBeanHintsRegistrar::PrePostAuthorizeExpressionBeanHintsRegistrar -- org.springframework.util.Assert::noNullElements : Assert.noNullElements(toVisit,"toVisit cannot contain null elements") 
org.springframework.security.aot.hint.PrePostAuthorizeExpressionBeanHintsRegistrar::registerHints -- org.springframework.beans.factory.config.ConfigurableListableBeanFactory::getType : beanFactory.getType(toRegister,false) 
org.springframework.security.aot.hint.PrePostAuthorizeExpressionBeanHintsRegistrar::registerHints -- org.springframework.aot.hint.RuntimeHints::reflection : hints.reflection().registerType(TypeReference.of(type),MemberCategory.INVOKE_DECLARED_METHODS) 
org.springframework.security.aot.hint.PrePostAuthorizeExpressionBeanHintsRegistrar::registerHints -- org.springframework.aot.hint.RuntimeHints::reflection : hints.reflection() 
org.springframework.security.aot.hint.PrePostAuthorizeExpressionBeanHintsRegistrar::registerHints -- org.springframework.aot.hint.TypeReference::of : TypeReference.of(type) 
org.springframework.security.aot.hint.PrePostAuthorizeExpressionBeanHintsRegistrar::extractSecurityExpressions -- java.util.Set::contains : this.visitedClasses.contains(clazz) 
org.springframework.security.aot.hint.PrePostAuthorizeExpressionBeanHintsRegistrar::extractSecurityExpressions -- java.util.Collections::emptySet : Collections.emptySet() 
org.springframework.security.aot.hint.PrePostAuthorizeExpressionBeanHintsRegistrar::extractSecurityExpressions -- java.util.Set::add : this.visitedClasses.add(clazz) 
org.springframework.security.aot.hint.PrePostAuthorizeExpressionBeanHintsRegistrar::extractSecurityExpressions -- java.lang.Class::getDeclaredMethods : clazz.getDeclaredMethods() 
org.springframework.security.aot.hint.PrePostAuthorizeExpressionBeanHintsRegistrar::extractSecurityExpressions -- org.springframework.security.core.annotation.SecurityAnnotationScanner::scan : this.preAuthorizeScanner.scan(method,clazz) 
org.springframework.security.aot.hint.PrePostAuthorizeExpressionBeanHintsRegistrar::extractSecurityExpressions -- org.springframework.security.core.annotation.SecurityAnnotationScanner::scan : this.postAuthorizeScanner.scan(method,clazz) 
org.springframework.security.aot.hint.PrePostAuthorizeExpressionBeanHintsRegistrar::extractSecurityExpressions -- org.springframework.security.core.annotation.SecurityAnnotationScanner::scan : this.authorizeReturnObjectScanner.scan(method,clazz) 
org.springframework.security.aot.hint.PrePostAuthorizeExpressionBeanHintsRegistrar::extractBeanNames -- org.springframework.expression.spel.standard.SpelExpressionParser::parseRaw : this.expressionParser.parseRaw(rawExpression) 
org.springframework.security.aot.hint.PrePostAuthorizeExpressionBeanHintsRegistrar::resolveBeanNames -- java.util.Set::add : beanNames.add(br.getName()) 
org.springframework.security.aot.hint.PrePostAuthorizeExpressionBeanHintsRegistrar::resolveBeanNames -- org.springframework.expression.spel.SpelNode::getChildCount : node.getChildCount() 
org.springframework.security.aot.hint.PrePostAuthorizeExpressionBeanHintsRegistrar::resolveBeanNames -- org.springframework.expression.spel.SpelNode::getChild : node.getChild(i) 
class PrePostAuthorizeHintsRegistrar  implements org.springframework.security.aot.hint.SecurityHintsRegistrar  {
  registerHints(hints : org.springframework.aot.hint.RuntimeHints, beanFactory : org.springframework.beans.factory.config.ConfigurableListableBeanFactory) : void
}
org.springframework.security.aot.hint.PrePostAuthorizeHintsRegistrar::registerHints -- java.util.Arrays::stream : Arrays.stream(beanFactory.getBeanDefinitionNames()).map((beanName)->RegisteredBean.of(beanFactory,beanName).getBeanClass()).collect(Collectors.toList()) 
org.springframework.security.aot.hint.PrePostAuthorizeHintsRegistrar::registerHints -- java.util.Arrays::stream : Arrays.stream(beanFactory.getBeanDefinitionNames()).map((beanName)->RegisteredBean.of(beanFactory,beanName).getBeanClass()) 
org.springframework.security.aot.hint.PrePostAuthorizeHintsRegistrar::registerHints -- java.util.Arrays::stream : Arrays.stream(beanFactory.getBeanDefinitionNames()) 
org.springframework.security.aot.hint.PrePostAuthorizeHintsRegistrar::registerHints -- org.springframework.beans.factory.config.ConfigurableListableBeanFactory::getBeanDefinitionNames : beanFactory.getBeanDefinitionNames() 
org.springframework.security.aot.hint.PrePostAuthorizeHintsRegistrar::registerHints -- org.springframework.beans.factory.support.RegisteredBean::of : RegisteredBean.of(beanFactory,beanName).getBeanClass() 
org.springframework.security.aot.hint.PrePostAuthorizeHintsRegistrar::registerHints -- org.springframework.beans.factory.support.RegisteredBean::of : RegisteredBean.of(beanFactory,beanName) 
org.springframework.security.aot.hint.PrePostAuthorizeHintsRegistrar::registerHints -- java.util.stream.Collectors::toList : Collectors.toList() 
org.springframework.security.aot.hint.PrePostAuthorizeHintsRegistrar::registerHints -- org.springframework.security.aot.hint.PrePostAuthorizeHintsRegistrar::newPrePostAuthorizeExpressionBeanHintsRegistrar : newPrePostAuthorizeExpressionBeanHintsRegistrar(beans).registerHints(hints,beanFactory) 
class SecurityHintsAotProcessor  implements org.springframework.beans.factory.aot.BeanFactoryInitializationAotProcessor  {
  processAheadOfTime(beanFactory : org.springframework.beans.factory.config.ConfigurableListableBeanFactory) : org.springframework.beans.factory.aot.BeanFactoryInitializationAotContribution
}
class AuthorizationProxyFactoryAotContribution  implements org.springframework.security.aot.hint.BeanFactoryInitializationAotContribution  {
  beanFactory : org.springframework.security.aot.hint.ConfigurableListableBeanFactory
  AuthorizationProxyFactoryAotContribution(beanFactory : org.springframework.security.aot.hint.ConfigurableListableBeanFactory) : None
  applyTo(context : org.springframework.security.aot.hint.GenerationContext, code : org.springframework.security.aot.hint.BeanFactoryInitializationCode) : void
}
org.springframework.security.aot.hint.AuthorizationProxyFactoryAotContribution::applyTo -- org.springframework.security.aot.hint.ConfigurableListableBeanFactory::getBeanProvider : this.beanFactory.getBeanProvider(SecurityHintsRegistrar.class).forEach((provider)->provider.registerHints(context.getRuntimeHints(),this.beanFactory)) 
org.springframework.security.aot.hint.AuthorizationProxyFactoryAotContribution::applyTo -- org.springframework.security.aot.hint.ConfigurableListableBeanFactory::getBeanProvider : this.beanFactory.getBeanProvider(SecurityHintsRegistrar.class) 
org.springframework.security.aot.hint.AuthorizationProxyFactoryAotContribution::applyTo -- org.springframework.security.aot.hint.GenerationContext::getRuntimeHints : context.getRuntimeHints() 
interface SecurityHintsRegistrar    {
  registerHints(hints : org.springframework.aot.hint.RuntimeHints, beanFactory : org.springframework.beans.factory.config.ConfigurableListableBeanFactory) : void
}
}
}
package authentication {
package dao {
class AbstractUserDetailsAuthenticationProvider  implements org.springframework.security.authentication.dao.AuthenticationProvider,InitializingBean,MessageSourceAware  {
  logger : org.apache.commons.logging.Log
  messages : org.springframework.context.support.MessageSourceAccessor
  userCache : org.springframework.security.core.userdetails.UserCache
  forcePrincipalAsString : boolean
  hideUserNotFoundExceptions : boolean
  preAuthenticationChecks : org.springframework.security.core.userdetails.UserDetailsChecker
  postAuthenticationChecks : org.springframework.security.core.userdetails.UserDetailsChecker
  authoritiesMapper : org.springframework.security.core.authority.mapping.GrantedAuthoritiesMapper
  additionalAuthenticationChecks(userDetails : org.springframework.security.core.userdetails.UserDetails, authentication : org.springframework.security.authentication.UsernamePasswordAuthenticationToken) : void
  afterPropertiesSet() : void
  authenticate(authentication : org.springframework.security.core.Authentication) : org.springframework.security.core.Authentication
  determineUsername(authentication : org.springframework.security.core.Authentication) : java.lang.String
  createSuccessAuthentication(principal : java.lang.Object, authentication : org.springframework.security.core.Authentication, user : org.springframework.security.core.userdetails.UserDetails) : org.springframework.security.core.Authentication
  doAfterPropertiesSet() : void
  getUserCache() : org.springframework.security.core.userdetails.UserCache
  isForcePrincipalAsString() : boolean
  isHideUserNotFoundExceptions() : boolean
  retrieveUser(username : java.lang.String, authentication : org.springframework.security.authentication.UsernamePasswordAuthenticationToken) : org.springframework.security.core.userdetails.UserDetails
  setForcePrincipalAsString(forcePrincipalAsString : boolean) : void
  setHideUserNotFoundExceptions(hideUserNotFoundExceptions : boolean) : void
  setMessageSource(messageSource : org.springframework.context.MessageSource) : void
  setUserCache(userCache : org.springframework.security.core.userdetails.UserCache) : void
  supports(authentication : java.lang.Class) : boolean
  getPreAuthenticationChecks() : org.springframework.security.core.userdetails.UserDetailsChecker
  setPreAuthenticationChecks(preAuthenticationChecks : org.springframework.security.core.userdetails.UserDetailsChecker) : void
  getPostAuthenticationChecks() : org.springframework.security.core.userdetails.UserDetailsChecker
  setPostAuthenticationChecks(postAuthenticationChecks : org.springframework.security.core.userdetails.UserDetailsChecker) : void
  setAuthoritiesMapper(authoritiesMapper : org.springframework.security.core.authority.mapping.GrantedAuthoritiesMapper) : void
}
org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider::afterPropertiesSet -- org.springframework.util.Assert::notNull : Assert.notNull(this.userCache,"A user cache must be set") 
org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider::afterPropertiesSet -- org.springframework.util.Assert::notNull : Assert.notNull(this.messages,"A message source must be set") 
org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider::authenticate -- org.springframework.util.Assert::isInstanceOf : Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class,authentication,()->this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.onlySupports","Only UsernamePasswordAuthenticationToken is supported")) 
org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider::authenticate -- org.springframework.context.support.MessageSourceAccessor::getMessage : this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.onlySupports","Only UsernamePasswordAuthenticationToken is supported") 
org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider::authenticate -- org.springframework.security.core.userdetails.UserCache::getUserFromCache : this.userCache.getUserFromCache(username) 
org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider::authenticate -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.format("Failed to find user '%s'",username)) 
org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider::authenticate -- org.springframework.core.log.LogMessage::format : LogMessage.format("Failed to find user '%s'",username) 
org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider::authenticate -- org.springframework.context.support.MessageSourceAccessor::getMessage : this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials","Bad credentials") 
org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider::authenticate -- org.springframework.util.Assert::notNull : Assert.notNull(user,"retrieveUser returned null - a violation of the interface contract") 
org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider::authenticate -- org.springframework.security.core.userdetails.UserDetailsChecker::check : this.preAuthenticationChecks.check(user) 
org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider::authenticate -- org.springframework.security.core.userdetails.UserDetailsChecker::check : this.preAuthenticationChecks.check(user) 
org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider::authenticate -- org.springframework.security.core.userdetails.UserDetailsChecker::check : this.postAuthenticationChecks.check(user) 
org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider::authenticate -- org.springframework.security.core.userdetails.UserCache::putUserInCache : this.userCache.putUserInCache(user) 
org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider::determineUsername -- org.springframework.security.core.Authentication::getPrincipal : authentication.getPrincipal() 
org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider::determineUsername -- org.springframework.security.core.Authentication::getName : authentication.getName() 
org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider::createSuccessAuthentication -- org.springframework.security.authentication.UsernamePasswordAuthenticationToken::authenticated : UsernamePasswordAuthenticationToken.authenticated(principal,authentication.getCredentials(),this.authoritiesMapper.mapAuthorities(user.getAuthorities())) 
org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider::createSuccessAuthentication -- org.springframework.security.core.Authentication::getCredentials : authentication.getCredentials() 
org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider::createSuccessAuthentication -- org.springframework.security.core.authority.mapping.GrantedAuthoritiesMapper::mapAuthorities : this.authoritiesMapper.mapAuthorities(user.getAuthorities()) 
org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider::createSuccessAuthentication -- org.springframework.security.core.userdetails.UserDetails::getAuthorities : user.getAuthorities() 
org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider::createSuccessAuthentication -- org.springframework.security.core.Authentication::getDetails : authentication.getDetails() 
org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider::createSuccessAuthentication -- org.apache.commons.logging.Log::debug : this.logger.debug("Authenticated user") 
class DefaultPreAuthenticationChecks  implements org.springframework.security.authentication.dao.UserDetailsChecker  {
  check(user : org.springframework.security.authentication.dao.UserDetails) : void
}
org.springframework.security.authentication.dao.DefaultPreAuthenticationChecks::check -- org.springframework.security.authentication.dao.UserDetails::isAccountNonLocked : user.isAccountNonLocked() 
org.springframework.security.authentication.dao.DefaultPreAuthenticationChecks::check -- org.springframework.security.authentication.dao.UserDetails::isEnabled : user.isEnabled() 
org.springframework.security.authentication.dao.DefaultPreAuthenticationChecks::check -- org.springframework.security.authentication.dao.UserDetails::isAccountNonExpired : user.isAccountNonExpired() 
class DefaultPostAuthenticationChecks  implements org.springframework.security.authentication.dao.UserDetailsChecker  {
  check(user : org.springframework.security.authentication.dao.UserDetails) : void
}
org.springframework.security.authentication.dao.DefaultPostAuthenticationChecks::check -- org.springframework.security.authentication.dao.UserDetails::isCredentialsNonExpired : user.isCredentialsNonExpired() 
class DaoAuthenticationProvider extends org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider   {
  USER_NOT_FOUND_PASSWORD : java.lang.String
  passwordEncoder : java.util.function.Supplier
  userNotFoundEncodedPassword : java.lang.String
  userDetailsService : org.springframework.security.core.userdetails.UserDetailsService
  userDetailsPasswordService : org.springframework.security.core.userdetails.UserDetailsPasswordService
  compromisedPasswordChecker : org.springframework.security.authentication.password.CompromisedPasswordChecker
  DaoAuthenticationProvider() : None
  DaoAuthenticationProvider(userDetailsService : org.springframework.security.core.userdetails.UserDetailsService) : None
  DaoAuthenticationProvider(passwordEncoder : org.springframework.security.crypto.password.PasswordEncoder) : None
  additionalAuthenticationChecks(userDetails : org.springframework.security.core.userdetails.UserDetails, authentication : org.springframework.security.authentication.UsernamePasswordAuthenticationToken) : void
  doAfterPropertiesSet() : void
  retrieveUser(username : java.lang.String, authentication : org.springframework.security.authentication.UsernamePasswordAuthenticationToken) : org.springframework.security.core.userdetails.UserDetails
  createSuccessAuthentication(principal : java.lang.Object, authentication : org.springframework.security.core.Authentication, user : org.springframework.security.core.userdetails.UserDetails) : org.springframework.security.core.Authentication
  prepareTimingAttackProtection() : void
  mitigateAgainstTimingAttack(authentication : org.springframework.security.authentication.UsernamePasswordAuthenticationToken) : void
  setPasswordEncoder(passwordEncoder : org.springframework.security.crypto.password.PasswordEncoder) : void
  getPasswordEncoder() : org.springframework.security.crypto.password.PasswordEncoder
  setUserDetailsService(userDetailsService : org.springframework.security.core.userdetails.UserDetailsService) : void
  getUserDetailsService() : org.springframework.security.core.userdetails.UserDetailsService
  setUserDetailsPasswordService(userDetailsPasswordService : org.springframework.security.core.userdetails.UserDetailsPasswordService) : void
  setCompromisedPasswordChecker(compromisedPasswordChecker : org.springframework.security.authentication.password.CompromisedPasswordChecker) : void
}
org.springframework.security.authentication.dao.DaoAuthenticationProvider::additionalAuthenticationChecks -- org.springframework.security.authentication.UsernamePasswordAuthenticationToken::getCredentials : authentication.getCredentials() 
org.springframework.security.authentication.dao.DaoAuthenticationProvider::additionalAuthenticationChecks -- org.springframework.security.authentication.UsernamePasswordAuthenticationToken::getCredentials : authentication.getCredentials().toString() 
org.springframework.security.authentication.dao.DaoAuthenticationProvider::additionalAuthenticationChecks -- org.springframework.security.authentication.UsernamePasswordAuthenticationToken::getCredentials : authentication.getCredentials() 
org.springframework.security.authentication.dao.DaoAuthenticationProvider::additionalAuthenticationChecks -- java.util.function.Supplier::get : this.passwordEncoder.get().matches(presentedPassword,userDetails.getPassword()) 
org.springframework.security.authentication.dao.DaoAuthenticationProvider::additionalAuthenticationChecks -- java.util.function.Supplier::get : this.passwordEncoder.get() 
org.springframework.security.authentication.dao.DaoAuthenticationProvider::additionalAuthenticationChecks -- org.springframework.security.core.userdetails.UserDetails::getPassword : userDetails.getPassword() 
org.springframework.security.authentication.dao.DaoAuthenticationProvider::doAfterPropertiesSet -- org.springframework.util.Assert::notNull : Assert.notNull(this.userDetailsService,"A UserDetailsService must be set") 
org.springframework.security.authentication.dao.DaoAuthenticationProvider::retrieveUser -- org.springframework.security.authentication.dao.DaoAuthenticationProvider::getUserDetailsService : this.getUserDetailsService().loadUserByUsername(username) 
org.springframework.security.authentication.dao.DaoAuthenticationProvider::createSuccessAuthentication -- org.springframework.security.core.Authentication::getCredentials : authentication.getCredentials().toString() 
org.springframework.security.authentication.dao.DaoAuthenticationProvider::createSuccessAuthentication -- org.springframework.security.core.Authentication::getCredentials : authentication.getCredentials() 
org.springframework.security.authentication.dao.DaoAuthenticationProvider::createSuccessAuthentication -- org.springframework.security.authentication.password.CompromisedPasswordChecker::check : this.compromisedPasswordChecker.check(presentedPassword).isCompromised() 
org.springframework.security.authentication.dao.DaoAuthenticationProvider::createSuccessAuthentication -- org.springframework.security.authentication.password.CompromisedPasswordChecker::check : this.compromisedPasswordChecker.check(presentedPassword) 
org.springframework.security.authentication.dao.DaoAuthenticationProvider::createSuccessAuthentication -- java.util.function.Supplier::get : this.passwordEncoder.get().upgradeEncoding(user.getPassword()) 
org.springframework.security.authentication.dao.DaoAuthenticationProvider::createSuccessAuthentication -- java.util.function.Supplier::get : this.passwordEncoder.get() 
org.springframework.security.authentication.dao.DaoAuthenticationProvider::createSuccessAuthentication -- org.springframework.security.core.userdetails.UserDetails::getPassword : user.getPassword() 
org.springframework.security.authentication.dao.DaoAuthenticationProvider::createSuccessAuthentication -- java.util.function.Supplier::get : this.passwordEncoder.get().encode(presentedPassword) 
org.springframework.security.authentication.dao.DaoAuthenticationProvider::createSuccessAuthentication -- java.util.function.Supplier::get : this.passwordEncoder.get() 
org.springframework.security.authentication.dao.DaoAuthenticationProvider::createSuccessAuthentication -- org.springframework.security.core.userdetails.UserDetailsPasswordService::updatePassword : this.userDetailsPasswordService.updatePassword(user,newPassword) 
org.springframework.security.authentication.dao.DaoAuthenticationProvider::prepareTimingAttackProtection -- java.util.function.Supplier::get : this.passwordEncoder.get().encode(USER_NOT_FOUND_PASSWORD) 
org.springframework.security.authentication.dao.DaoAuthenticationProvider::prepareTimingAttackProtection -- java.util.function.Supplier::get : this.passwordEncoder.get() 
org.springframework.security.authentication.dao.DaoAuthenticationProvider::mitigateAgainstTimingAttack -- org.springframework.security.authentication.UsernamePasswordAuthenticationToken::getCredentials : authentication.getCredentials() 
org.springframework.security.authentication.dao.DaoAuthenticationProvider::mitigateAgainstTimingAttack -- org.springframework.security.authentication.UsernamePasswordAuthenticationToken::getCredentials : authentication.getCredentials().toString() 
org.springframework.security.authentication.dao.DaoAuthenticationProvider::mitigateAgainstTimingAttack -- org.springframework.security.authentication.UsernamePasswordAuthenticationToken::getCredentials : authentication.getCredentials() 
org.springframework.security.authentication.dao.DaoAuthenticationProvider::mitigateAgainstTimingAttack -- java.util.function.Supplier::get : this.passwordEncoder.get().matches(presentedPassword,this.userNotFoundEncodedPassword) 
org.springframework.security.authentication.dao.DaoAuthenticationProvider::mitigateAgainstTimingAttack -- java.util.function.Supplier::get : this.passwordEncoder.get() 
org.springframework.security.authentication.dao.DaoAuthenticationProvider::setPasswordEncoder -- org.springframework.util.Assert::notNull : Assert.notNull(passwordEncoder,"passwordEncoder cannot be null") 
org.springframework.security.authentication.dao.DaoAuthenticationProvider::getPasswordEncoder -- java.util.function.Supplier::get : this.passwordEncoder.get() 
}
package event {
class AbstractAuthenticationEvent extends org.springframework.context.ApplicationEvent   {
  AbstractAuthenticationEvent(authentication : org.springframework.security.core.Authentication) : None
  getAuthentication() : org.springframework.security.core.Authentication
}
class AbstractAuthenticationFailureEvent extends org.springframework.security.authentication.event.AbstractAuthenticationEvent   {
  exception : org.springframework.security.core.AuthenticationException
  AbstractAuthenticationFailureEvent(authentication : org.springframework.security.core.Authentication, exception : org.springframework.security.core.AuthenticationException) : None
  getException() : org.springframework.security.core.AuthenticationException
}
org.springframework.security.authentication.event.AbstractAuthenticationFailureEvent::AbstractAuthenticationFailureEvent -- org.springframework.util.Assert::notNull : Assert.notNull(exception,"AuthenticationException is required") 
class AuthenticationFailureBadCredentialsEvent extends org.springframework.security.authentication.event.AbstractAuthenticationFailureEvent   {
  serialVersionUID : long
  AuthenticationFailureBadCredentialsEvent(authentication : org.springframework.security.core.Authentication, exception : org.springframework.security.core.AuthenticationException) : None
}
class AuthenticationFailureCredentialsExpiredEvent extends org.springframework.security.authentication.event.AbstractAuthenticationFailureEvent   {
  serialVersionUID : long
  AuthenticationFailureCredentialsExpiredEvent(authentication : org.springframework.security.core.Authentication, exception : org.springframework.security.core.AuthenticationException) : None
}
class AuthenticationFailureDisabledEvent extends org.springframework.security.authentication.event.AbstractAuthenticationFailureEvent   {
  serialVersionUID : long
  AuthenticationFailureDisabledEvent(authentication : org.springframework.security.core.Authentication, exception : org.springframework.security.core.AuthenticationException) : None
}
class AuthenticationFailureExpiredEvent extends org.springframework.security.authentication.event.AbstractAuthenticationFailureEvent   {
  serialVersionUID : long
  AuthenticationFailureExpiredEvent(authentication : org.springframework.security.core.Authentication, exception : org.springframework.security.core.AuthenticationException) : None
}
class AuthenticationFailureLockedEvent extends org.springframework.security.authentication.event.AbstractAuthenticationFailureEvent   {
  serialVersionUID : long
  AuthenticationFailureLockedEvent(authentication : org.springframework.security.core.Authentication, exception : org.springframework.security.core.AuthenticationException) : None
}
class AuthenticationFailureProviderNotFoundEvent extends org.springframework.security.authentication.event.AbstractAuthenticationFailureEvent   {
  serialVersionUID : long
  AuthenticationFailureProviderNotFoundEvent(authentication : org.springframework.security.core.Authentication, exception : org.springframework.security.core.AuthenticationException) : None
}
class AuthenticationFailureProxyUntrustedEvent extends org.springframework.security.authentication.event.AbstractAuthenticationFailureEvent   {
  serialVersionUID : long
  AuthenticationFailureProxyUntrustedEvent(authentication : org.springframework.security.core.Authentication, exception : org.springframework.security.core.AuthenticationException) : None
}
class AuthenticationFailureServiceExceptionEvent extends org.springframework.security.authentication.event.AbstractAuthenticationFailureEvent   {
  serialVersionUID : long
  AuthenticationFailureServiceExceptionEvent(authentication : org.springframework.security.core.Authentication, exception : org.springframework.security.core.AuthenticationException) : None
}
class AuthenticationSuccessEvent extends org.springframework.security.authentication.event.AbstractAuthenticationEvent   {
  serialVersionUID : long
  AuthenticationSuccessEvent(authentication : org.springframework.security.core.Authentication) : None
}
class InteractiveAuthenticationSuccessEvent extends org.springframework.security.authentication.event.AbstractAuthenticationEvent   {
  serialVersionUID : long
  generatedBy : java.lang.Class
  InteractiveAuthenticationSuccessEvent(authentication : org.springframework.security.core.Authentication, generatedBy : java.lang.Class) : None
  getGeneratedBy() : java.lang.Class
}
org.springframework.security.authentication.event.InteractiveAuthenticationSuccessEvent::InteractiveAuthenticationSuccessEvent -- org.springframework.util.Assert::notNull : Assert.notNull(generatedBy,"generatedBy cannot be null") 
class LoggerListener  implements org.springframework.context.ApplicationListener  {
  logger : org.apache.commons.logging.Log
  logInteractiveAuthenticationSuccessEvents : boolean
  onApplicationEvent(event : org.springframework.security.authentication.event.AbstractAuthenticationEvent) : void
  getLogMessage(event : org.springframework.security.authentication.event.AbstractAuthenticationEvent) : java.lang.String
  isLogInteractiveAuthenticationSuccessEvents() : boolean
  setLogInteractiveAuthenticationSuccessEvents(logInteractiveAuthenticationSuccessEvents : boolean) : void
}
org.springframework.security.authentication.event.LoggerListener::onApplicationEvent -- org.apache.commons.logging.Log::warn : logger.warn(LogMessage.of(()->getLogMessage(event))) 
org.springframework.security.authentication.event.LoggerListener::onApplicationEvent -- org.springframework.core.log.LogMessage::of : LogMessage.of(()->getLogMessage(event)) 
org.springframework.security.authentication.event.LoggerListener::getLogMessage -- org.springframework.util.ClassUtils::getShortName : ClassUtils.getShortName(event.getClass()) 
org.springframework.security.authentication.event.LoggerListener::getLogMessage -- org.springframework.security.authentication.event.AbstractAuthenticationEvent::getClass : event.getClass() 
org.springframework.security.authentication.event.LoggerListener::getLogMessage -- org.springframework.security.authentication.event.AbstractAuthenticationEvent::getAuthentication : event.getAuthentication().getName() 
org.springframework.security.authentication.event.LoggerListener::getLogMessage -- org.springframework.security.authentication.event.AbstractAuthenticationEvent::getAuthentication : event.getAuthentication() 
org.springframework.security.authentication.event.LoggerListener::getLogMessage -- org.springframework.security.authentication.event.AbstractAuthenticationEvent::getAuthentication : event.getAuthentication().getDetails() 
org.springframework.security.authentication.event.LoggerListener::getLogMessage -- org.springframework.security.authentication.event.AbstractAuthenticationEvent::getAuthentication : event.getAuthentication() 
class LogoutSuccessEvent extends org.springframework.security.authentication.event.AbstractAuthenticationEvent   {
  serialVersionUID : long
  LogoutSuccessEvent(authentication : org.springframework.security.core.Authentication) : None
}
}
package jaas {
package event {
class JaasAuthenticationEvent extends org.springframework.context.ApplicationEvent   {
  JaasAuthenticationEvent(auth : org.springframework.security.core.Authentication) : None
  getAuthentication() : org.springframework.security.core.Authentication
}
class JaasAuthenticationFailedEvent extends org.springframework.security.authentication.jaas.event.JaasAuthenticationEvent   {
  serialVersionUID : long
  exception : java.lang.Exception
  JaasAuthenticationFailedEvent(auth : org.springframework.security.core.Authentication, exception : java.lang.Exception) : None
  getException() : java.lang.Exception
}
class JaasAuthenticationSuccessEvent extends org.springframework.security.authentication.jaas.event.JaasAuthenticationEvent   {
  serialVersionUID : long
  JaasAuthenticationSuccessEvent(auth : org.springframework.security.core.Authentication) : None
}
}
package memory {
class InMemoryConfiguration extends javax.security.auth.login.Configuration   {
  defaultConfiguration : org.springframework.security.authentication.jaas.memory.AppConfigurationEntry[]
  mappedConfigurations : java.util.Map
  InMemoryConfiguration(defaultConfiguration : org.springframework.security.authentication.jaas.memory.AppConfigurationEntry[]) : None
  InMemoryConfiguration(mappedConfigurations : java.util.Map) : None
  InMemoryConfiguration(mappedConfigurations : java.util.Map, defaultConfiguration : org.springframework.security.authentication.jaas.memory.AppConfigurationEntry[]) : None
  getAppConfigurationEntry(name : java.lang.String) : org.springframework.security.authentication.jaas.memory.AppConfigurationEntry[]
  refresh() : void
}
org.springframework.security.authentication.jaas.memory.InMemoryConfiguration::InMemoryConfiguration -- java.util.Collections::emptyMap : Collections.emptyMap() 
org.springframework.security.authentication.jaas.memory.InMemoryConfiguration::InMemoryConfiguration -- org.springframework.util.Assert::notNull : Assert.notNull(mappedConfigurations,"mappedConfigurations cannot be null.") 
org.springframework.security.authentication.jaas.memory.InMemoryConfiguration::getAppConfigurationEntry -- java.util.Map::get : this.mappedConfigurations.get(name) 
}
class AbstractJaasAuthenticationProvider  implements org.springframework.security.authentication.jaas.AuthenticationProvider,ApplicationEventPublisherAware,InitializingBean,ApplicationListener  {
  applicationEventPublisher : org.springframework.context.ApplicationEventPublisher
  authorityGranters : org.springframework.security.authentication.jaas.AuthorityGranter[]
  callbackHandlers : org.springframework.security.authentication.jaas.JaasAuthenticationCallbackHandler[]
  log : org.apache.commons.logging.Log
  loginExceptionResolver : org.springframework.security.authentication.jaas.LoginExceptionResolver
  loginContextName : java.lang.String
  afterPropertiesSet() : void
  authenticate(auth : org.springframework.security.core.Authentication) : org.springframework.security.core.Authentication
  getAuthorities(principals : java.util.Set) : java.util.Set
  createLoginContext(handler : javax.security.auth.callback.CallbackHandler) : javax.security.auth.login.LoginContext
  handleLogout(event : org.springframework.security.core.session.SessionDestroyedEvent) : void
  logout(token : org.springframework.security.authentication.jaas.JaasAuthenticationToken, loginContext : javax.security.auth.login.LoginContext) : void
  onApplicationEvent(event : org.springframework.security.core.session.SessionDestroyedEvent) : void
  publishFailureEvent(token : org.springframework.security.authentication.UsernamePasswordAuthenticationToken, ase : org.springframework.security.core.AuthenticationException) : void
  publishSuccessEvent(token : org.springframework.security.authentication.UsernamePasswordAuthenticationToken) : void
  getAuthorityGranters() : org.springframework.security.authentication.jaas.AuthorityGranter[]
  setAuthorityGranters(authorityGranters : org.springframework.security.authentication.jaas.AuthorityGranter[]) : void
  getCallbackHandlers() : org.springframework.security.authentication.jaas.JaasAuthenticationCallbackHandler[]
  setCallbackHandlers(callbackHandlers : org.springframework.security.authentication.jaas.JaasAuthenticationCallbackHandler[]) : void
  getLoginContextName() : java.lang.String
  setLoginContextName(loginContextName : java.lang.String) : void
  getLoginExceptionResolver() : org.springframework.security.authentication.jaas.LoginExceptionResolver
  setLoginExceptionResolver(loginExceptionResolver : org.springframework.security.authentication.jaas.LoginExceptionResolver) : void
  supports(aClass : java.lang.Class) : boolean
  setApplicationEventPublisher(applicationEventPublisher : org.springframework.context.ApplicationEventPublisher) : void
  getApplicationEventPublisher() : org.springframework.context.ApplicationEventPublisher
}
org.springframework.security.authentication.jaas.AbstractJaasAuthenticationProvider::afterPropertiesSet -- org.springframework.util.Assert::hasLength : Assert.hasLength(this.loginContextName,"loginContextName cannot be null or empty") 
org.springframework.security.authentication.jaas.AbstractJaasAuthenticationProvider::afterPropertiesSet -- org.springframework.util.Assert::notEmpty : Assert.notEmpty(this.authorityGranters,"authorityGranters cannot be null or empty") 
org.springframework.security.authentication.jaas.AbstractJaasAuthenticationProvider::afterPropertiesSet -- org.springframework.util.ObjectUtils::isEmpty : ObjectUtils.isEmpty(this.callbackHandlers) 
org.springframework.security.authentication.jaas.AbstractJaasAuthenticationProvider::afterPropertiesSet -- org.springframework.util.Assert::notNull : Assert.notNull(this.loginExceptionResolver,"loginExceptionResolver cannot be null") 
org.springframework.security.authentication.jaas.AbstractJaasAuthenticationProvider::authenticate -- org.springframework.security.authentication.jaas.LoginExceptionResolver::resolveException : this.loginExceptionResolver.resolveException(ex) 
org.springframework.security.authentication.jaas.AbstractJaasAuthenticationProvider::getAuthorities -- org.springframework.util.CollectionUtils::isEmpty : CollectionUtils.isEmpty(roles) 
org.springframework.security.authentication.jaas.AbstractJaasAuthenticationProvider::handleLogout -- org.springframework.security.core.session.SessionDestroyedEvent::getSecurityContexts : event.getSecurityContexts() 
org.springframework.security.authentication.jaas.AbstractJaasAuthenticationProvider::handleLogout -- org.apache.commons.logging.Log::debug : this.log.debug("The destroyed session has no SecurityContexts") 
org.springframework.security.authentication.jaas.AbstractJaasAuthenticationProvider::handleLogout -- org.apache.commons.logging.Log::warn : this.log.warn("Error error logging out of LoginContext",ex) 
org.springframework.security.authentication.jaas.AbstractJaasAuthenticationProvider::logout -- org.apache.commons.logging.Log::debug : this.log.debug(LogMessage.of(()->"Logging principal: ["+token.getPrincipal()+"] out of LoginContext")) 
org.springframework.security.authentication.jaas.AbstractJaasAuthenticationProvider::logout -- org.springframework.core.log.LogMessage::of : LogMessage.of(()->"Logging principal: ["+token.getPrincipal()+"] out of LoginContext") 
org.springframework.security.authentication.jaas.AbstractJaasAuthenticationProvider::logout -- org.springframework.security.authentication.jaas.JaasAuthenticationToken::getPrincipal : token.getPrincipal() 
org.springframework.security.authentication.jaas.AbstractJaasAuthenticationProvider::logout -- javax.security.auth.login.LoginContext::logout : loginContext.logout() 
org.springframework.security.authentication.jaas.AbstractJaasAuthenticationProvider::logout -- org.apache.commons.logging.Log::debug : this.log.debug(LogMessage.of(()->"Cannot logout principal: ["+token.getPrincipal()+"] from LoginContext. The LoginContext is unavailable")) 
org.springframework.security.authentication.jaas.AbstractJaasAuthenticationProvider::logout -- org.springframework.core.log.LogMessage::of : LogMessage.of(()->"Cannot logout principal: ["+token.getPrincipal()+"] from LoginContext. The LoginContext is unavailable") 
org.springframework.security.authentication.jaas.AbstractJaasAuthenticationProvider::logout -- org.springframework.security.authentication.jaas.JaasAuthenticationToken::getPrincipal : token.getPrincipal() 
org.springframework.security.authentication.jaas.AbstractJaasAuthenticationProvider::publishFailureEvent -- org.springframework.context.ApplicationEventPublisher::publishEvent : this.applicationEventPublisher.publishEvent(newJaasAuthenticationFailedEvent(token,ase)) 
org.springframework.security.authentication.jaas.AbstractJaasAuthenticationProvider::publishSuccessEvent -- org.springframework.context.ApplicationEventPublisher::publishEvent : this.applicationEventPublisher.publishEvent(newJaasAuthenticationSuccessEvent(token)) 
class InternalCallbackHandler  implements org.springframework.security.authentication.jaas.CallbackHandler  {
  authentication : org.springframework.security.authentication.jaas.Authentication
  InternalCallbackHandler(authentication : org.springframework.security.authentication.jaas.Authentication) : None
  handle(callbacks : org.springframework.security.authentication.jaas.Callback[]) : void
}
interface AuthorityGranter    {
  grant(principal : java.security.Principal) : java.util.Set
}
class DefaultJaasAuthenticationProvider extends org.springframework.security.authentication.jaas.AbstractJaasAuthenticationProvider   {
  configuration : javax.security.auth.login.Configuration
  afterPropertiesSet() : void
  createLoginContext(handler : javax.security.auth.callback.CallbackHandler) : javax.security.auth.login.LoginContext
  getConfiguration() : javax.security.auth.login.Configuration
  setConfiguration(configuration : javax.security.auth.login.Configuration) : void
}
org.springframework.security.authentication.jaas.DefaultJaasAuthenticationProvider::afterPropertiesSet -- org.springframework.util.Assert::notNull : Assert.notNull(this.configuration,"configuration cannot be null.") 
class DefaultLoginExceptionResolver  implements org.springframework.security.authentication.jaas.LoginExceptionResolver  {
  resolveException(ex : javax.security.auth.login.LoginException) : org.springframework.security.core.AuthenticationException
}
org.springframework.security.authentication.jaas.DefaultLoginExceptionResolver::resolveException -- javax.security.auth.login.LoginException::getMessage : ex.getMessage() 
interface JaasAuthenticationCallbackHandler    {
  handle(callback : javax.security.auth.callback.Callback, auth : org.springframework.security.core.Authentication) : void
}
class JaasAuthenticationProvider extends org.springframework.security.authentication.jaas.AbstractJaasAuthenticationProvider   {
  log : org.apache.commons.logging.Log
  loginConfig : org.springframework.core.io.Resource
  refreshConfigurationOnStartup : boolean
  afterPropertiesSet() : void
  createLoginContext(handler : javax.security.auth.callback.CallbackHandler) : javax.security.auth.login.LoginContext
  configureJaas(loginConfig : org.springframework.core.io.Resource) : void
  configureJaasUsingLoop() : void
  convertLoginConfigToUrl() : java.lang.String
  publishFailureEvent(token : org.springframework.security.authentication.UsernamePasswordAuthenticationToken, ase : org.springframework.security.core.AuthenticationException) : void
  getLoginConfig() : org.springframework.core.io.Resource
  setLoginConfig(loginConfig : org.springframework.core.io.Resource) : void
  setRefreshConfigurationOnStartup(refresh : boolean) : void
}
org.springframework.security.authentication.jaas.JaasAuthenticationProvider::afterPropertiesSet -- org.springframework.util.Assert::hasLength : Assert.hasLength(getLoginContextName(),()->"loginContextName must be set on "+getClass()) 
org.springframework.security.authentication.jaas.JaasAuthenticationProvider::afterPropertiesSet -- org.springframework.util.Assert::notNull : Assert.notNull(this.loginConfig,()->"loginConfig must be set on "+getClass()) 
org.springframework.security.authentication.jaas.JaasAuthenticationProvider::afterPropertiesSet -- org.springframework.util.Assert::notNull : Assert.notNull(Configuration.getConfiguration(),"As per https://java.sun.com/j2se/1.5.0/docs/api/javax/security/auth/login/Configuration.html "+"\"If a Configuration object was set via the Configuration.setConfiguration method, then that object is "+"returned. Otherwise, a default Configuration object is returned\". Your JRE returned null to "+"Configuration.getConfiguration().") 
org.springframework.security.authentication.jaas.JaasAuthenticationProvider::afterPropertiesSet -- javax.security.auth.login.Configuration::getConfiguration : Configuration.getConfiguration() 
org.springframework.security.authentication.jaas.JaasAuthenticationProvider::configureJaas -- javax.security.auth.login.Configuration::getConfiguration : Configuration.getConfiguration().refresh() 
org.springframework.security.authentication.jaas.JaasAuthenticationProvider::configureJaas -- javax.security.auth.login.Configuration::getConfiguration : Configuration.getConfiguration() 
org.springframework.security.authentication.jaas.JaasAuthenticationProvider::configureJaasUsingLoop -- java.security.Security::getProperty : Security.getProperty(prefix+n) 
org.springframework.security.authentication.jaas.JaasAuthenticationProvider::configureJaasUsingLoop -- org.apache.commons.logging.Log::debug : log.debug(LogMessage.format("Setting security property [%s] to: %s",key,loginConfigUrl)) 
org.springframework.security.authentication.jaas.JaasAuthenticationProvider::configureJaasUsingLoop -- org.springframework.core.log.LogMessage::format : LogMessage.format("Setting security property [%s] to: %s",key,loginConfigUrl) 
org.springframework.security.authentication.jaas.JaasAuthenticationProvider::configureJaasUsingLoop -- java.security.Security::setProperty : Security.setProperty(key,loginConfigUrl) 
org.springframework.security.authentication.jaas.JaasAuthenticationProvider::convertLoginConfigToUrl -- org.springframework.core.io.Resource::getFile : this.loginConfig.getFile().getAbsolutePath().replace(File.separatorChar,'/') 
org.springframework.security.authentication.jaas.JaasAuthenticationProvider::convertLoginConfigToUrl -- org.springframework.core.io.Resource::getFile : this.loginConfig.getFile().getAbsolutePath() 
org.springframework.security.authentication.jaas.JaasAuthenticationProvider::convertLoginConfigToUrl -- org.springframework.core.io.Resource::getFile : this.loginConfig.getFile() 
org.springframework.security.authentication.jaas.JaasAuthenticationProvider::convertLoginConfigToUrl -- org.springframework.security.authentication.jaas.JaasAuthenticationProvider::newURL : newURL("file","",loginConfigPath).toString() 
org.springframework.security.authentication.jaas.JaasAuthenticationProvider::convertLoginConfigToUrl -- org.springframework.core.io.Resource::getURL : this.loginConfig.getURL().toString() 
org.springframework.security.authentication.jaas.JaasAuthenticationProvider::convertLoginConfigToUrl -- org.springframework.core.io.Resource::getURL : this.loginConfig.getURL() 
org.springframework.security.authentication.jaas.JaasAuthenticationProvider::publishFailureEvent -- org.springframework.security.authentication.jaas.JaasAuthenticationProvider::getApplicationEventPublisher : getApplicationEventPublisher().publishEvent(newJaasAuthenticationFailedEvent(token,ase)) 
class JaasAuthenticationToken extends org.springframework.security.authentication.UsernamePasswordAuthenticationToken   {
  serialVersionUID : long
  loginContext : javax.security.auth.login.LoginContext
  JaasAuthenticationToken(principal : java.lang.Object, credentials : java.lang.Object, loginContext : javax.security.auth.login.LoginContext) : None
  JaasAuthenticationToken(principal : java.lang.Object, credentials : java.lang.Object, authorities : java.util.List, loginContext : javax.security.auth.login.LoginContext) : None
  getLoginContext() : javax.security.auth.login.LoginContext
}
class JaasGrantedAuthority  implements org.springframework.security.core.GrantedAuthority  {
  serialVersionUID : long
  role : java.lang.String
  principal : java.security.Principal
  JaasGrantedAuthority(role : java.lang.String, principal : java.security.Principal) : None
  getPrincipal() : java.security.Principal
  getAuthority() : java.lang.String
  equals(obj : java.lang.Object) : boolean
  hashCode() : int
  toString() : java.lang.String
}
org.springframework.security.authentication.jaas.JaasGrantedAuthority::JaasGrantedAuthority -- org.springframework.util.Assert::notNull : Assert.notNull(role,"role cannot be null") 
org.springframework.security.authentication.jaas.JaasGrantedAuthority::JaasGrantedAuthority -- org.springframework.util.Assert::notNull : Assert.notNull(principal,"principal cannot be null") 
org.springframework.security.authentication.jaas.JaasGrantedAuthority::equals -- java.lang.String::equals : this.role.equals(jga.getAuthority()) 
org.springframework.security.authentication.jaas.JaasGrantedAuthority::equals -- java.security.Principal::equals : this.principal.equals(jga.getPrincipal()) 
org.springframework.security.authentication.jaas.JaasGrantedAuthority::hashCode -- java.security.Principal::hashCode : this.principal.hashCode() 
org.springframework.security.authentication.jaas.JaasGrantedAuthority::hashCode -- java.lang.String::hashCode : this.role.hashCode() 
class JaasNameCallbackHandler  implements org.springframework.security.authentication.jaas.JaasAuthenticationCallbackHandler  {
  handle(callback : javax.security.auth.callback.Callback, authentication : org.springframework.security.core.Authentication) : void
  getUserName(authentication : org.springframework.security.core.Authentication) : java.lang.String
}
org.springframework.security.authentication.jaas.JaasNameCallbackHandler::getUserName -- org.springframework.security.core.Authentication::getPrincipal : authentication.getPrincipal() 
class JaasPasswordCallbackHandler  implements org.springframework.security.authentication.jaas.JaasAuthenticationCallbackHandler  {
  handle(callback : javax.security.auth.callback.Callback, auth : org.springframework.security.core.Authentication) : void
}
org.springframework.security.authentication.jaas.JaasPasswordCallbackHandler::handle -- org.springframework.security.core.Authentication::getCredentials : auth.getCredentials().toString().toCharArray() 
org.springframework.security.authentication.jaas.JaasPasswordCallbackHandler::handle -- org.springframework.security.core.Authentication::getCredentials : auth.getCredentials().toString() 
org.springframework.security.authentication.jaas.JaasPasswordCallbackHandler::handle -- org.springframework.security.core.Authentication::getCredentials : auth.getCredentials() 
interface LoginExceptionResolver    {
  resolveException(ex : javax.security.auth.login.LoginException) : org.springframework.security.core.AuthenticationException
}
class SecurityContextLoginModule  implements javax.security.auth.spi.LoginModule  {
  log : org.apache.commons.logging.Log
  securityContextHolderStrategy : org.springframework.security.core.context.SecurityContextHolderStrategy
  authen : org.springframework.security.core.Authentication
  subject : javax.security.auth.Subject
  ignoreMissingAuthentication : boolean
  abort() : boolean
  commit() : boolean
  setSecurityContextHolderStrategy(securityContextHolderStrategy : org.springframework.security.core.context.SecurityContextHolderStrategy) : void
  getAuthentication() : org.springframework.security.core.Authentication
  getSubject() : javax.security.auth.Subject
  initialize(subject : javax.security.auth.Subject, callbackHandler : javax.security.auth.callback.CallbackHandler, sharedState : java.util.Map, options : java.util.Map) : void
  login() : boolean
  logout() : boolean
}
org.springframework.security.authentication.jaas.SecurityContextLoginModule::commit -- javax.security.auth.Subject::getPrincipals : this.subject.getPrincipals().add(this.authen) 
org.springframework.security.authentication.jaas.SecurityContextLoginModule::commit -- javax.security.auth.Subject::getPrincipals : this.subject.getPrincipals() 
org.springframework.security.authentication.jaas.SecurityContextLoginModule::setSecurityContextHolderStrategy -- org.springframework.util.Assert::notNull : Assert.notNull(securityContextHolderStrategy,"securityContextHolderStrategy cannot be null") 
org.springframework.security.authentication.jaas.SecurityContextLoginModule::initialize -- java.util.Map::get : options.get("ignoreMissingAuthentication") 
org.springframework.security.authentication.jaas.SecurityContextLoginModule::login -- org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : this.securityContextHolderStrategy.getContext().getAuthentication() 
org.springframework.security.authentication.jaas.SecurityContextLoginModule::login -- org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : this.securityContextHolderStrategy.getContext() 
org.springframework.security.authentication.jaas.SecurityContextLoginModule::login -- org.apache.commons.logging.Log::warn : log.warn(msg) 
org.springframework.security.authentication.jaas.SecurityContextLoginModule::logout -- javax.security.auth.Subject::getPrincipals : this.subject.getPrincipals().remove(this.authen) 
org.springframework.security.authentication.jaas.SecurityContextLoginModule::logout -- javax.security.auth.Subject::getPrincipals : this.subject.getPrincipals() 
}
package ott {
package reactive {
class InMemoryReactiveOneTimeTokenService  implements org.springframework.security.authentication.ott.reactive.ReactiveOneTimeTokenService  {
  oneTimeTokenService : org.springframework.security.authentication.ott.InMemoryOneTimeTokenService
  generate(request : org.springframework.security.authentication.ott.GenerateOneTimeTokenRequest) : reactor.core.publisher.Mono
  consume(authenticationToken : org.springframework.security.authentication.ott.OneTimeTokenAuthenticationToken) : reactor.core.publisher.Mono
  setClock(clock : java.time.Clock) : void
}
org.springframework.security.authentication.ott.reactive.InMemoryReactiveOneTimeTokenService::generate -- reactor.core.publisher.Mono::just : Mono.just(request).map(this.oneTimeTokenService::generate) 
org.springframework.security.authentication.ott.reactive.InMemoryReactiveOneTimeTokenService::generate -- reactor.core.publisher.Mono::just : Mono.just(request) 
org.springframework.security.authentication.ott.reactive.InMemoryReactiveOneTimeTokenService::consume -- reactor.core.publisher.Mono::just : Mono.just(authenticationToken).mapNotNull(this.oneTimeTokenService::consume) 
org.springframework.security.authentication.ott.reactive.InMemoryReactiveOneTimeTokenService::consume -- reactor.core.publisher.Mono::just : Mono.just(authenticationToken) 
org.springframework.security.authentication.ott.reactive.InMemoryReactiveOneTimeTokenService::setClock -- org.springframework.util.Assert::notNull : Assert.notNull(clock,"clock cannot be null") 
org.springframework.security.authentication.ott.reactive.InMemoryReactiveOneTimeTokenService::setClock -- org.springframework.security.authentication.ott.InMemoryOneTimeTokenService::setClock : this.oneTimeTokenService.setClock(clock) 
class OneTimeTokenReactiveAuthenticationManager  implements org.springframework.security.authentication.ReactiveAuthenticationManager  {
  oneTimeTokenService : org.springframework.security.authentication.ott.reactive.ReactiveOneTimeTokenService
  userDetailsService : org.springframework.security.core.userdetails.ReactiveUserDetailsService
  OneTimeTokenReactiveAuthenticationManager(oneTimeTokenService : org.springframework.security.authentication.ott.reactive.ReactiveOneTimeTokenService, userDetailsService : org.springframework.security.core.userdetails.ReactiveUserDetailsService) : None
  authenticate(authentication : org.springframework.security.core.Authentication) : reactor.core.publisher.Mono
  onSuccess(token : org.springframework.security.authentication.ott.OneTimeTokenAuthenticationToken) : java.util.function.Function
}
org.springframework.security.authentication.ott.reactive.OneTimeTokenReactiveAuthenticationManager::OneTimeTokenReactiveAuthenticationManager -- org.springframework.util.Assert::notNull : Assert.notNull(oneTimeTokenService,"oneTimeTokenService cannot be null") 
org.springframework.security.authentication.ott.reactive.OneTimeTokenReactiveAuthenticationManager::OneTimeTokenReactiveAuthenticationManager -- org.springframework.util.Assert::notNull : Assert.notNull(userDetailsService,"userDetailsService cannot be null") 
org.springframework.security.authentication.ott.reactive.OneTimeTokenReactiveAuthenticationManager::authenticate -- reactor.core.publisher.Mono::empty : Mono.empty() 
org.springframework.security.authentication.ott.reactive.OneTimeTokenReactiveAuthenticationManager::authenticate -- org.springframework.security.authentication.ott.reactive.ReactiveOneTimeTokenService::consume : this.oneTimeTokenService.consume(otpAuthenticationToken).switchIfEmpty(Mono.defer(()->Mono.error(newInvalidOneTimeTokenException("Invalid token")))).flatMap((consumed)->this.userDetailsService.findByUsername(consumed.getUsername())).map(onSuccess(otpAuthenticationToken)) 
org.springframework.security.authentication.ott.reactive.OneTimeTokenReactiveAuthenticationManager::authenticate -- org.springframework.security.authentication.ott.reactive.ReactiveOneTimeTokenService::consume : this.oneTimeTokenService.consume(otpAuthenticationToken).switchIfEmpty(Mono.defer(()->Mono.error(newInvalidOneTimeTokenException("Invalid token")))).flatMap((consumed)->this.userDetailsService.findByUsername(consumed.getUsername())) 
org.springframework.security.authentication.ott.reactive.OneTimeTokenReactiveAuthenticationManager::authenticate -- org.springframework.security.authentication.ott.reactive.ReactiveOneTimeTokenService::consume : this.oneTimeTokenService.consume(otpAuthenticationToken).switchIfEmpty(Mono.defer(()->Mono.error(newInvalidOneTimeTokenException("Invalid token")))) 
org.springframework.security.authentication.ott.reactive.OneTimeTokenReactiveAuthenticationManager::authenticate -- org.springframework.security.authentication.ott.reactive.ReactiveOneTimeTokenService::consume : this.oneTimeTokenService.consume(otpAuthenticationToken) 
org.springframework.security.authentication.ott.reactive.OneTimeTokenReactiveAuthenticationManager::authenticate -- reactor.core.publisher.Mono::defer : Mono.defer(()->Mono.error(newInvalidOneTimeTokenException("Invalid token"))) 
org.springframework.security.authentication.ott.reactive.OneTimeTokenReactiveAuthenticationManager::authenticate -- reactor.core.publisher.Mono::error : Mono.error(newInvalidOneTimeTokenException("Invalid token")) 
org.springframework.security.authentication.ott.reactive.OneTimeTokenReactiveAuthenticationManager::authenticate -- org.springframework.security.core.userdetails.ReactiveUserDetailsService::findByUsername : this.userDetailsService.findByUsername(consumed.getUsername()) 
org.springframework.security.authentication.ott.reactive.OneTimeTokenReactiveAuthenticationManager::onSuccess -- org.springframework.security.authentication.ott.OneTimeTokenAuthenticationToken::authenticated : OneTimeTokenAuthenticationToken.authenticated(user,user.getAuthorities()) 
org.springframework.security.authentication.ott.reactive.OneTimeTokenReactiveAuthenticationManager::onSuccess -- org.springframework.security.authentication.ott.OneTimeTokenAuthenticationToken::getDetails : token.getDetails() 
interface ReactiveOneTimeTokenService    {
  generate(request : org.springframework.security.authentication.ott.GenerateOneTimeTokenRequest) : reactor.core.publisher.Mono
  consume(authenticationToken : org.springframework.security.authentication.ott.OneTimeTokenAuthenticationToken) : reactor.core.publisher.Mono
}
}
class DefaultOneTimeToken  implements org.springframework.security.authentication.ott.OneTimeToken  {
  serialVersionUID : long
  token : java.lang.String
  username : java.lang.String
  expireAt : java.time.Instant
  DefaultOneTimeToken(token : java.lang.String, username : java.lang.String, expireAt : java.time.Instant) : None
  getTokenValue() : java.lang.String
  getUsername() : java.lang.String
  getExpiresAt() : java.time.Instant
}
org.springframework.security.authentication.ott.DefaultOneTimeToken::DefaultOneTimeToken -- org.springframework.util.Assert::hasText : Assert.hasText(token,"token cannot be empty") 
org.springframework.security.authentication.ott.DefaultOneTimeToken::DefaultOneTimeToken -- org.springframework.util.Assert::hasText : Assert.hasText(username,"username cannot be empty") 
org.springframework.security.authentication.ott.DefaultOneTimeToken::DefaultOneTimeToken -- org.springframework.util.Assert::notNull : Assert.notNull(expireAt,"expireAt cannot be null") 
class GenerateOneTimeTokenRequest    {
  DEFAULT_EXPIRES_IN : java.time.Duration
  username : java.lang.String
  expiresIn : java.time.Duration
  GenerateOneTimeTokenRequest(username : java.lang.String) : None
  GenerateOneTimeTokenRequest(username : java.lang.String, expiresIn : java.time.Duration) : None
  getUsername() : java.lang.String
  getExpiresIn() : java.time.Duration
}
org.springframework.security.authentication.ott.GenerateOneTimeTokenRequest::GenerateOneTimeTokenRequest -- org.springframework.util.Assert::hasText : Assert.hasText(username,"username cannot be empty") 
org.springframework.security.authentication.ott.GenerateOneTimeTokenRequest::GenerateOneTimeTokenRequest -- org.springframework.util.Assert::notNull : Assert.notNull(expiresIn,"expiresIn cannot be null") 
class InMemoryOneTimeTokenService  implements org.springframework.security.authentication.ott.OneTimeTokenService  {
  oneTimeTokenByToken : java.util.Map
  clock : java.time.Clock
  generate(request : org.springframework.security.authentication.ott.GenerateOneTimeTokenRequest) : org.springframework.security.authentication.ott.OneTimeToken
  consume(authenticationToken : org.springframework.security.authentication.ott.OneTimeTokenAuthenticationToken) : org.springframework.security.authentication.ott.OneTimeToken
  cleanExpiredTokensIfNeeded() : void
  isExpired(ott : org.springframework.security.authentication.ott.OneTimeToken) : boolean
  setClock(clock : java.time.Clock) : void
}
org.springframework.security.authentication.ott.InMemoryOneTimeTokenService::generate -- java.util.UUID::randomUUID : UUID.randomUUID().toString() 
org.springframework.security.authentication.ott.InMemoryOneTimeTokenService::generate -- java.util.UUID::randomUUID : UUID.randomUUID() 
org.springframework.security.authentication.ott.InMemoryOneTimeTokenService::generate -- java.time.Clock::instant : this.clock.instant().plus(request.getExpiresIn()) 
org.springframework.security.authentication.ott.InMemoryOneTimeTokenService::generate -- java.time.Clock::instant : this.clock.instant() 
org.springframework.security.authentication.ott.InMemoryOneTimeTokenService::generate -- org.springframework.security.authentication.ott.GenerateOneTimeTokenRequest::getExpiresIn : request.getExpiresIn() 
org.springframework.security.authentication.ott.InMemoryOneTimeTokenService::generate -- org.springframework.security.authentication.ott.GenerateOneTimeTokenRequest::getUsername : request.getUsername() 
org.springframework.security.authentication.ott.InMemoryOneTimeTokenService::generate -- java.util.Map::put : this.oneTimeTokenByToken.put(token,ott) 
org.springframework.security.authentication.ott.InMemoryOneTimeTokenService::consume -- java.util.Map::remove : this.oneTimeTokenByToken.remove(authenticationToken.getTokenValue()) 
org.springframework.security.authentication.ott.InMemoryOneTimeTokenService::consume -- org.springframework.security.authentication.ott.OneTimeTokenAuthenticationToken::getTokenValue : authenticationToken.getTokenValue() 
org.springframework.security.authentication.ott.InMemoryOneTimeTokenService::cleanExpiredTokensIfNeeded -- java.util.Map::size : this.oneTimeTokenByToken.size() 
org.springframework.security.authentication.ott.InMemoryOneTimeTokenService::cleanExpiredTokensIfNeeded -- java.util.Map::entrySet : this.oneTimeTokenByToken.entrySet() 
org.springframework.security.authentication.ott.InMemoryOneTimeTokenService::cleanExpiredTokensIfNeeded -- java.util.Map::remove : this.oneTimeTokenByToken.remove(entry.getKey()) 
org.springframework.security.authentication.ott.InMemoryOneTimeTokenService::isExpired -- java.time.Clock::instant : this.clock.instant().isAfter(ott.getExpiresAt()) 
org.springframework.security.authentication.ott.InMemoryOneTimeTokenService::isExpired -- java.time.Clock::instant : this.clock.instant() 
org.springframework.security.authentication.ott.InMemoryOneTimeTokenService::isExpired -- org.springframework.security.authentication.ott.OneTimeToken::getExpiresAt : ott.getExpiresAt() 
org.springframework.security.authentication.ott.InMemoryOneTimeTokenService::setClock -- org.springframework.util.Assert::notNull : Assert.notNull(clock,"clock cannot be null") 
class InvalidOneTimeTokenException extends org.springframework.security.core.AuthenticationException   {
  serialVersionUID : long
  InvalidOneTimeTokenException(msg : java.lang.String) : None
}
class JdbcOneTimeTokenService  implements org.springframework.security.authentication.ott.OneTimeTokenService,DisposableBean,InitializingBean  {
  logger : org.apache.commons.logging.Log
  jdbcOperations : org.springframework.jdbc.core.JdbcOperations
  oneTimeTokenParametersMapper : java.util.function.Function
  oneTimeTokenRowMapper : org.springframework.jdbc.core.RowMapper
  clock : java.time.Clock
  taskScheduler : org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler
  DEFAULT_CLEANUP_CRON : java.lang.String
  TABLE_NAME : java.lang.String
  COLUMN_NAMES : java.lang.String
  SAVE_ONE_TIME_TOKEN_SQL : java.lang.String
  FILTER : java.lang.String
  DELETE_ONE_TIME_TOKEN_SQL : java.lang.String
  SELECT_ONE_TIME_TOKEN_SQL : java.lang.String
  DELETE_ONE_TIME_TOKENS_BY_EXPIRY_TIME_QUERY : java.lang.String
  JdbcOneTimeTokenService(jdbcOperations : org.springframework.jdbc.core.JdbcOperations) : None
  setCleanupCron(cleanupCron : java.lang.String) : void
  generate(request : org.springframework.security.authentication.ott.GenerateOneTimeTokenRequest) : org.springframework.security.authentication.ott.OneTimeToken
  insertOneTimeToken(oneTimeToken : org.springframework.security.authentication.ott.OneTimeToken) : void
  consume(authenticationToken : org.springframework.security.authentication.ott.OneTimeTokenAuthenticationToken) : org.springframework.security.authentication.ott.OneTimeToken
  isExpired(ott : org.springframework.security.authentication.ott.OneTimeToken) : boolean
  selectOneTimeToken(authenticationToken : org.springframework.security.authentication.ott.OneTimeTokenAuthenticationToken) : java.util.List
  deleteOneTimeToken(oneTimeToken : org.springframework.security.authentication.ott.OneTimeToken) : void
  createTaskScheduler(cleanupCron : java.lang.String) : org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler
  cleanupExpiredTokens() : void
  afterPropertiesSet() : void
  destroy() : void
  setClock(clock : java.time.Clock) : void
}
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::JdbcOneTimeTokenService -- org.springframework.util.Assert::notNull : Assert.notNull(jdbcOperations,"jdbcOperations cannot be null") 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::generate -- org.springframework.util.Assert::notNull : Assert.notNull(request,"generateOneTimeTokenRequest cannot be null") 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::generate -- java.util.UUID::randomUUID : UUID.randomUUID().toString() 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::generate -- java.util.UUID::randomUUID : UUID.randomUUID() 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::generate -- java.time.Clock::instant : this.clock.instant().plus(request.getExpiresIn()) 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::generate -- java.time.Clock::instant : this.clock.instant() 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::generate -- org.springframework.security.authentication.ott.GenerateOneTimeTokenRequest::getExpiresIn : request.getExpiresIn() 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::generate -- org.springframework.security.authentication.ott.GenerateOneTimeTokenRequest::getUsername : request.getUsername() 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::insertOneTimeToken -- java.util.function.Function::apply : this.oneTimeTokenParametersMapper.apply(oneTimeToken) 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::insertOneTimeToken -- org.springframework.jdbc.core.JdbcOperations::update : this.jdbcOperations.update(SAVE_ONE_TIME_TOKEN_SQL,pss) 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::consume -- org.springframework.util.Assert::notNull : Assert.notNull(authenticationToken,"authenticationToken cannot be null") 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::consume -- org.springframework.util.CollectionUtils::isEmpty : CollectionUtils.isEmpty(tokens) 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::isExpired -- java.time.Clock::instant : this.clock.instant().isAfter(ott.getExpiresAt()) 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::isExpired -- java.time.Clock::instant : this.clock.instant() 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::isExpired -- org.springframework.security.authentication.ott.OneTimeToken::getExpiresAt : ott.getExpiresAt() 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::selectOneTimeToken -- java.util.List::of : List.of(newSqlParameterValue(Types.VARCHAR,authenticationToken.getTokenValue())) 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::selectOneTimeToken -- org.springframework.security.authentication.ott.OneTimeTokenAuthenticationToken::getTokenValue : authenticationToken.getTokenValue() 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::selectOneTimeToken -- org.springframework.jdbc.core.JdbcOperations::query : this.jdbcOperations.query(SELECT_ONE_TIME_TOKEN_SQL,pss,this.oneTimeTokenRowMapper) 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::deleteOneTimeToken -- java.util.List::of : List.of(newSqlParameterValue(Types.VARCHAR,oneTimeToken.getTokenValue())) 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::deleteOneTimeToken -- org.springframework.security.authentication.ott.OneTimeToken::getTokenValue : oneTimeToken.getTokenValue() 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::deleteOneTimeToken -- org.springframework.jdbc.core.JdbcOperations::update : this.jdbcOperations.update(DELETE_ONE_TIME_TOKEN_SQL,pss) 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::createTaskScheduler -- org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler::setThreadNamePrefix : taskScheduler.setThreadNamePrefix("spring-one-time-tokens-") 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::createTaskScheduler -- org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler::initialize : taskScheduler.initialize() 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::createTaskScheduler -- org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler::schedule : taskScheduler.schedule(this::cleanupExpiredTokens,newCronTrigger(cleanupCron)) 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::cleanupExpiredTokens -- java.util.List::of : List.of(newSqlParameterValue(Types.TIMESTAMP,Timestamp.from(Instant.now()))) 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::cleanupExpiredTokens -- java.sql.Timestamp::from : Timestamp.from(Instant.now()) 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::cleanupExpiredTokens -- java.time.Instant::now : Instant.now() 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::cleanupExpiredTokens -- org.springframework.jdbc.core.JdbcOperations::update : this.jdbcOperations.update(DELETE_ONE_TIME_TOKENS_BY_EXPIRY_TIME_QUERY,pss) 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::cleanupExpiredTokens -- org.apache.commons.logging.Log::isDebugEnabled : this.logger.isDebugEnabled() 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::cleanupExpiredTokens -- org.apache.commons.logging.Log::debug : this.logger.debug("Cleaned up "+deletedCount+" expired tokens") 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::afterPropertiesSet -- org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler::afterPropertiesSet : this.taskScheduler.afterPropertiesSet() 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::destroy -- org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler::shutdown : this.taskScheduler.shutdown() 
org.springframework.security.authentication.ott.JdbcOneTimeTokenService::setClock -- org.springframework.util.Assert::notNull : Assert.notNull(clock,"clock cannot be null") 
class OneTimeTokenParametersMapper  implements org.springframework.security.authentication.ott.Function  {
  apply(oneTimeToken : org.springframework.security.authentication.ott.OneTimeToken) : org.springframework.security.authentication.ott.List
}
org.springframework.security.authentication.ott.OneTimeTokenParametersMapper::apply -- org.springframework.security.authentication.ott.OneTimeToken::getTokenValue : oneTimeToken.getTokenValue() 
org.springframework.security.authentication.ott.OneTimeTokenParametersMapper::apply -- org.springframework.security.authentication.ott.OneTimeToken::getUsername : oneTimeToken.getUsername() 
org.springframework.security.authentication.ott.OneTimeTokenParametersMapper::apply -- org.springframework.security.authentication.ott.Timestamp::from : Timestamp.from(oneTimeToken.getExpiresAt()) 
org.springframework.security.authentication.ott.OneTimeTokenParametersMapper::apply -- org.springframework.security.authentication.ott.OneTimeToken::getExpiresAt : oneTimeToken.getExpiresAt() 
class OneTimeTokenRowMapper  implements org.springframework.security.authentication.ott.RowMapper  {
  mapRow(rs : org.springframework.security.authentication.ott.ResultSet, rowNum : int) : org.springframework.security.authentication.ott.OneTimeToken
}
org.springframework.security.authentication.ott.OneTimeTokenRowMapper::mapRow -- org.springframework.security.authentication.ott.ResultSet::getString : rs.getString("token_value") 
org.springframework.security.authentication.ott.OneTimeTokenRowMapper::mapRow -- org.springframework.security.authentication.ott.ResultSet::getString : rs.getString("username") 
org.springframework.security.authentication.ott.OneTimeTokenRowMapper::mapRow -- org.springframework.security.authentication.ott.ResultSet::getTimestamp : rs.getTimestamp("expires_at").toInstant() 
org.springframework.security.authentication.ott.OneTimeTokenRowMapper::mapRow -- org.springframework.security.authentication.ott.ResultSet::getTimestamp : rs.getTimestamp("expires_at") 
interface OneTimeToken    {
  getTokenValue() : java.lang.String
  getUsername() : java.lang.String
  getExpiresAt() : java.time.Instant
}
class OneTimeTokenAuthenticationProvider  implements org.springframework.security.authentication.AuthenticationProvider  {
  oneTimeTokenService : org.springframework.security.authentication.ott.OneTimeTokenService
  userDetailsService : org.springframework.security.core.userdetails.UserDetailsService
  OneTimeTokenAuthenticationProvider(oneTimeTokenService : org.springframework.security.authentication.ott.OneTimeTokenService, userDetailsService : org.springframework.security.core.userdetails.UserDetailsService) : None
  authenticate(authentication : org.springframework.security.core.Authentication) : org.springframework.security.core.Authentication
  supports(authentication : java.lang.Class) : boolean
}
org.springframework.security.authentication.ott.OneTimeTokenAuthenticationProvider::OneTimeTokenAuthenticationProvider -- org.springframework.util.Assert::notNull : Assert.notNull(oneTimeTokenService,"oneTimeTokenService cannot be null") 
org.springframework.security.authentication.ott.OneTimeTokenAuthenticationProvider::OneTimeTokenAuthenticationProvider -- org.springframework.util.Assert::notNull : Assert.notNull(userDetailsService,"userDetailsService cannot be null") 
org.springframework.security.authentication.ott.OneTimeTokenAuthenticationProvider::authenticate -- org.springframework.security.authentication.ott.OneTimeTokenService::consume : this.oneTimeTokenService.consume(otpAuthenticationToken) 
org.springframework.security.authentication.ott.OneTimeTokenAuthenticationProvider::authenticate -- org.springframework.security.core.userdetails.UserDetailsService::loadUserByUsername : this.userDetailsService.loadUserByUsername(consumed.getUsername()) 
org.springframework.security.authentication.ott.OneTimeTokenAuthenticationProvider::authenticate -- org.springframework.security.authentication.ott.OneTimeTokenAuthenticationToken::authenticated : OneTimeTokenAuthenticationToken.authenticated(user,user.getAuthorities()) 
class OneTimeTokenAuthenticationToken extends org.springframework.security.authentication.AbstractAuthenticationToken   {
  serialVersionUID : long
  principal : java.lang.Object
  tokenValue : java.lang.String
  OneTimeTokenAuthenticationToken(principal : java.lang.Object, tokenValue : java.lang.String) : None
  OneTimeTokenAuthenticationToken(tokenValue : java.lang.String) : None
  OneTimeTokenAuthenticationToken(principal : java.lang.Object, authorities : java.util.Collection) : None
  unauthenticated(tokenValue : java.lang.String) : org.springframework.security.authentication.ott.OneTimeTokenAuthenticationToken
  unauthenticated(principal : java.lang.Object, tokenValue : java.lang.String) : org.springframework.security.authentication.ott.OneTimeTokenAuthenticationToken
  authenticated(principal : java.lang.Object, authorities : java.util.Collection) : org.springframework.security.authentication.ott.OneTimeTokenAuthenticationToken
  getTokenValue() : java.lang.String
  getCredentials() : java.lang.Object
  getPrincipal() : java.lang.Object
}
org.springframework.security.authentication.ott.OneTimeTokenAuthenticationToken::OneTimeTokenAuthenticationToken -- java.util.Collections::emptyList : Collections.emptyList() 
interface OneTimeTokenService    {
  generate(request : org.springframework.security.authentication.ott.GenerateOneTimeTokenRequest) : org.springframework.security.authentication.ott.OneTimeToken
  consume(authenticationToken : org.springframework.security.authentication.ott.OneTimeTokenAuthenticationToken) : org.springframework.security.authentication.ott.OneTimeToken
}
}
package password {
interface CompromisedPasswordChecker    {
  check(password : java.lang.String) : org.springframework.security.authentication.password.CompromisedPasswordDecision
}
class CompromisedPasswordDecision    {
  compromised : boolean
  CompromisedPasswordDecision(compromised : boolean) : None
  isCompromised() : boolean
}
class CompromisedPasswordException extends org.springframework.security.core.AuthenticationException   {
  serialVersionUID : long
  CompromisedPasswordException(message : java.lang.String) : None
  CompromisedPasswordException(message : java.lang.String, cause : java.lang.Throwable) : None
}
interface ReactiveCompromisedPasswordChecker    {
  check(password : java.lang.String) : reactor.core.publisher.Mono
}
}
class AbstractAuthenticationToken  implements org.springframework.security.authentication.Authentication,CredentialsContainer  {
  authorities : java.util.Collection
  details : java.lang.Object
  authenticated : boolean
  AbstractAuthenticationToken(authorities : java.util.Collection) : None
  getAuthorities() : java.util.Collection
  getName() : java.lang.String
  isAuthenticated() : boolean
  setAuthenticated(authenticated : boolean) : void
  getDetails() : java.lang.Object
  setDetails(details : java.lang.Object) : void
  eraseCredentials() : void
  eraseSecret(secret : java.lang.Object) : void
  equals(obj : java.lang.Object) : boolean
  hashCode() : int
  toString() : java.lang.String
}
org.springframework.security.authentication.AbstractAuthenticationToken::AbstractAuthenticationToken -- org.springframework.util.Assert::notNull : Assert.notNull(a,"Authorities collection cannot contain any null elements") 
org.springframework.security.authentication.AbstractAuthenticationToken::AbstractAuthenticationToken -- java.util.Collections::unmodifiableList : Collections.unmodifiableList(newArrayList<>(authorities)) 
org.springframework.security.authentication.AbstractAuthenticationToken::getName -- org.springframework.security.authentication.AbstractAuthenticationToken::getPrincipal : this.getPrincipal().toString() 
org.springframework.security.authentication.AbstractAuthenticationToken::equals -- java.util.Collection::equals : this.authorities.equals(test.authorities) 
org.springframework.security.authentication.AbstractAuthenticationToken::equals -- java.lang.Object::equals : this.details.equals(test.getDetails()) 
org.springframework.security.authentication.AbstractAuthenticationToken::equals -- org.springframework.security.authentication.AbstractAuthenticationToken::getCredentials : this.getCredentials().equals(test.getCredentials()) 
org.springframework.security.authentication.AbstractAuthenticationToken::equals -- org.springframework.security.authentication.AbstractAuthenticationToken::getPrincipal : this.getPrincipal().equals(test.getPrincipal()) 
org.springframework.security.authentication.AbstractAuthenticationToken::hashCode -- org.springframework.security.authentication.AbstractAuthenticationToken::getPrincipal : this.getPrincipal().hashCode() 
org.springframework.security.authentication.AbstractAuthenticationToken::hashCode -- org.springframework.security.authentication.AbstractAuthenticationToken::getCredentials : this.getCredentials().hashCode() 
org.springframework.security.authentication.AbstractAuthenticationToken::hashCode -- org.springframework.security.authentication.AbstractAuthenticationToken::getDetails : this.getDetails().hashCode() 
org.springframework.security.authentication.AbstractAuthenticationToken::toString -- org.springframework.security.authentication.AbstractAuthenticationToken::getClass : getClass().getSimpleName() 
class AbstractUserDetailsReactiveAuthenticationManager  implements org.springframework.security.authentication.ReactiveAuthenticationManager,MessageSourceAware  {
  logger : org.apache.commons.logging.Log
  messages : org.springframework.context.support.MessageSourceAccessor
  passwordEncoder : org.springframework.security.crypto.password.PasswordEncoder
  userDetailsPasswordService : org.springframework.security.core.userdetails.ReactiveUserDetailsPasswordService
  scheduler : reactor.core.scheduler.Scheduler
  preAuthenticationChecks : org.springframework.security.core.userdetails.UserDetailsChecker
  postAuthenticationChecks : org.springframework.security.core.userdetails.UserDetailsChecker
  compromisedPasswordChecker : org.springframework.security.authentication.password.ReactiveCompromisedPasswordChecker
  defaultPreAuthenticationChecks(user : org.springframework.security.core.userdetails.UserDetails) : void
  defaultPostAuthenticationChecks(user : org.springframework.security.core.userdetails.UserDetails) : void
  authenticate(authentication : org.springframework.security.core.Authentication) : reactor.core.publisher.Mono
  checkCompromisedPassword(password : java.lang.String) : reactor.core.publisher.Mono
  upgradeEncodingIfNecessary(userDetails : org.springframework.security.core.userdetails.UserDetails, presentedPassword : java.lang.String) : reactor.core.publisher.Mono
  createUsernamePasswordAuthenticationToken(userDetails : org.springframework.security.core.userdetails.UserDetails) : org.springframework.security.authentication.UsernamePasswordAuthenticationToken
  setPasswordEncoder(passwordEncoder : org.springframework.security.crypto.password.PasswordEncoder) : void
  setScheduler(scheduler : reactor.core.scheduler.Scheduler) : void
  setUserDetailsPasswordService(userDetailsPasswordService : org.springframework.security.core.userdetails.ReactiveUserDetailsPasswordService) : void
  setPostAuthenticationChecks(postAuthenticationChecks : org.springframework.security.core.userdetails.UserDetailsChecker) : void
  setMessageSource(messageSource : org.springframework.context.MessageSource) : void
  setCompromisedPasswordChecker(compromisedPasswordChecker : org.springframework.security.authentication.password.ReactiveCompromisedPasswordChecker) : void
  retrieveUser(username : java.lang.String) : reactor.core.publisher.Mono
}
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::defaultPreAuthenticationChecks -- org.springframework.security.core.userdetails.UserDetails::isAccountNonLocked : user.isAccountNonLocked() 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::defaultPreAuthenticationChecks -- org.apache.commons.logging.Log::debug : this.logger.debug("User account is locked") 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::defaultPreAuthenticationChecks -- org.springframework.context.support.MessageSourceAccessor::getMessage : this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.locked","User account is locked") 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::defaultPreAuthenticationChecks -- org.springframework.security.core.userdetails.UserDetails::isEnabled : user.isEnabled() 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::defaultPreAuthenticationChecks -- org.apache.commons.logging.Log::debug : this.logger.debug("User account is disabled") 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::defaultPreAuthenticationChecks -- org.springframework.context.support.MessageSourceAccessor::getMessage : this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.disabled","User is disabled") 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::defaultPreAuthenticationChecks -- org.springframework.security.core.userdetails.UserDetails::isAccountNonExpired : user.isAccountNonExpired() 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::defaultPreAuthenticationChecks -- org.apache.commons.logging.Log::debug : this.logger.debug("User account is expired") 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::defaultPreAuthenticationChecks -- org.springframework.context.support.MessageSourceAccessor::getMessage : this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.expired","User account has expired") 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::defaultPostAuthenticationChecks -- org.springframework.security.core.userdetails.UserDetails::isCredentialsNonExpired : user.isCredentialsNonExpired() 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::defaultPostAuthenticationChecks -- org.apache.commons.logging.Log::debug : this.logger.debug("User account credentials have expired") 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::defaultPostAuthenticationChecks -- org.springframework.context.support.MessageSourceAccessor::getMessage : this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.credentialsExpired","User credentials have expired") 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::authenticate -- org.springframework.security.core.Authentication::getName : authentication.getName() 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::authenticate -- org.springframework.security.core.Authentication::getCredentials : authentication.getCredentials() 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::authenticate -- org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::retrieveUser : retrieveUser(username).doOnNext(this.preAuthenticationChecks::check).publishOn(this.scheduler).filter((userDetails)->this.passwordEncoder.matches(presentedPassword,userDetails.getPassword())).switchIfEmpty(Mono.defer(()->Mono.error(newBadCredentialsException("Invalid Credentials")))).flatMap((userDetails)->checkCompromisedPassword(presentedPassword).thenReturn(userDetails)).flatMap((userDetails)->upgradeEncodingIfNecessary(userDetails,presentedPassword)).doOnNext(this.postAuthenticationChecks::check).map(this::createUsernamePasswordAuthenticationToken) 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::authenticate -- org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::retrieveUser : retrieveUser(username).doOnNext(this.preAuthenticationChecks::check).publishOn(this.scheduler).filter((userDetails)->this.passwordEncoder.matches(presentedPassword,userDetails.getPassword())).switchIfEmpty(Mono.defer(()->Mono.error(newBadCredentialsException("Invalid Credentials")))).flatMap((userDetails)->checkCompromisedPassword(presentedPassword).thenReturn(userDetails)).flatMap((userDetails)->upgradeEncodingIfNecessary(userDetails,presentedPassword)).doOnNext(this.postAuthenticationChecks::check) 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::authenticate -- org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::retrieveUser : retrieveUser(username).doOnNext(this.preAuthenticationChecks::check).publishOn(this.scheduler).filter((userDetails)->this.passwordEncoder.matches(presentedPassword,userDetails.getPassword())).switchIfEmpty(Mono.defer(()->Mono.error(newBadCredentialsException("Invalid Credentials")))).flatMap((userDetails)->checkCompromisedPassword(presentedPassword).thenReturn(userDetails)).flatMap((userDetails)->upgradeEncodingIfNecessary(userDetails,presentedPassword)) 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::authenticate -- org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::retrieveUser : retrieveUser(username).doOnNext(this.preAuthenticationChecks::check).publishOn(this.scheduler).filter((userDetails)->this.passwordEncoder.matches(presentedPassword,userDetails.getPassword())).switchIfEmpty(Mono.defer(()->Mono.error(newBadCredentialsException("Invalid Credentials")))).flatMap((userDetails)->checkCompromisedPassword(presentedPassword).thenReturn(userDetails)) 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::authenticate -- org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::retrieveUser : retrieveUser(username).doOnNext(this.preAuthenticationChecks::check).publishOn(this.scheduler).filter((userDetails)->this.passwordEncoder.matches(presentedPassword,userDetails.getPassword())).switchIfEmpty(Mono.defer(()->Mono.error(newBadCredentialsException("Invalid Credentials")))) 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::authenticate -- org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::retrieveUser : retrieveUser(username).doOnNext(this.preAuthenticationChecks::check).publishOn(this.scheduler).filter((userDetails)->this.passwordEncoder.matches(presentedPassword,userDetails.getPassword())) 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::authenticate -- org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::retrieveUser : retrieveUser(username).doOnNext(this.preAuthenticationChecks::check).publishOn(this.scheduler) 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::authenticate -- org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::retrieveUser : retrieveUser(username).doOnNext(this.preAuthenticationChecks::check) 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::authenticate -- org.springframework.security.crypto.password.PasswordEncoder::matches : this.passwordEncoder.matches(presentedPassword,userDetails.getPassword()) 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::authenticate -- reactor.core.publisher.Mono::defer : Mono.defer(()->Mono.error(newBadCredentialsException("Invalid Credentials"))) 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::authenticate -- reactor.core.publisher.Mono::error : Mono.error(newBadCredentialsException("Invalid Credentials")) 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::authenticate -- org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::checkCompromisedPassword : checkCompromisedPassword(presentedPassword).thenReturn(userDetails) 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::checkCompromisedPassword -- reactor.core.publisher.Mono::empty : Mono.empty() 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::checkCompromisedPassword -- org.springframework.security.authentication.password.ReactiveCompromisedPasswordChecker::check : this.compromisedPasswordChecker.check(password).filter(CompromisedPasswordDecision::isCompromised).flatMap((compromised)->Mono.error(newCompromisedPasswordException("The provided password is compromised, please change your password"))) 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::checkCompromisedPassword -- org.springframework.security.authentication.password.ReactiveCompromisedPasswordChecker::check : this.compromisedPasswordChecker.check(password).filter(CompromisedPasswordDecision::isCompromised) 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::checkCompromisedPassword -- org.springframework.security.authentication.password.ReactiveCompromisedPasswordChecker::check : this.compromisedPasswordChecker.check(password) 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::checkCompromisedPassword -- reactor.core.publisher.Mono::error : Mono.error(newCompromisedPasswordException("The provided password is compromised, please change your password")) 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::upgradeEncodingIfNecessary -- org.springframework.security.crypto.password.PasswordEncoder::upgradeEncoding : this.passwordEncoder.upgradeEncoding(userDetails.getPassword()) 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::upgradeEncodingIfNecessary -- org.springframework.security.core.userdetails.UserDetails::getPassword : userDetails.getPassword() 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::upgradeEncodingIfNecessary -- org.springframework.security.crypto.password.PasswordEncoder::encode : this.passwordEncoder.encode(presentedPassword) 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::upgradeEncodingIfNecessary -- org.springframework.security.core.userdetails.ReactiveUserDetailsPasswordService::updatePassword : this.userDetailsPasswordService.updatePassword(userDetails,newPassword) 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::upgradeEncodingIfNecessary -- reactor.core.publisher.Mono::just : Mono.just(userDetails) 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::createUsernamePasswordAuthenticationToken -- org.springframework.security.authentication.UsernamePasswordAuthenticationToken::authenticated : UsernamePasswordAuthenticationToken.authenticated(userDetails,userDetails.getPassword(),userDetails.getAuthorities()) 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::createUsernamePasswordAuthenticationToken -- org.springframework.security.core.userdetails.UserDetails::getPassword : userDetails.getPassword() 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::createUsernamePasswordAuthenticationToken -- org.springframework.security.core.userdetails.UserDetails::getAuthorities : userDetails.getAuthorities() 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::setPasswordEncoder -- org.springframework.util.Assert::notNull : Assert.notNull(passwordEncoder,"passwordEncoder cannot be null") 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::setScheduler -- org.springframework.util.Assert::notNull : Assert.notNull(scheduler,"scheduler cannot be null") 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::setPostAuthenticationChecks -- org.springframework.util.Assert::notNull : Assert.notNull(this.postAuthenticationChecks,"postAuthenticationChecks cannot be null") 
org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager::setMessageSource -- org.springframework.util.Assert::notNull : Assert.notNull(messageSource,"messageSource cannot be null") 
class AccountExpiredException extends org.springframework.security.authentication.AccountStatusException   {
  serialVersionUID : long
  AccountExpiredException(msg : java.lang.String) : None
  AccountExpiredException(msg : java.lang.String, cause : java.lang.Throwable) : None
}
class AccountStatusException extends org.springframework.security.core.AuthenticationException   {
  AccountStatusException(msg : java.lang.String) : None
  AccountStatusException(msg : java.lang.String, cause : java.lang.Throwable) : None
}
class AccountStatusUserDetailsChecker  implements org.springframework.security.authentication.UserDetailsChecker,MessageSourceAware  {
  logger : org.apache.commons.logging.Log
  messages : org.springframework.context.support.MessageSourceAccessor
  check(user : org.springframework.security.core.userdetails.UserDetails) : void
  setMessageSource(messageSource : org.springframework.context.MessageSource) : void
}
org.springframework.security.authentication.AccountStatusUserDetailsChecker::check -- org.springframework.security.core.userdetails.UserDetails::isAccountNonLocked : user.isAccountNonLocked() 
org.springframework.security.authentication.AccountStatusUserDetailsChecker::check -- org.apache.commons.logging.Log::debug : this.logger.debug("Failed to authenticate since user account is locked") 
org.springframework.security.authentication.AccountStatusUserDetailsChecker::check -- org.springframework.context.support.MessageSourceAccessor::getMessage : this.messages.getMessage("AccountStatusUserDetailsChecker.locked","User account is locked") 
org.springframework.security.authentication.AccountStatusUserDetailsChecker::check -- org.springframework.security.core.userdetails.UserDetails::isEnabled : user.isEnabled() 
org.springframework.security.authentication.AccountStatusUserDetailsChecker::check -- org.apache.commons.logging.Log::debug : this.logger.debug("Failed to authenticate since user account is disabled") 
org.springframework.security.authentication.AccountStatusUserDetailsChecker::check -- org.springframework.context.support.MessageSourceAccessor::getMessage : this.messages.getMessage("AccountStatusUserDetailsChecker.disabled","User is disabled") 
org.springframework.security.authentication.AccountStatusUserDetailsChecker::check -- org.springframework.security.core.userdetails.UserDetails::isAccountNonExpired : user.isAccountNonExpired() 
org.springframework.security.authentication.AccountStatusUserDetailsChecker::check -- org.apache.commons.logging.Log::debug : this.logger.debug("Failed to authenticate since user account is expired") 
org.springframework.security.authentication.AccountStatusUserDetailsChecker::check -- org.springframework.context.support.MessageSourceAccessor::getMessage : this.messages.getMessage("AccountStatusUserDetailsChecker.expired","User account has expired") 
org.springframework.security.authentication.AccountStatusUserDetailsChecker::check -- org.springframework.security.core.userdetails.UserDetails::isCredentialsNonExpired : user.isCredentialsNonExpired() 
org.springframework.security.authentication.AccountStatusUserDetailsChecker::check -- org.apache.commons.logging.Log::debug : this.logger.debug("Failed to authenticate since user account credentials have expired") 
org.springframework.security.authentication.AccountStatusUserDetailsChecker::check -- org.springframework.context.support.MessageSourceAccessor::getMessage : this.messages.getMessage("AccountStatusUserDetailsChecker.credentialsExpired","User credentials have expired") 
org.springframework.security.authentication.AccountStatusUserDetailsChecker::setMessageSource -- org.springframework.util.Assert::notNull : Assert.notNull(messageSource,"messageSource cannot be null") 
class AnonymousAuthenticationProvider  implements org.springframework.security.authentication.AuthenticationProvider,MessageSourceAware  {
  messages : org.springframework.context.support.MessageSourceAccessor
  key : java.lang.String
  AnonymousAuthenticationProvider(key : java.lang.String) : None
  authenticate(authentication : org.springframework.security.core.Authentication) : org.springframework.security.core.Authentication
  getKey() : java.lang.String
  setMessageSource(messageSource : org.springframework.context.MessageSource) : void
  supports(authentication : java.lang.Class) : boolean
}
org.springframework.security.authentication.AnonymousAuthenticationProvider::AnonymousAuthenticationProvider -- org.springframework.util.Assert::hasLength : Assert.hasLength(key,"A Key is required") 
org.springframework.security.authentication.AnonymousAuthenticationProvider::authenticate -- org.springframework.security.core.Authentication::getClass : authentication.getClass() 
org.springframework.security.authentication.AnonymousAuthenticationProvider::authenticate -- java.lang.String::hashCode : this.key.hashCode() 
org.springframework.security.authentication.AnonymousAuthenticationProvider::authenticate -- org.springframework.context.support.MessageSourceAccessor::getMessage : this.messages.getMessage("AnonymousAuthenticationProvider.incorrectKey","The presented AnonymousAuthenticationToken does not contain the expected key") 
org.springframework.security.authentication.AnonymousAuthenticationProvider::setMessageSource -- org.springframework.util.Assert::notNull : Assert.notNull(messageSource,"messageSource cannot be null") 
class AnonymousAuthenticationToken extends org.springframework.security.authentication.AbstractAuthenticationToken implements java.io.Serializable  {
  serialVersionUID : long
  principal : java.lang.Object
  keyHash : int
  AnonymousAuthenticationToken(key : java.lang.String, principal : java.lang.Object, authorities : java.util.Collection) : None
  AnonymousAuthenticationToken(keyHash : java.lang.Integer, principal : java.lang.Object, authorities : java.util.Collection) : None
  extractKeyHash(key : java.lang.String) : java.lang.Integer
  equals(obj : java.lang.Object) : boolean
  hashCode() : int
  getCredentials() : java.lang.Object
  getKeyHash() : int
  getPrincipal() : java.lang.Object
}
org.springframework.security.authentication.AnonymousAuthenticationToken::AnonymousAuthenticationToken -- org.springframework.util.Assert::isTrue : Assert.isTrue(principal!=null&&!"".equals(principal),"principal cannot be null or empty") 
org.springframework.security.authentication.AnonymousAuthenticationToken::AnonymousAuthenticationToken -- org.springframework.util.Assert::notEmpty : Assert.notEmpty(authorities,"authorities cannot be null or empty") 
org.springframework.security.authentication.AnonymousAuthenticationToken::extractKeyHash -- org.springframework.util.Assert::hasLength : Assert.hasLength(key,"key cannot be empty or null") 
org.springframework.security.authentication.AnonymousAuthenticationToken::extractKeyHash -- java.lang.String::hashCode : key.hashCode() 
class AuthenticationCredentialsNotFoundException extends org.springframework.security.core.AuthenticationException   {
  serialVersionUID : long
  AuthenticationCredentialsNotFoundException(msg : java.lang.String) : None
  AuthenticationCredentialsNotFoundException(msg : java.lang.String, cause : java.lang.Throwable) : None
}
interface AuthenticationDetailsSource    {
  buildDetails(context : org.springframework.security.authentication.C) : org.springframework.security.authentication.T
}
interface AuthenticationEventPublisher    {
  publishAuthenticationSuccess(authentication : org.springframework.security.core.Authentication) : void
  publishAuthenticationFailure(exception : org.springframework.security.core.AuthenticationException, authentication : org.springframework.security.core.Authentication) : void
}
interface AuthenticationManager    {
  authenticate(authentication : org.springframework.security.core.Authentication) : org.springframework.security.core.Authentication
}
interface AuthenticationManagerResolver    {
  resolve(context : org.springframework.security.authentication.C) : org.springframework.security.authentication.AuthenticationManager
}
class AuthenticationObservationContext extends org.springframework.security.authentication.Observation.Context   {
  authenticationRequest : org.springframework.security.core.Authentication
  authenticationManager : java.lang.Class
  authenticationResult : org.springframework.security.core.Authentication
  getAuthenticationRequest() : org.springframework.security.core.Authentication
  setAuthenticationRequest(authenticationRequest : org.springframework.security.core.Authentication) : void
  getAuthenticationResult() : org.springframework.security.core.Authentication
  setAuthenticationResult(authenticationResult : org.springframework.security.core.Authentication) : void
  getAuthenticationManagerClass() : java.lang.Class
  setAuthenticationManagerClass(authenticationManagerClass : java.lang.Class) : void
}
org.springframework.security.authentication.AuthenticationObservationContext::setAuthenticationRequest -- org.springframework.util.Assert::notNull : Assert.notNull(authenticationRequest,"authenticationRequest cannot be null") 
org.springframework.security.authentication.AuthenticationObservationContext::setAuthenticationManagerClass -- org.springframework.util.Assert::notNull : Assert.notNull(authenticationManagerClass,"authenticationManagerClass class cannot be null") 
class AuthenticationObservationConvention  implements io.micrometer.observation.ObservationConvention  {
  OBSERVATION_NAME : java.lang.String
  getName() : java.lang.String
  getContextualName(context : org.springframework.security.authentication.AuthenticationObservationContext) : java.lang.String
  getLowCardinalityKeyValues(context : org.springframework.security.authentication.AuthenticationObservationContext) : io.micrometer.common.KeyValues
  getAuthenticationType(context : org.springframework.security.authentication.AuthenticationObservationContext) : java.lang.String
  getAuthenticationMethod(context : org.springframework.security.authentication.AuthenticationObservationContext) : java.lang.String
  getAuthenticationResult(context : org.springframework.security.authentication.AuthenticationObservationContext) : java.lang.String
  getAuthenticationFailureType(context : org.springframework.security.authentication.AuthenticationObservationContext) : java.lang.String
  supportsContext(context : org.springframework.security.authentication.Observation.Context) : boolean
}
org.springframework.security.authentication.AuthenticationObservationConvention::getContextualName -- org.springframework.security.authentication.AuthenticationObservationContext::getAuthenticationRequest : context.getAuthenticationRequest() 
org.springframework.security.authentication.AuthenticationObservationConvention::getContextualName -- org.springframework.security.authentication.AuthenticationObservationContext::getAuthenticationRequest : context.getAuthenticationRequest().getClass().getSimpleName() 
org.springframework.security.authentication.AuthenticationObservationConvention::getContextualName -- org.springframework.security.authentication.AuthenticationObservationContext::getAuthenticationRequest : context.getAuthenticationRequest().getClass() 
org.springframework.security.authentication.AuthenticationObservationConvention::getContextualName -- org.springframework.security.authentication.AuthenticationObservationContext::getAuthenticationRequest : context.getAuthenticationRequest() 
org.springframework.security.authentication.AuthenticationObservationConvention::getLowCardinalityKeyValues -- io.micrometer.common.KeyValues::of : KeyValues.of("authentication.request.type",getAuthenticationType(context)).and("authentication.method",getAuthenticationMethod(context)).and("authentication.result.type",getAuthenticationResult(context)).and("authentication.failure.type",getAuthenticationFailureType(context)) 
org.springframework.security.authentication.AuthenticationObservationConvention::getLowCardinalityKeyValues -- io.micrometer.common.KeyValues::of : KeyValues.of("authentication.request.type",getAuthenticationType(context)).and("authentication.method",getAuthenticationMethod(context)).and("authentication.result.type",getAuthenticationResult(context)) 
org.springframework.security.authentication.AuthenticationObservationConvention::getLowCardinalityKeyValues -- io.micrometer.common.KeyValues::of : KeyValues.of("authentication.request.type",getAuthenticationType(context)).and("authentication.method",getAuthenticationMethod(context)) 
org.springframework.security.authentication.AuthenticationObservationConvention::getLowCardinalityKeyValues -- io.micrometer.common.KeyValues::of : KeyValues.of("authentication.request.type",getAuthenticationType(context)) 
org.springframework.security.authentication.AuthenticationObservationConvention::getAuthenticationType -- org.springframework.security.authentication.AuthenticationObservationContext::getAuthenticationRequest : context.getAuthenticationRequest() 
org.springframework.security.authentication.AuthenticationObservationConvention::getAuthenticationType -- org.springframework.security.authentication.AuthenticationObservationContext::getAuthenticationRequest : context.getAuthenticationRequest().getClass().getSimpleName() 
org.springframework.security.authentication.AuthenticationObservationConvention::getAuthenticationType -- org.springframework.security.authentication.AuthenticationObservationContext::getAuthenticationRequest : context.getAuthenticationRequest().getClass() 
org.springframework.security.authentication.AuthenticationObservationConvention::getAuthenticationType -- org.springframework.security.authentication.AuthenticationObservationContext::getAuthenticationRequest : context.getAuthenticationRequest() 
org.springframework.security.authentication.AuthenticationObservationConvention::getAuthenticationMethod -- org.springframework.security.authentication.AuthenticationObservationContext::getAuthenticationManagerClass : context.getAuthenticationManagerClass() 
org.springframework.security.authentication.AuthenticationObservationConvention::getAuthenticationMethod -- org.springframework.security.authentication.AuthenticationObservationContext::getAuthenticationManagerClass : context.getAuthenticationManagerClass().getSimpleName() 
org.springframework.security.authentication.AuthenticationObservationConvention::getAuthenticationMethod -- org.springframework.security.authentication.AuthenticationObservationContext::getAuthenticationManagerClass : context.getAuthenticationManagerClass() 
org.springframework.security.authentication.AuthenticationObservationConvention::getAuthenticationResult -- org.springframework.security.authentication.AuthenticationObservationContext::getAuthenticationResult : context.getAuthenticationResult() 
org.springframework.security.authentication.AuthenticationObservationConvention::getAuthenticationResult -- org.springframework.security.authentication.AuthenticationObservationContext::getAuthenticationResult : context.getAuthenticationResult().getClass().getSimpleName() 
org.springframework.security.authentication.AuthenticationObservationConvention::getAuthenticationResult -- org.springframework.security.authentication.AuthenticationObservationContext::getAuthenticationResult : context.getAuthenticationResult().getClass() 
org.springframework.security.authentication.AuthenticationObservationConvention::getAuthenticationResult -- org.springframework.security.authentication.AuthenticationObservationContext::getAuthenticationResult : context.getAuthenticationResult() 
org.springframework.security.authentication.AuthenticationObservationConvention::getAuthenticationFailureType -- org.springframework.security.authentication.AuthenticationObservationContext::getError : context.getError() 
org.springframework.security.authentication.AuthenticationObservationConvention::getAuthenticationFailureType -- org.springframework.security.authentication.AuthenticationObservationContext::getError : context.getError().getClass().getSimpleName() 
org.springframework.security.authentication.AuthenticationObservationConvention::getAuthenticationFailureType -- org.springframework.security.authentication.AuthenticationObservationContext::getError : context.getError().getClass() 
org.springframework.security.authentication.AuthenticationObservationConvention::getAuthenticationFailureType -- org.springframework.security.authentication.AuthenticationObservationContext::getError : context.getError() 
interface AuthenticationProvider    {
  authenticate(authentication : org.springframework.security.core.Authentication) : org.springframework.security.core.Authentication
  supports(authentication : java.lang.Class) : boolean
}
class AuthenticationServiceException extends org.springframework.security.core.AuthenticationException   {
  serialVersionUID : long
  AuthenticationServiceException(msg : java.lang.String) : None
  AuthenticationServiceException(msg : java.lang.String, cause : java.lang.Throwable) : None
}
interface AuthenticationTrustResolver    {
  isAnonymous(authentication : org.springframework.security.core.Authentication) : boolean
  isRememberMe(authentication : org.springframework.security.core.Authentication) : boolean
  isFullyAuthenticated(authentication : org.springframework.security.core.Authentication) : boolean
  isAuthenticated(authentication : org.springframework.security.core.Authentication) : boolean
}
org.springframework.security.authentication.AuthenticationTrustResolver::isAuthenticated -- org.springframework.security.core.Authentication::isAuthenticated : authentication.isAuthenticated() 
class AuthenticationTrustResolverImpl  implements org.springframework.security.authentication.AuthenticationTrustResolver  {
  anonymousClass : java.lang.Class
  rememberMeClass : java.lang.Class
  getAnonymousClass() : java.lang.Class
  getRememberMeClass() : java.lang.Class
  isAnonymous(authentication : org.springframework.security.core.Authentication) : boolean
  isRememberMe(authentication : org.springframework.security.core.Authentication) : boolean
  setAnonymousClass(anonymousClass : java.lang.Class) : void
  setRememberMeClass(rememberMeClass : java.lang.Class) : void
}
org.springframework.security.authentication.AuthenticationTrustResolverImpl::isAnonymous -- java.lang.Class::isAssignableFrom : this.anonymousClass.isAssignableFrom(authentication.getClass()) 
org.springframework.security.authentication.AuthenticationTrustResolverImpl::isAnonymous -- org.springframework.security.core.Authentication::getClass : authentication.getClass() 
org.springframework.security.authentication.AuthenticationTrustResolverImpl::isRememberMe -- java.lang.Class::isAssignableFrom : this.rememberMeClass.isAssignableFrom(authentication.getClass()) 
org.springframework.security.authentication.AuthenticationTrustResolverImpl::isRememberMe -- org.springframework.security.core.Authentication::getClass : authentication.getClass() 
class BadCredentialsException extends org.springframework.security.core.AuthenticationException   {
  serialVersionUID : long
  BadCredentialsException(msg : java.lang.String) : None
  BadCredentialsException(msg : java.lang.String, cause : java.lang.Throwable) : None
}
class CachingUserDetailsService  implements org.springframework.security.core.userdetails.UserDetailsService  {
  userCache : org.springframework.security.core.userdetails.UserCache
  delegate : org.springframework.security.core.userdetails.UserDetailsService
  CachingUserDetailsService(delegate : org.springframework.security.core.userdetails.UserDetailsService) : None
  getUserCache() : org.springframework.security.core.userdetails.UserCache
  setUserCache(userCache : org.springframework.security.core.userdetails.UserCache) : void
  loadUserByUsername(username : java.lang.String) : org.springframework.security.core.userdetails.UserDetails
}
org.springframework.security.authentication.CachingUserDetailsService::loadUserByUsername -- org.springframework.security.core.userdetails.UserCache::getUserFromCache : this.userCache.getUserFromCache(username) 
org.springframework.security.authentication.CachingUserDetailsService::loadUserByUsername -- org.springframework.security.core.userdetails.UserDetailsService::loadUserByUsername : this.delegate.loadUserByUsername(username) 
org.springframework.security.authentication.CachingUserDetailsService::loadUserByUsername -- org.springframework.util.Assert::notNull : Assert.notNull(user,()->"UserDetailsService "+this.delegate+" returned null for username "+username+". "+"This is an interface contract violation") 
org.springframework.security.authentication.CachingUserDetailsService::loadUserByUsername -- org.springframework.security.core.userdetails.UserCache::putUserInCache : this.userCache.putUserInCache(user) 
class CredentialsExpiredException extends org.springframework.security.authentication.AccountStatusException   {
  serialVersionUID : long
  CredentialsExpiredException(msg : java.lang.String) : None
  CredentialsExpiredException(msg : java.lang.String, cause : java.lang.Throwable) : None
}
class DefaultAuthenticationEventPublisher  implements org.springframework.security.authentication.AuthenticationEventPublisher,ApplicationEventPublisherAware  {
  logger : org.apache.commons.logging.Log
  applicationEventPublisher : org.springframework.context.ApplicationEventPublisher
  exceptionMappings : java.util.HashMap
  defaultAuthenticationFailureEventConstructor : java.lang.reflect.Constructor
  DefaultAuthenticationEventPublisher() : None
  DefaultAuthenticationEventPublisher(applicationEventPublisher : org.springframework.context.ApplicationEventPublisher) : None
  publishAuthenticationSuccess(authentication : org.springframework.security.core.Authentication) : void
  publishAuthenticationFailure(exception : org.springframework.security.core.AuthenticationException, authentication : org.springframework.security.core.Authentication) : void
  getEventConstructor(exception : org.springframework.security.core.AuthenticationException) : java.lang.reflect.Constructor
  setApplicationEventPublisher(applicationEventPublisher : org.springframework.context.ApplicationEventPublisher) : void
  setAdditionalExceptionMappings(additionalExceptionMappings : java.util.Properties) : void
  setAdditionalExceptionMappings(mappings : java.util.Map) : void
  setDefaultAuthenticationFailureEvent(defaultAuthenticationFailureEventClass : java.lang.Class) : void
  addMapping(exceptionClass : java.lang.String, eventClass : java.lang.Class) : void
}
org.springframework.security.authentication.DefaultAuthenticationEventPublisher::publishAuthenticationSuccess -- org.springframework.context.ApplicationEventPublisher::publishEvent : this.applicationEventPublisher.publishEvent(newAuthenticationSuccessEvent(authentication)) 
org.springframework.security.authentication.DefaultAuthenticationEventPublisher::publishAuthenticationFailure -- org.springframework.context.ApplicationEventPublisher::publishEvent : this.applicationEventPublisher.publishEvent(event) 
org.springframework.security.authentication.DefaultAuthenticationEventPublisher::publishAuthenticationFailure -- org.apache.commons.logging.Log::isDebugEnabled : this.logger.isDebugEnabled() 
org.springframework.security.authentication.DefaultAuthenticationEventPublisher::publishAuthenticationFailure -- org.apache.commons.logging.Log::debug : this.logger.debug("No event was found for the exception "+exception.getClass().getName()) 
org.springframework.security.authentication.DefaultAuthenticationEventPublisher::publishAuthenticationFailure -- org.springframework.security.core.AuthenticationException::getClass : exception.getClass().getName() 
org.springframework.security.authentication.DefaultAuthenticationEventPublisher::publishAuthenticationFailure -- org.springframework.security.core.AuthenticationException::getClass : exception.getClass() 
org.springframework.security.authentication.DefaultAuthenticationEventPublisher::getEventConstructor -- java.util.HashMap::get : this.exceptionMappings.get(exception.getClass().getName()) 
org.springframework.security.authentication.DefaultAuthenticationEventPublisher::getEventConstructor -- org.springframework.security.core.AuthenticationException::getClass : exception.getClass().getName() 
org.springframework.security.authentication.DefaultAuthenticationEventPublisher::getEventConstructor -- org.springframework.security.core.AuthenticationException::getClass : exception.getClass() 
org.springframework.security.authentication.DefaultAuthenticationEventPublisher::setAdditionalExceptionMappings -- org.springframework.util.Assert::notNull : Assert.notNull(additionalExceptionMappings,"The exceptionMappings object must not be null") 
org.springframework.security.authentication.DefaultAuthenticationEventPublisher::setAdditionalExceptionMappings -- java.util.Properties::keySet : additionalExceptionMappings.keySet() 
org.springframework.security.authentication.DefaultAuthenticationEventPublisher::setAdditionalExceptionMappings -- java.util.Properties::get : additionalExceptionMappings.get(exceptionClass) 
org.springframework.security.authentication.DefaultAuthenticationEventPublisher::setAdditionalExceptionMappings -- org.springframework.security.authentication.DefaultAuthenticationEventPublisher::getClass : getClass().getClassLoader().loadClass(eventClass) 
org.springframework.security.authentication.DefaultAuthenticationEventPublisher::setAdditionalExceptionMappings -- org.springframework.security.authentication.DefaultAuthenticationEventPublisher::getClass : getClass().getClassLoader() 
org.springframework.security.authentication.DefaultAuthenticationEventPublisher::setAdditionalExceptionMappings -- org.springframework.util.Assert::isAssignable : Assert.isAssignable(AbstractAuthenticationFailureEvent.class,clazz) 
org.springframework.security.authentication.DefaultAuthenticationEventPublisher::setAdditionalExceptionMappings -- org.springframework.util.Assert::notEmpty : Assert.notEmpty(mappings,"The mappings Map must not be empty nor null") 
org.springframework.security.authentication.DefaultAuthenticationEventPublisher::setAdditionalExceptionMappings -- java.util.Map::entrySet : mappings.entrySet() 
org.springframework.security.authentication.DefaultAuthenticationEventPublisher::setAdditionalExceptionMappings -- org.springframework.util.Assert::notNull : Assert.notNull(exceptionClass,"exceptionClass cannot be null") 
org.springframework.security.authentication.DefaultAuthenticationEventPublisher::setAdditionalExceptionMappings -- org.springframework.util.Assert::notNull : Assert.notNull(eventClass,"eventClass cannot be null") 
org.springframework.security.authentication.DefaultAuthenticationEventPublisher::setDefaultAuthenticationFailureEvent -- org.springframework.util.Assert::notNull : Assert.notNull(defaultAuthenticationFailureEventClass,"defaultAuthenticationFailureEventClass must not be null") 
org.springframework.security.authentication.DefaultAuthenticationEventPublisher::setDefaultAuthenticationFailureEvent -- java.lang.Class::getConstructor : defaultAuthenticationFailureEventClass.getConstructor(Authentication.class,AuthenticationException.class) 
org.springframework.security.authentication.DefaultAuthenticationEventPublisher::setDefaultAuthenticationFailureEvent -- java.lang.Class::getName : defaultAuthenticationFailureEventClass.getName() 
org.springframework.security.authentication.DefaultAuthenticationEventPublisher::addMapping -- java.lang.Class::getConstructor : eventClass.getConstructor(Authentication.class,AuthenticationException.class) 
org.springframework.security.authentication.DefaultAuthenticationEventPublisher::addMapping -- java.util.HashMap::put : this.exceptionMappings.put(exceptionClass,constructor) 
org.springframework.security.authentication.DefaultAuthenticationEventPublisher::addMapping -- java.lang.Class::getName : eventClass.getName() 
class DelegatingReactiveAuthenticationManager  implements org.springframework.security.authentication.ReactiveAuthenticationManager  {
  delegates : java.util.List
  continueOnError : boolean
  logger : org.apache.commons.logging.Log
  DelegatingReactiveAuthenticationManager() : None
  DelegatingReactiveAuthenticationManager(entryPoints : java.util.List) : None
  authenticate(authentication : org.springframework.security.core.Authentication) : reactor.core.publisher.Mono
  setContinueOnError(continueOnError : boolean) : void
}
org.springframework.security.authentication.DelegatingReactiveAuthenticationManager::DelegatingReactiveAuthenticationManager -- java.util.Arrays::asList : Arrays.asList(entryPoints) 
org.springframework.security.authentication.DelegatingReactiveAuthenticationManager::DelegatingReactiveAuthenticationManager -- org.springframework.util.Assert::notEmpty : Assert.notEmpty(entryPoints,"entryPoints cannot be null") 
org.springframework.security.authentication.DelegatingReactiveAuthenticationManager::authenticate -- reactor.core.publisher.Flux::fromIterable : Flux.fromIterable(this.delegates) 
class DisabledException extends org.springframework.security.authentication.AccountStatusException   {
  serialVersionUID : long
  DisabledException(msg : java.lang.String) : None
  DisabledException(msg : java.lang.String, cause : java.lang.Throwable) : None
}
class InsufficientAuthenticationException extends org.springframework.security.core.AuthenticationException   {
  serialVersionUID : long
  InsufficientAuthenticationException(msg : java.lang.String) : None
  InsufficientAuthenticationException(msg : java.lang.String, cause : java.lang.Throwable) : None
}
class InternalAuthenticationServiceException extends org.springframework.security.authentication.AuthenticationServiceException   {
  serialVersionUID : long
  InternalAuthenticationServiceException(message : java.lang.String, cause : java.lang.Throwable) : None
  InternalAuthenticationServiceException(message : java.lang.String) : None
}
class LockedException extends org.springframework.security.authentication.AccountStatusException   {
  serialVersionUID : long
  LockedException(msg : java.lang.String) : None
  LockedException(msg : java.lang.String, cause : java.lang.Throwable) : None
}
class ObservationAuthenticationManager  implements org.springframework.security.authentication.AuthenticationManager  {
  registry : io.micrometer.observation.ObservationRegistry
  delegate : org.springframework.security.authentication.AuthenticationManager
  convention : io.micrometer.observation.ObservationConvention
  ObservationAuthenticationManager(registry : io.micrometer.observation.ObservationRegistry, delegate : org.springframework.security.authentication.AuthenticationManager) : None
  authenticate(authentication : org.springframework.security.core.Authentication) : org.springframework.security.core.Authentication
  setObservationConvention(convention : io.micrometer.observation.ObservationConvention) : void
}
org.springframework.security.authentication.ObservationAuthenticationManager::ObservationAuthenticationManager -- org.springframework.util.Assert::notNull : Assert.notNull(registry,"observationRegistry cannot be null") 
org.springframework.security.authentication.ObservationAuthenticationManager::ObservationAuthenticationManager -- org.springframework.util.Assert::notNull : Assert.notNull(delegate,"authenticationManager cannot be null") 
org.springframework.security.authentication.ObservationAuthenticationManager::authenticate -- org.springframework.security.authentication.AuthenticationManager::getClass : this.delegate.getClass() 
org.springframework.security.authentication.ObservationAuthenticationManager::authenticate -- io.micrometer.observation.Observation::createNotStarted : Observation.createNotStarted(this.convention,()->context,this.registry).observe(()->{Authenticationresult=this.delegate.authenticate(authentication);context.setAuthenticationResult(result);returnresult;}) 
org.springframework.security.authentication.ObservationAuthenticationManager::authenticate -- io.micrometer.observation.Observation::createNotStarted : Observation.createNotStarted(this.convention,()->context,this.registry) 
org.springframework.security.authentication.ObservationAuthenticationManager::authenticate -- org.springframework.security.authentication.AuthenticationManager::authenticate : this.delegate.authenticate(authentication) 
org.springframework.security.authentication.ObservationAuthenticationManager::setObservationConvention -- org.springframework.util.Assert::notNull : Assert.notNull(convention,"The observation convention cannot be null") 
class ObservationReactiveAuthenticationManager  implements org.springframework.security.authentication.ReactiveAuthenticationManager  {
  registry : io.micrometer.observation.ObservationRegistry
  delegate : org.springframework.security.authentication.ReactiveAuthenticationManager
  convention : io.micrometer.observation.ObservationConvention
  ObservationReactiveAuthenticationManager(registry : io.micrometer.observation.ObservationRegistry, delegate : org.springframework.security.authentication.ReactiveAuthenticationManager) : None
  authenticate(authentication : org.springframework.security.core.Authentication) : reactor.core.publisher.Mono
  setObservationConvention(convention : io.micrometer.observation.ObservationConvention) : void
}
org.springframework.security.authentication.ObservationReactiveAuthenticationManager::authenticate -- org.springframework.security.authentication.ReactiveAuthenticationManager::getClass : this.delegate.getClass() 
org.springframework.security.authentication.ObservationReactiveAuthenticationManager::authenticate -- reactor.core.publisher.Mono::deferContextual : Mono.deferContextual((contextView)->{Observationobservation=Observation.createNotStarted(this.convention,()->context,this.registry).parentObservation(contextView.getOrDefault(ObservationThreadLocalAccessor.KEY,null)).start();returnthis.delegate.authenticate(authentication).doOnSuccess((result)->{context.setAuthenticationResult(result);observation.stop();}).doOnCancel(observation::stop).doOnError((t)->{observation.error(t);observation.stop();});}) 
org.springframework.security.authentication.ObservationReactiveAuthenticationManager::authenticate -- io.micrometer.observation.Observation::createNotStarted : Observation.createNotStarted(this.convention,()->context,this.registry).parentObservation(contextView.getOrDefault(ObservationThreadLocalAccessor.KEY,null)).start() 
org.springframework.security.authentication.ObservationReactiveAuthenticationManager::authenticate -- io.micrometer.observation.Observation::createNotStarted : Observation.createNotStarted(this.convention,()->context,this.registry).parentObservation(contextView.getOrDefault(ObservationThreadLocalAccessor.KEY,null)) 
org.springframework.security.authentication.ObservationReactiveAuthenticationManager::authenticate -- io.micrometer.observation.Observation::createNotStarted : Observation.createNotStarted(this.convention,()->context,this.registry) 
org.springframework.security.authentication.ObservationReactiveAuthenticationManager::authenticate -- org.springframework.security.authentication.ReactiveAuthenticationManager::authenticate : this.delegate.authenticate(authentication).doOnSuccess((result)->{context.setAuthenticationResult(result);observation.stop();}).doOnCancel(observation::stop).doOnError((t)->{observation.error(t);observation.stop();}) 
org.springframework.security.authentication.ObservationReactiveAuthenticationManager::authenticate -- org.springframework.security.authentication.ReactiveAuthenticationManager::authenticate : this.delegate.authenticate(authentication).doOnSuccess((result)->{context.setAuthenticationResult(result);observation.stop();}).doOnCancel(observation::stop) 
org.springframework.security.authentication.ObservationReactiveAuthenticationManager::authenticate -- org.springframework.security.authentication.ReactiveAuthenticationManager::authenticate : this.delegate.authenticate(authentication).doOnSuccess((result)->{context.setAuthenticationResult(result);observation.stop();}) 
org.springframework.security.authentication.ObservationReactiveAuthenticationManager::authenticate -- org.springframework.security.authentication.ReactiveAuthenticationManager::authenticate : this.delegate.authenticate(authentication) 
org.springframework.security.authentication.ObservationReactiveAuthenticationManager::setObservationConvention -- org.springframework.util.Assert::notNull : Assert.notNull(convention,"The observation convention cannot be null") 
class ProviderManager  implements org.springframework.security.authentication.AuthenticationManager,MessageSourceAware,InitializingBean  {
  logger : org.apache.commons.logging.Log
  eventPublisher : org.springframework.security.authentication.AuthenticationEventPublisher
  providers : java.util.List
  messages : org.springframework.context.support.MessageSourceAccessor
  parent : org.springframework.security.authentication.AuthenticationManager
  eraseCredentialsAfterAuthentication : boolean
  ProviderManager() : None
  ProviderManager(providers : java.util.List) : None
  ProviderManager(providers : java.util.List, parent : org.springframework.security.authentication.AuthenticationManager) : None
  afterPropertiesSet() : void
  checkState() : void
  authenticate(authentication : org.springframework.security.core.Authentication) : org.springframework.security.core.Authentication
  prepareException(ex : org.springframework.security.core.AuthenticationException, auth : org.springframework.security.core.Authentication) : void
  copyDetails(source : org.springframework.security.core.Authentication, dest : org.springframework.security.core.Authentication) : void
  getProviders() : java.util.List
  setMessageSource(messageSource : org.springframework.context.MessageSource) : void
  setAuthenticationEventPublisher(eventPublisher : org.springframework.security.authentication.AuthenticationEventPublisher) : void
  setEraseCredentialsAfterAuthentication(eraseSecretData : boolean) : void
  isEraseCredentialsAfterAuthentication() : boolean
}
org.springframework.security.authentication.ProviderManager::ProviderManager -- java.util.Arrays::asList : Arrays.asList(providers) 
org.springframework.security.authentication.ProviderManager::ProviderManager -- org.springframework.util.Assert::notNull : Assert.notNull(providers,"providers list cannot be null") 
org.springframework.security.authentication.ProviderManager::checkState -- org.springframework.util.Assert::isTrue : Assert.isTrue(this.parent!=null||!this.providers.isEmpty(),"A parent AuthenticationManager or a list of AuthenticationProviders is required") 
org.springframework.security.authentication.ProviderManager::checkState -- java.util.List::isEmpty : this.providers.isEmpty() 
org.springframework.security.authentication.ProviderManager::checkState -- org.springframework.util.Assert::isTrue : Assert.isTrue(!CollectionUtils.contains(this.providers.iterator(),null),"providers list cannot contain null values") 
org.springframework.security.authentication.ProviderManager::checkState -- org.springframework.util.CollectionUtils::contains : CollectionUtils.contains(this.providers.iterator(),null) 
org.springframework.security.authentication.ProviderManager::checkState -- java.util.List::iterator : this.providers.iterator() 
org.springframework.security.authentication.ProviderManager::authenticate -- org.springframework.security.core.Authentication::getClass : authentication.getClass() 
org.springframework.security.authentication.ProviderManager::authenticate -- java.util.List::size : this.providers.size() 
org.springframework.security.authentication.ProviderManager::authenticate -- org.apache.commons.logging.Log::isTraceEnabled : logger.isTraceEnabled() 
org.springframework.security.authentication.ProviderManager::authenticate -- org.apache.commons.logging.Log::trace : logger.trace(LogMessage.format("Authenticating request with %s (%d/%d)",provider.getClass().getSimpleName(),++currentPosition,size)) 
org.springframework.security.authentication.ProviderManager::authenticate -- org.springframework.core.log.LogMessage::format : LogMessage.format("Authenticating request with %s (%d/%d)",provider.getClass().getSimpleName(),++currentPosition,size) 
org.springframework.security.authentication.ProviderManager::authenticate -- org.apache.commons.logging.Log::debug : logger.debug(LogMessage.format("Authentication failed for user '%s' since their account status is %s",authentication.getName(),ex.getMessage()),ex) 
org.springframework.security.authentication.ProviderManager::authenticate -- org.springframework.core.log.LogMessage::format : LogMessage.format("Authentication failed for user '%s' since their account status is %s",authentication.getName(),ex.getMessage()) 
org.springframework.security.authentication.ProviderManager::authenticate -- org.springframework.security.core.Authentication::getName : authentication.getName() 
org.springframework.security.authentication.ProviderManager::authenticate -- org.apache.commons.logging.Log::debug : logger.debug(LogMessage.format("Authentication service failed internally for user '%s'",authentication.getName()),ex) 
org.springframework.security.authentication.ProviderManager::authenticate -- org.springframework.core.log.LogMessage::format : LogMessage.format("Authentication service failed internally for user '%s'",authentication.getName()) 
org.springframework.security.authentication.ProviderManager::authenticate -- org.springframework.security.core.Authentication::getName : authentication.getName() 
org.springframework.security.authentication.ProviderManager::authenticate -- org.apache.commons.logging.Log::debug : logger.debug(LogMessage.format("Authentication failed with provider %s since %s",provider.getClass().getSimpleName(),ex.getMessage())) 
org.springframework.security.authentication.ProviderManager::authenticate -- org.springframework.core.log.LogMessage::format : LogMessage.format("Authentication failed with provider %s since %s",provider.getClass().getSimpleName(),ex.getMessage()) 
org.springframework.security.authentication.ProviderManager::authenticate -- org.springframework.security.authentication.AuthenticationManager::authenticate : this.parent.authenticate(authentication) 
org.springframework.security.authentication.ProviderManager::authenticate -- org.springframework.security.authentication.AuthenticationEventPublisher::publishAuthenticationSuccess : this.eventPublisher.publishAuthenticationSuccess(result) 
org.springframework.security.authentication.ProviderManager::authenticate -- org.springframework.context.support.MessageSourceAccessor::getMessage : this.messages.getMessage("ProviderManager.providerNotFound",newObject[]{toTest.getName()},"No AuthenticationProvider found for {0}") 
org.springframework.security.authentication.ProviderManager::authenticate -- org.apache.commons.logging.Log::debug : logger.debug("Denying authentication since all attempted providers failed") 
org.springframework.security.authentication.ProviderManager::prepareException -- org.springframework.security.authentication.AuthenticationEventPublisher::publishAuthenticationFailure : this.eventPublisher.publishAuthenticationFailure(ex,auth) 
org.springframework.security.authentication.ProviderManager::copyDetails -- org.springframework.security.core.Authentication::getDetails : dest.getDetails() 
org.springframework.security.authentication.ProviderManager::copyDetails -- org.springframework.security.core.Authentication::getDetails : source.getDetails() 
org.springframework.security.authentication.ProviderManager::setAuthenticationEventPublisher -- org.springframework.util.Assert::notNull : Assert.notNull(eventPublisher,"AuthenticationEventPublisher cannot be null") 
class NullEventPublisher  implements org.springframework.security.authentication.AuthenticationEventPublisher  {
  publishAuthenticationFailure(exception : org.springframework.security.authentication.AuthenticationException, authentication : org.springframework.security.authentication.Authentication) : void
  publishAuthenticationSuccess(authentication : org.springframework.security.authentication.Authentication) : void
}
class ProviderNotFoundException extends org.springframework.security.core.AuthenticationException   {
  serialVersionUID : long
  ProviderNotFoundException(msg : java.lang.String) : None
}
interface ReactiveAuthenticationManager    {
  authenticate(authentication : org.springframework.security.core.Authentication) : reactor.core.publisher.Mono
}
class ReactiveAuthenticationManagerAdapter  implements org.springframework.security.authentication.ReactiveAuthenticationManager  {
  authenticationManager : org.springframework.security.authentication.AuthenticationManager
  scheduler : reactor.core.scheduler.Scheduler
  ReactiveAuthenticationManagerAdapter(authenticationManager : org.springframework.security.authentication.AuthenticationManager) : None
  authenticate(token : org.springframework.security.core.Authentication) : reactor.core.publisher.Mono
  doAuthenticate(authentication : org.springframework.security.core.Authentication) : reactor.core.publisher.Mono
  setScheduler(scheduler : reactor.core.scheduler.Scheduler) : void
}
org.springframework.security.authentication.ReactiveAuthenticationManagerAdapter::ReactiveAuthenticationManagerAdapter -- org.springframework.util.Assert::notNull : Assert.notNull(authenticationManager,"authenticationManager cannot be null") 
org.springframework.security.authentication.ReactiveAuthenticationManagerAdapter::authenticate -- reactor.core.publisher.Mono::just : Mono.just(token).publishOn(this.scheduler).flatMap(this::doAuthenticate).filter(Authentication::isAuthenticated) 
org.springframework.security.authentication.ReactiveAuthenticationManagerAdapter::authenticate -- reactor.core.publisher.Mono::just : Mono.just(token).publishOn(this.scheduler).flatMap(this::doAuthenticate) 
org.springframework.security.authentication.ReactiveAuthenticationManagerAdapter::authenticate -- reactor.core.publisher.Mono::just : Mono.just(token).publishOn(this.scheduler) 
org.springframework.security.authentication.ReactiveAuthenticationManagerAdapter::authenticate -- reactor.core.publisher.Mono::just : Mono.just(token) 
org.springframework.security.authentication.ReactiveAuthenticationManagerAdapter::doAuthenticate -- reactor.core.publisher.Mono::just : Mono.just(this.authenticationManager.authenticate(authentication)) 
org.springframework.security.authentication.ReactiveAuthenticationManagerAdapter::doAuthenticate -- org.springframework.security.authentication.AuthenticationManager::authenticate : this.authenticationManager.authenticate(authentication) 
org.springframework.security.authentication.ReactiveAuthenticationManagerAdapter::doAuthenticate -- reactor.core.publisher.Mono::error : Mono.error(ex) 
org.springframework.security.authentication.ReactiveAuthenticationManagerAdapter::setScheduler -- org.springframework.util.Assert::notNull : Assert.notNull(scheduler,"scheduler cannot be null") 
interface ReactiveAuthenticationManagerResolver    {
  resolve(context : org.springframework.security.authentication.C) : reactor.core.publisher.Mono
}
class RememberMeAuthenticationProvider  implements org.springframework.security.authentication.AuthenticationProvider,InitializingBean,MessageSourceAware  {
  messages : org.springframework.context.support.MessageSourceAccessor
  key : java.lang.String
  RememberMeAuthenticationProvider(key : java.lang.String) : None
  afterPropertiesSet() : void
  authenticate(authentication : org.springframework.security.core.Authentication) : org.springframework.security.core.Authentication
  getKey() : java.lang.String
  setMessageSource(messageSource : org.springframework.context.MessageSource) : void
  supports(authentication : java.lang.Class) : boolean
}
org.springframework.security.authentication.RememberMeAuthenticationProvider::RememberMeAuthenticationProvider -- org.springframework.util.Assert::hasLength : Assert.hasLength(key,"key must have a length") 
org.springframework.security.authentication.RememberMeAuthenticationProvider::afterPropertiesSet -- org.springframework.util.Assert::notNull : Assert.notNull(this.messages,"A message source must be set") 
org.springframework.security.authentication.RememberMeAuthenticationProvider::authenticate -- org.springframework.security.core.Authentication::getClass : authentication.getClass() 
org.springframework.security.authentication.RememberMeAuthenticationProvider::authenticate -- java.lang.String::hashCode : this.key.hashCode() 
org.springframework.security.authentication.RememberMeAuthenticationProvider::authenticate -- org.springframework.context.support.MessageSourceAccessor::getMessage : this.messages.getMessage("RememberMeAuthenticationProvider.incorrectKey","The presented RememberMeAuthenticationToken does not contain the expected key") 
class RememberMeAuthenticationToken extends org.springframework.security.authentication.AbstractAuthenticationToken   {
  serialVersionUID : long
  principal : java.lang.Object
  keyHash : int
  RememberMeAuthenticationToken(key : java.lang.String, principal : java.lang.Object, authorities : java.util.Collection) : None
  RememberMeAuthenticationToken(keyHash : java.lang.Integer, principal : java.lang.Object, authorities : java.util.Collection) : None
  getCredentials() : java.lang.Object
  getKeyHash() : int
  getPrincipal() : java.lang.Object
  equals(obj : java.lang.Object) : boolean
  hashCode() : int
}
org.springframework.security.authentication.RememberMeAuthenticationToken::RememberMeAuthenticationToken -- java.lang.String::hashCode : key.hashCode() 
class TestingAuthenticationProvider  implements org.springframework.security.authentication.AuthenticationProvider  {
  authenticate(authentication : org.springframework.security.core.Authentication) : org.springframework.security.core.Authentication
  supports(authentication : java.lang.Class) : boolean
}
class TestingAuthenticationToken extends org.springframework.security.authentication.AbstractAuthenticationToken   {
  serialVersionUID : long
  credentials : java.lang.Object
  principal : java.lang.Object
  TestingAuthenticationToken(principal : java.lang.Object, credentials : java.lang.Object) : None
  TestingAuthenticationToken(principal : java.lang.Object, credentials : java.lang.Object) : None
  TestingAuthenticationToken(principal : java.lang.Object, credentials : java.lang.Object, authorities : java.util.List) : None
  TestingAuthenticationToken(principal : java.lang.Object, credentials : java.lang.Object, authorities : java.util.Collection) : None
  getCredentials() : java.lang.Object
  getPrincipal() : java.lang.Object
}
org.springframework.security.authentication.TestingAuthenticationToken::TestingAuthenticationToken -- org.springframework.security.core.authority.AuthorityUtils::createAuthorityList : AuthorityUtils.createAuthorityList(authorities) 
class UserDetailsRepositoryReactiveAuthenticationManager extends org.springframework.security.authentication.AbstractUserDetailsReactiveAuthenticationManager   {
  userDetailsService : org.springframework.security.core.userdetails.ReactiveUserDetailsService
  UserDetailsRepositoryReactiveAuthenticationManager(userDetailsService : org.springframework.security.core.userdetails.ReactiveUserDetailsService) : None
  retrieveUser(username : java.lang.String) : reactor.core.publisher.Mono
}
org.springframework.security.authentication.UserDetailsRepositoryReactiveAuthenticationManager::UserDetailsRepositoryReactiveAuthenticationManager -- org.springframework.util.Assert::notNull : Assert.notNull(userDetailsService,"userDetailsService cannot be null") 
org.springframework.security.authentication.UserDetailsRepositoryReactiveAuthenticationManager::retrieveUser -- org.springframework.security.core.userdetails.ReactiveUserDetailsService::findByUsername : this.userDetailsService.findByUsername(username) 
class UsernamePasswordAuthenticationToken extends org.springframework.security.authentication.AbstractAuthenticationToken   {
  serialVersionUID : long
  principal : java.lang.Object
  credentials : java.lang.Object
  UsernamePasswordAuthenticationToken(principal : java.lang.Object, credentials : java.lang.Object) : None
  UsernamePasswordAuthenticationToken(principal : java.lang.Object, credentials : java.lang.Object, authorities : java.util.Collection) : None
  unauthenticated(principal : java.lang.Object, credentials : java.lang.Object) : org.springframework.security.authentication.UsernamePasswordAuthenticationToken
  authenticated(principal : java.lang.Object, credentials : java.lang.Object, authorities : java.util.Collection) : org.springframework.security.authentication.UsernamePasswordAuthenticationToken
  getCredentials() : java.lang.Object
  getPrincipal() : java.lang.Object
  setAuthenticated(isAuthenticated : boolean) : void
  eraseCredentials() : void
}
org.springframework.security.authentication.UsernamePasswordAuthenticationToken::setAuthenticated -- org.springframework.util.Assert::isTrue : Assert.isTrue(!isAuthenticated,"Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead") 
}
package authorization {
package event {
class AuthorizationDeniedEvent extends org.springframework.security.authorization.event.AuthorizationEvent   {
  AuthorizationDeniedEvent(authentication : java.util.function.Supplier, object : org.springframework.security.authorization.event.T, decision : org.springframework.security.authorization.AuthorizationDecision) : None
  AuthorizationDeniedEvent(authentication : java.util.function.Supplier, object : org.springframework.security.authorization.event.T, result : org.springframework.security.authorization.AuthorizationResult) : None
  getObject() : org.springframework.security.authorization.event.T
}
class AuthorizationEvent extends org.springframework.context.ApplicationEvent   {
  serialVersionUID : long
  authentication : java.util.function.Supplier
  result : org.springframework.security.authorization.AuthorizationResult
  AuthorizationEvent(authentication : java.util.function.Supplier, object : java.lang.Object, result : org.springframework.security.authorization.AuthorizationDecision) : None
  AuthorizationEvent(authentication : java.util.function.Supplier, object : java.lang.Object, result : org.springframework.security.authorization.AuthorizationResult) : None
  getAuthentication() : java.util.function.Supplier
  getObject() : java.lang.Object
  getAuthorizationDecision() : org.springframework.security.authorization.AuthorizationDecision
  getAuthorizationResult() : org.springframework.security.authorization.AuthorizationResult
}
org.springframework.security.authorization.event.AuthorizationEvent::AuthorizationEvent -- org.springframework.util.Assert::notNull : Assert.notNull(authentication,"authentication supplier cannot be null") 
org.springframework.security.authorization.event.AuthorizationEvent::AuthorizationEvent -- org.springframework.util.Assert::notNull : Assert.notNull(authentication,"authentication supplier cannot be null") 
class AuthorizationGrantedEvent extends org.springframework.security.authorization.event.AuthorizationEvent   {
  serialVersionUID : long
  AuthorizationGrantedEvent(authentication : java.util.function.Supplier, object : org.springframework.security.authorization.event.T, decision : org.springframework.security.authorization.AuthorizationDecision) : None
  AuthorizationGrantedEvent(authentication : java.util.function.Supplier, object : org.springframework.security.authorization.event.T, result : org.springframework.security.authorization.AuthorizationResult) : None
  getObject() : org.springframework.security.authorization.event.T
}
}
package method {
class AbstractAuthorizationManagerRegistry    {
  NULL_MANAGER : org.springframework.security.authorization.AuthorizationManager
  cachedManagers : java.util.Map
  getManager(methodInvocation : org.aopalliance.intercept.MethodInvocation) : org.springframework.security.authorization.AuthorizationManager
  resolveManager(method : java.lang.reflect.Method, targetClass : java.lang.Class) : org.springframework.security.authorization.AuthorizationManager
}
org.springframework.security.authorization.method.AbstractAuthorizationManagerRegistry::getManager -- org.aopalliance.intercept.MethodInvocation::getMethod : methodInvocation.getMethod() 
org.springframework.security.authorization.method.AbstractAuthorizationManagerRegistry::getManager -- org.aopalliance.intercept.MethodInvocation::getThis : methodInvocation.getThis() 
org.springframework.security.authorization.method.AbstractAuthorizationManagerRegistry::getManager -- java.util.Map::computeIfAbsent : this.cachedManagers.computeIfAbsent(cacheKey,(k)->resolveManager(method,targetClass)) 
class AbstractExpressionAttributeRegistry    {
  cachedAttributes : java.util.Map
  expressionHandler : org.springframework.security.access.expression.method.MethodSecurityExpressionHandler
  getAttribute(mi : org.aopalliance.intercept.MethodInvocation) : org.springframework.security.authorization.method.T
  getAttribute(method : java.lang.reflect.Method, targetClass : java.lang.Class) : org.springframework.security.authorization.method.T
  getExpressionHandler() : org.springframework.security.access.expression.method.MethodSecurityExpressionHandler
  setExpressionHandler(expressionHandler : org.springframework.security.access.expression.method.MethodSecurityExpressionHandler) : void
  setTemplateDefaults(defaults : org.springframework.security.authorization.method.PrePostTemplateDefaults) : void
  setTemplateDefaults(adapter : org.springframework.security.core.annotation.AnnotationTemplateExpressionDefaults) : void
  resolveAttribute(method : java.lang.reflect.Method, targetClass : java.lang.Class) : org.springframework.security.authorization.method.T
  targetClass(method : java.lang.reflect.Method, targetClass : java.lang.Class) : java.lang.Class
}
org.springframework.security.authorization.method.AbstractExpressionAttributeRegistry::getAttribute -- org.aopalliance.intercept.MethodInvocation::getMethod : mi.getMethod() 
org.springframework.security.authorization.method.AbstractExpressionAttributeRegistry::getAttribute -- org.aopalliance.intercept.MethodInvocation::getThis : mi.getThis() 
org.springframework.security.authorization.method.AbstractExpressionAttributeRegistry::getAttribute -- java.util.Map::computeIfAbsent : this.cachedAttributes.computeIfAbsent(cacheKey,(k)->resolveAttribute(method,targetClass)) 
org.springframework.security.authorization.method.AbstractExpressionAttributeRegistry::setExpressionHandler -- org.springframework.util.Assert::notNull : Assert.notNull(expressionHandler,"expressionHandler cannot be null") 
org.springframework.security.authorization.method.AbstractExpressionAttributeRegistry::setTemplateDefaults -- org.springframework.security.authorization.method.PrePostTemplateDefaults::isIgnoreUnknown : defaults.isIgnoreUnknown() 
org.springframework.security.authorization.method.AbstractExpressionAttributeRegistry::targetClass -- java.lang.reflect.Method::getDeclaringClass : method.getDeclaringClass() 
interface AuthorizationAdvisor    {
}
class AuthorizationAdvisorProxyFactory  implements org.springframework.security.authorization.method.AuthorizationProxyFactory,Iterable  {
  isReactivePresent : boolean
  DEFAULT_VISITOR : org.springframework.security.authorization.method.TargetVisitor
  DEFAULT_VISITOR_SKIP_VALUE_TYPES : org.springframework.security.authorization.method.TargetVisitor
  authorizationProxy : org.springframework.security.authorization.method.AuthorizationProxyMethodInterceptor
  advisors : java.util.List
  visitor : org.springframework.security.authorization.method.TargetVisitor
  AuthorizationAdvisorProxyFactory(advisors : java.util.List) : None
  withDefaults() : org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory
  withReactiveDefaults() : org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory
  proxy(target : java.lang.Object) : java.lang.Object
  setAdvisors() : void
  setAdvisors(advisors : java.util.Collection) : void
  addAdvisor(advisor : org.springframework.security.authorization.method.AuthorizationAdvisor) : void
  setTargetVisitor(visitor : org.springframework.security.authorization.method.TargetVisitor) : void
  iterator() : java.util.Iterator
}
org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory::AuthorizationAdvisorProxyFactory -- org.springframework.core.annotation.AnnotationAwareOrderComparator::sort : AnnotationAwareOrderComparator.sort(this.advisors) 
org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory::withDefaults -- java.util.List::add : advisors.add(AuthorizationManagerBeforeMethodInterceptor.preAuthorize()) 
org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory::withDefaults -- org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor::preAuthorize : AuthorizationManagerBeforeMethodInterceptor.preAuthorize() 
org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory::withDefaults -- java.util.List::add : advisors.add(AuthorizationManagerAfterMethodInterceptor.postAuthorize()) 
org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory::withDefaults -- org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor::postAuthorize : AuthorizationManagerAfterMethodInterceptor.postAuthorize() 
org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory::withDefaults -- java.util.List::add : advisors.add(newPreFilterAuthorizationMethodInterceptor()) 
org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory::withDefaults -- java.util.List::add : advisors.add(newPostFilterAuthorizationMethodInterceptor()) 
org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory::withReactiveDefaults -- java.util.List::add : advisors.add(AuthorizationManagerBeforeReactiveMethodInterceptor.preAuthorize()) 
org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory::withReactiveDefaults -- org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::preAuthorize : AuthorizationManagerBeforeReactiveMethodInterceptor.preAuthorize() 
org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory::withReactiveDefaults -- java.util.List::add : advisors.add(AuthorizationManagerAfterReactiveMethodInterceptor.postAuthorize()) 
org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory::withReactiveDefaults -- org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::postAuthorize : AuthorizationManagerAfterReactiveMethodInterceptor.postAuthorize() 
org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory::withReactiveDefaults -- java.util.List::add : advisors.add(newPreFilterAuthorizationReactiveMethodInterceptor()) 
org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory::withReactiveDefaults -- java.util.List::add : advisors.add(newPostFilterAuthorizationReactiveMethodInterceptor()) 
org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory::proxy -- org.springframework.core.annotation.AnnotationAwareOrderComparator::sort : AnnotationAwareOrderComparator.sort(this.advisors) 
org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory::proxy -- org.springframework.security.authorization.method.TargetVisitor::visit : this.visitor.visit(this,target) 
org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory::proxy -- java.lang.reflect.Modifier::isFinal : Modifier.isFinal(target.getClass().getModifiers()) 
org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory::proxy -- java.lang.Object::getClass : target.getClass().getModifiers() 
org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory::proxy -- java.lang.Object::getClass : target.getClass() 
org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory::setAdvisors -- java.util.List::of : List.of(advisors) 
org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory::addAdvisor -- java.util.List::add : this.advisors.add(advisor) 
org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory::setTargetVisitor -- org.springframework.util.Assert::notNull : Assert.notNull(visitor,"delegate cannot be null") 
org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory::iterator -- java.util.List::iterator : this.advisors.iterator() 
interface TargetVisitor    {
  visit(proxyFactory : org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory, target : java.lang.Object) : java.lang.Object
  defaults() : org.springframework.security.authorization.method.TargetVisitor
  defaultsSkipValueTypes() : org.springframework.security.authorization.method.TargetVisitor
  of() : org.springframework.security.authorization.method.TargetVisitor
}
class IgnoreValueTypeVisitor  implements org.springframework.security.authorization.method.TargetVisitor  {
  visit(proxyFactory : org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory, object : java.lang.Object) : java.lang.Object
}
org.springframework.security.authorization.method.IgnoreValueTypeVisitor::visit -- org.springframework.security.authorization.method.ClassUtils::isSimpleValueType : ClassUtils.isSimpleValueType(object.getClass()) 
org.springframework.security.authorization.method.IgnoreValueTypeVisitor::visit -- java.lang.Object::getClass : object.getClass() 
class ClassVisitor  implements org.springframework.security.authorization.method.TargetVisitor  {
  authorizationProxy : org.springframework.security.authorization.method.AuthorizationProxyMethodInterceptor
  visit(proxyFactory : org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory, object : java.lang.Object) : java.lang.Object
}
org.springframework.security.authorization.method.ClassVisitor::visit -- org.springframework.security.authorization.method.ClassUtils::getAllInterfacesForClass : ClassUtils.getAllInterfacesForClass(targetClass) 
org.springframework.security.authorization.method.ClassVisitor::visit -- org.springframework.security.authorization.method.Modifier::isFinal : Modifier.isFinal(targetClass.getModifiers()) 
org.springframework.security.authorization.method.ClassVisitor::visit -- org.springframework.security.authorization.method.ClassVisitor::getClass : getClass().getClassLoader() 
class ContainerTypeVisitor  implements org.springframework.security.authorization.method.TargetVisitor  {
  visit(proxyFactory : org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory, target : java.lang.Object) : java.lang.Object
  proxyCast(proxyFactory : org.springframework.security.authorization.method.AuthorizationProxyFactory, target : org.springframework.security.authorization.method.T) : org.springframework.security.authorization.method.T
  proxyIterable(proxyFactory : org.springframework.security.authorization.method.AuthorizationProxyFactory, iterable : org.springframework.security.authorization.method.Iterable) : org.springframework.security.authorization.method.Iterable
  proxyIterator(proxyFactory : org.springframework.security.authorization.method.AuthorizationProxyFactory, iterator : org.springframework.security.authorization.method.Iterator) : org.springframework.security.authorization.method.Iterator
  hasNext() : boolean
  next() : org.springframework.security.authorization.method.T
  proxySortedSet(proxyFactory : org.springframework.security.authorization.method.AuthorizationProxyFactory, set : org.springframework.security.authorization.method.SortedSet) : org.springframework.security.authorization.method.SortedSet
  proxySet(proxyFactory : org.springframework.security.authorization.method.AuthorizationProxyFactory, set : org.springframework.security.authorization.method.Set) : org.springframework.security.authorization.method.Set
  proxyQueue(proxyFactory : org.springframework.security.authorization.method.AuthorizationProxyFactory, queue : org.springframework.security.authorization.method.Queue) : org.springframework.security.authorization.method.Queue
  proxyList(proxyFactory : org.springframework.security.authorization.method.AuthorizationProxyFactory, list : org.springframework.security.authorization.method.List) : org.springframework.security.authorization.method.List
  proxyArray(proxyFactory : org.springframework.security.authorization.method.AuthorizationProxyFactory, objects : org.springframework.security.authorization.method.Object[]) : org.springframework.security.authorization.method.Object[]
  proxySortedMap(proxyFactory : org.springframework.security.authorization.method.AuthorizationProxyFactory, entries : org.springframework.security.authorization.method.SortedMap) : org.springframework.security.authorization.method.SortedMap
  proxyMap(proxyFactory : org.springframework.security.authorization.method.AuthorizationProxyFactory, entries : org.springframework.security.authorization.method.Map) : org.springframework.security.authorization.method.Map
  proxyStream(proxyFactory : org.springframework.security.authorization.method.AuthorizationProxyFactory, stream : org.springframework.security.authorization.method.Stream) : org.springframework.security.authorization.method.Stream
  proxyOptional(proxyFactory : org.springframework.security.authorization.method.AuthorizationProxyFactory, optional : org.springframework.security.authorization.method.Optional) : org.springframework.security.authorization.method.Optional
  proxySupplier(proxyFactory : org.springframework.security.authorization.method.AuthorizationProxyFactory, supplier : org.springframework.security.authorization.method.Supplier) : org.springframework.security.authorization.method.Supplier
}
org.springframework.security.authorization.method.ContainerTypeVisitor::visit -- java.lang.Object::getClass : target.getClass().isArray() 
org.springframework.security.authorization.method.ContainerTypeVisitor::visit -- java.lang.Object::getClass : target.getClass() 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxyCast -- org.springframework.security.authorization.method.AuthorizationProxyFactory::proxy : proxyFactory.proxy(target) 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxyIterable -- org.springframework.security.authorization.method.Iterable::iterator : iterable.iterator() 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxySortedSet -- org.springframework.security.authorization.method.SortedSet::comparator : set.comparator() 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxySortedSet -- org.springframework.security.authorization.method.SortedSet::clear : set.clear() 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxySortedSet -- org.springframework.security.authorization.method.SortedSet::addAll : set.addAll(proxies) 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxySortedSet -- org.springframework.security.authorization.method.Collections::unmodifiableSortedSet : Collections.unmodifiableSortedSet(proxies) 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxySet -- org.springframework.security.authorization.method.Set::size : set.size() 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxySet -- org.springframework.security.authorization.method.Set::clear : set.clear() 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxySet -- org.springframework.security.authorization.method.Set::addAll : set.addAll(proxies) 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxySet -- org.springframework.security.authorization.method.Collections::unmodifiableSet : Collections.unmodifiableSet(proxies) 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxyQueue -- org.springframework.security.authorization.method.Queue::clear : queue.clear() 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxyQueue -- org.springframework.security.authorization.method.Queue::addAll : queue.addAll(proxies) 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxyList -- org.springframework.security.authorization.method.List::size : list.size() 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxyList -- org.springframework.security.authorization.method.List::clear : list.clear() 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxyList -- org.springframework.security.authorization.method.List::addAll : list.addAll(proxies) 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxyList -- org.springframework.security.authorization.method.Collections::unmodifiableList : Collections.unmodifiableList(proxies) 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxyArray -- org.springframework.security.authorization.method.AuthorizationProxyFactory::proxy : proxyFactory.proxy(object) 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxyArray -- org.springframework.security.authorization.method.Array::newInstance : Array.newInstance(objects.getClass().getComponentType(),retain.size()) 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxyArray -- org.springframework.security.authorization.method.Object[]::getClass : objects.getClass().getComponentType() 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxyArray -- org.springframework.security.authorization.method.Object[]::getClass : objects.getClass() 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxySortedMap -- org.springframework.security.authorization.method.SortedMap::comparator : entries.comparator() 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxySortedMap -- org.springframework.security.authorization.method.SortedMap::entrySet : entries.entrySet() 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxySortedMap -- org.springframework.security.authorization.method.SortedMap::clear : entries.clear() 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxySortedMap -- org.springframework.security.authorization.method.SortedMap::putAll : entries.putAll(proxies) 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxySortedMap -- org.springframework.security.authorization.method.Collections::unmodifiableSortedMap : Collections.unmodifiableSortedMap(proxies) 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxyMap -- org.springframework.security.authorization.method.Map::size : entries.size() 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxyMap -- org.springframework.security.authorization.method.Map::entrySet : entries.entrySet() 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxyMap -- org.springframework.security.authorization.method.Map::clear : entries.clear() 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxyMap -- org.springframework.security.authorization.method.Map::putAll : entries.putAll(proxies) 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxyMap -- org.springframework.security.authorization.method.Collections::unmodifiableMap : Collections.unmodifiableMap(proxies) 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxyStream -- org.springframework.security.authorization.method.Stream::map : stream.map(proxyFactory::proxy).onClose(stream::close) 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxyStream -- org.springframework.security.authorization.method.Stream::map : stream.map(proxyFactory::proxy) 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxyOptional -- org.springframework.security.authorization.method.Optional::map : optional.map(proxyFactory::proxy) 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxySupplier -- org.springframework.security.authorization.method.AuthorizationProxyFactory::proxy : proxyFactory.proxy(supplier.get()) 
org.springframework.security.authorization.method.ContainerTypeVisitor::proxySupplier -- org.springframework.security.authorization.method.Supplier::get : supplier.get() 
class ReactiveTypeVisitor  implements org.springframework.security.authorization.method.TargetVisitor  {
  visit(proxyFactory : org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory, target : java.lang.Object) : java.lang.Object
  proxyMono(proxyFactory : org.springframework.security.authorization.method.AuthorizationProxyFactory, mono : org.springframework.security.authorization.method.Mono) : org.springframework.security.authorization.method.Mono
  proxyFlux(proxyFactory : org.springframework.security.authorization.method.AuthorizationProxyFactory, flux : org.springframework.security.authorization.method.Flux) : org.springframework.security.authorization.method.Flux
}
org.springframework.security.authorization.method.ReactiveTypeVisitor::proxyMono -- org.springframework.security.authorization.method.Mono::map : mono.map(proxyFactory::proxy) 
org.springframework.security.authorization.method.ReactiveTypeVisitor::proxyFlux -- org.springframework.security.authorization.method.Flux::map : flux.map(proxyFactory::proxy) 
class AuthorizationProxyMethodInterceptor  implements org.springframework.security.authorization.method.AuthorizationAdvisor  {
  GET_TARGET_METHOD : org.springframework.security.authorization.method.Method
  invoke(invocation : org.springframework.security.authorization.method.MethodInvocation) : java.lang.Object
  getPointcut() : org.springframework.security.authorization.method.Pointcut
  getAdvice() : org.springframework.security.authorization.method.Advice
  getOrder() : int
}
org.springframework.security.authorization.method.AuthorizationProxyMethodInterceptor::invoke -- org.springframework.security.authorization.method.MethodInvocation::getMethod : invocation.getMethod().equals(GET_TARGET_METHOD) 
org.springframework.security.authorization.method.AuthorizationProxyMethodInterceptor::invoke -- org.springframework.security.authorization.method.MethodInvocation::getMethod : invocation.getMethod() 
org.springframework.security.authorization.method.AuthorizationProxyMethodInterceptor::invoke -- org.springframework.security.authorization.method.MethodInvocation::getThis : invocation.getThis() 
org.springframework.security.authorization.method.AuthorizationProxyMethodInterceptor::invoke -- org.springframework.security.authorization.method.MethodInvocation::proceed : invocation.proceed() 
class AuthorizationManagerAfterMethodInterceptor  implements org.springframework.security.authorization.method.AuthorizationAdvisor  {
  securityContextHolderStrategy : java.util.function.Supplier
  logger : org.apache.commons.logging.Log
  pointcut : org.springframework.aop.Pointcut
  authorizationManager : org.springframework.security.authorization.AuthorizationManager
  defaultHandler : org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler
  order : int
  eventPublisher : org.springframework.security.authorization.AuthorizationEventPublisher
  AuthorizationManagerAfterMethodInterceptor(pointcut : org.springframework.aop.Pointcut, authorizationManager : org.springframework.security.authorization.AuthorizationManager) : None
  postAuthorize() : org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor
  postAuthorize(authorizationManager : org.springframework.security.authorization.method.PostAuthorizeAuthorizationManager) : org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor
  postAuthorize(authorizationManager : org.springframework.security.authorization.AuthorizationManager) : org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor
  invoke(mi : org.aopalliance.intercept.MethodInvocation) : java.lang.Object
  getOrder() : int
  setOrder(order : int) : void
  setAuthorizationEventPublisher(eventPublisher : org.springframework.security.authorization.AuthorizationEventPublisher) : void
  getPointcut() : org.springframework.aop.Pointcut
  getAdvice() : org.aopalliance.aop.Advice
  isPerInstance() : boolean
  setSecurityContextHolderStrategy(strategy : org.springframework.security.core.context.SecurityContextHolderStrategy) : void
  attemptAuthorization(mi : org.aopalliance.intercept.MethodInvocation, result : java.lang.Object) : java.lang.Object
  handlePostInvocationDenied(mi : org.springframework.security.authorization.method.MethodInvocationResult, result : org.springframework.security.authorization.AuthorizationResult) : java.lang.Object
  getAuthentication() : org.springframework.security.core.Authentication
}
org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor::AuthorizationManagerAfterMethodInterceptor -- org.springframework.util.Assert::notNull : Assert.notNull(pointcut,"pointcut cannot be null") 
org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor::AuthorizationManagerAfterMethodInterceptor -- org.springframework.util.Assert::notNull : Assert.notNull(authorizationManager,"authorizationManager cannot be null") 
org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor::postAuthorize -- org.springframework.security.authorization.method.AuthorizationMethodPointcuts::forAnnotations : AuthorizationMethodPointcuts.forAnnotations(PostAuthorize.class) 
org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor::postAuthorize -- org.springframework.security.authorization.method.AuthorizationMethodPointcuts::forAnnotations : AuthorizationMethodPointcuts.forAnnotations(PostAuthorize.class) 
org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor::invoke -- org.aopalliance.intercept.MethodInvocation::proceed : mi.proceed() 
org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor::invoke -- org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler::handleDeniedInvocation : this.defaultHandler.handleDeniedInvocation(mi,ex) 
org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor::setAuthorizationEventPublisher -- org.springframework.util.Assert::notNull : Assert.notNull(eventPublisher,"eventPublisher cannot be null") 
org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor::attemptAuthorization -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.of(()->"Authorizing method invocation "+mi)) 
org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor::attemptAuthorization -- org.springframework.core.log.LogMessage::of : LogMessage.of(()->"Authorizing method invocation "+mi) 
org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor::attemptAuthorization -- org.springframework.security.authorization.AuthorizationManager::authorize : this.authorizationManager.authorize(this::getAuthentication,object) 
org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor::attemptAuthorization -- org.springframework.security.authorization.AuthorizationEventPublisher::publishAuthorizationEvent : this.eventPublisher.publishAuthorizationEvent(this::getAuthentication,object,authorizationResult) 
org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor::attemptAuthorization -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.of(()->"Failed to authorize "+mi+" with authorization manager "+this.authorizationManager+" and authorizationResult "+authorizationResult)) 
org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor::attemptAuthorization -- org.springframework.core.log.LogMessage::of : LogMessage.of(()->"Failed to authorize "+mi+" with authorization manager "+this.authorizationManager+" and authorizationResult "+authorizationResult) 
org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor::attemptAuthorization -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.of(()->"Authorized method invocation "+mi)) 
org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor::attemptAuthorization -- org.springframework.core.log.LogMessage::of : LogMessage.of(()->"Authorized method invocation "+mi) 
org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor::handlePostInvocationDenied -- org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler::handleDeniedInvocationResult : this.defaultHandler.handleDeniedInvocationResult(mi,result) 
org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor::getAuthentication -- java.util.function.Supplier::get : this.securityContextHolderStrategy.get().getContext().getAuthentication() 
org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor::getAuthentication -- java.util.function.Supplier::get : this.securityContextHolderStrategy.get().getContext() 
org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor::getAuthentication -- java.util.function.Supplier::get : this.securityContextHolderStrategy.get() 
class AuthorizationManagerAfterReactiveMethodInterceptor  implements org.springframework.security.authorization.method.AuthorizationAdvisor  {
  COROUTINES_FLOW_CLASS_NAME : java.lang.String
  RETURN_TYPE_METHOD_PARAMETER_INDEX : int
  pointcut : org.springframework.aop.Pointcut
  authorizationManager : org.springframework.security.authorization.ReactiveAuthorizationManager
  order : int
  defaultHandler : org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler
  postAuthorize() : org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor
  postAuthorize(authorizationManager : org.springframework.security.authorization.ReactiveAuthorizationManager) : org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor
  AuthorizationManagerAfterReactiveMethodInterceptor(pointcut : org.springframework.aop.Pointcut, authorizationManager : org.springframework.security.authorization.ReactiveAuthorizationManager) : None
  invoke(mi : org.aopalliance.intercept.MethodInvocation) : java.lang.Object
  isMultiValue(returnType : java.lang.Class, adapter : org.springframework.core.ReactiveAdapter) : boolean
  postAuthorize(authentication : reactor.core.publisher.Mono, mi : org.aopalliance.intercept.MethodInvocation, result : java.lang.Object) : reactor.core.publisher.Mono
  postProcess(decision : org.springframework.security.authorization.AuthorizationResult, methodInvocationResult : org.springframework.security.authorization.method.MethodInvocationResult) : reactor.core.publisher.Mono
  postProcess(decision : org.springframework.security.authorization.AuthorizationResult, methodInvocation : org.aopalliance.intercept.MethodInvocation) : reactor.core.publisher.Mono
  getPointcut() : org.springframework.aop.Pointcut
  getAdvice() : org.aopalliance.aop.Advice
  isPerInstance() : boolean
  getOrder() : int
  setOrder(order : int) : void
}
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::postAuthorize -- org.springframework.security.authorization.method.AuthorizationMethodPointcuts::forAnnotations : AuthorizationMethodPointcuts.forAnnotations(PostAuthorize.class) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::AuthorizationManagerAfterReactiveMethodInterceptor -- org.springframework.util.Assert::notNull : Assert.notNull(pointcut,"pointcut cannot be null") 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::AuthorizationManagerAfterReactiveMethodInterceptor -- org.springframework.util.Assert::notNull : Assert.notNull(authorizationManager,"authorizationManager cannot be null") 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- org.aopalliance.intercept.MethodInvocation::getMethod : mi.getMethod() 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- org.springframework.core.KotlinDetector::isSuspendingFunction : KotlinDetector.isSuspendingFunction(method) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.COROUTINES_FLOW_CLASS_NAME::equals : COROUTINES_FLOW_CLASS_NAME.equals(newMethodParameter(method,RETURN_TYPE_METHOD_PARAMETER_INDEX).getParameterType().getName()) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::newMethodParameter : newMethodParameter(method,RETURN_TYPE_METHOD_PARAMETER_INDEX).getParameterType().getName() 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::newMethodParameter : newMethodParameter(method,RETURN_TYPE_METHOD_PARAMETER_INDEX).getParameterType() 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- org.springframework.util.Assert::state : Assert.state(hasReactiveReturnType,()->"The returnType "+type+" on "+method+" must return an instance of org.reactivestreams.Publisher "+"(for example, a Mono or Flux) or the function must be a Kotlin coroutine "+"in order to support Reactor Context") 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.ReactiveAuthenticationUtils::getAuthentication : ReactiveAuthenticationUtils.getAuthentication() 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- reactor.core.publisher.Mono::empty : Mono.empty() 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- reactor.core.publisher.Mono::error : Mono.error(signal.getThrowable()) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- org.springframework.core.ReactiveAdapterRegistry::getSharedInstance : ReactiveAdapterRegistry.getSharedInstance().getAdapter(type) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- org.springframework.core.ReactiveAdapterRegistry::getSharedInstance : ReactiveAdapterRegistry.getSharedInstance() 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.ReactiveMethodInvocationUtils::proceed : ReactiveMethodInvocationUtils.proceed(mi) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- reactor.core.publisher.Flux::from : Flux.from(publisher).materialize().flatMap(postAuthorize) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- reactor.core.publisher.Flux::from : Flux.from(publisher).materialize() 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- reactor.core.publisher.Flux::from : Flux.from(publisher) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- org.springframework.util.Assert::state : Assert.state(adapter!=null,()->"The returnType "+type+" on "+method+" must have a org.springframework.core.ReactiveAdapter registered") 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- reactor.core.publisher.Flux::defer : Flux.defer(()->adapter.toPublisher(ReactiveMethodInvocationUtils.proceed(mi))).materialize().flatMap(postAuthorize) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- reactor.core.publisher.Flux::defer : Flux.defer(()->adapter.toPublisher(ReactiveMethodInvocationUtils.proceed(mi))).materialize() 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- reactor.core.publisher.Flux::defer : Flux.defer(()->adapter.toPublisher(ReactiveMethodInvocationUtils.proceed(mi))) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.ReactiveMethodInvocationUtils::proceed : ReactiveMethodInvocationUtils.proceed(mi) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.KotlinDelegate::asFlow : KotlinDelegate.asFlow(response) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.ReactiveMethodInvocationUtils::proceed : ReactiveMethodInvocationUtils.proceed(mi) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- reactor.core.publisher.Flux::from : Flux.from(publisher).materialize().flatMap(postAuthorize) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- reactor.core.publisher.Flux::from : Flux.from(publisher).materialize() 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- reactor.core.publisher.Flux::from : Flux.from(publisher) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- reactor.core.publisher.Mono::from : Mono.from(publisher).materialize().flatMap(postAuthorize) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- reactor.core.publisher.Mono::from : Mono.from(publisher).materialize() 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::invoke -- reactor.core.publisher.Mono::from : Mono.from(publisher) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::isMultiValue -- org.springframework.core.ReactiveAdapter::isMultiValue : adapter.isMultiValue() 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::postAuthorize -- org.springframework.security.authorization.ReactiveAuthorizationManager::authorize : this.authorizationManager.authorize(authentication,invocationResult).switchIfEmpty(Mono.just(newAuthorizationDecision(false))).flatMap((decision)->postProcess(decision,invocationResult)) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::postAuthorize -- org.springframework.security.authorization.ReactiveAuthorizationManager::authorize : this.authorizationManager.authorize(authentication,invocationResult).switchIfEmpty(Mono.just(newAuthorizationDecision(false))) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::postAuthorize -- org.springframework.security.authorization.ReactiveAuthorizationManager::authorize : this.authorizationManager.authorize(authentication,invocationResult) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::postAuthorize -- reactor.core.publisher.Mono::just : Mono.just(newAuthorizationDecision(false)) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::postProcess -- org.springframework.security.authorization.AuthorizationResult::isGranted : decision.isGranted() 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::postProcess -- reactor.core.publisher.Mono::just : Mono.just(methodInvocationResult.getResult()) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::postProcess -- org.springframework.security.authorization.method.MethodInvocationResult::getResult : methodInvocationResult.getResult() 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::postProcess -- reactor.core.publisher.Mono::fromSupplier : Mono.fromSupplier(()->{if(this.authorizationManagerinstanceofMethodAuthorizationDeniedHandlerhandler){returnhandler.handleDeniedInvocationResult(methodInvocationResult,decision);}returnthis.defaultHandler.handleDeniedInvocationResult(methodInvocationResult,decision);}).flatMap((processedResult)->{if(Mono.class.isAssignableFrom(processedResult.getClass())){return(Mono<?>)processedResult;}returnMono.justOrEmpty(processedResult);}) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::postProcess -- reactor.core.publisher.Mono::fromSupplier : Mono.fromSupplier(()->{if(this.authorizationManagerinstanceofMethodAuthorizationDeniedHandlerhandler){returnhandler.handleDeniedInvocationResult(methodInvocationResult,decision);}returnthis.defaultHandler.handleDeniedInvocationResult(methodInvocationResult,decision);}) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::postProcess -- org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler::handleDeniedInvocationResult : this.defaultHandler.handleDeniedInvocationResult(methodInvocationResult,decision) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::postProcess -- reactor.core.publisher.Mono::justOrEmpty : Mono.justOrEmpty(processedResult) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::postProcess -- reactor.core.publisher.Mono::fromSupplier : Mono.fromSupplier(()->{if(this.authorizationManagerinstanceofMethodAuthorizationDeniedHandlerhandler){returnhandler.handleDeniedInvocation(methodInvocation,decision);}returnthis.defaultHandler.handleDeniedInvocation(methodInvocation,decision);}).flatMap((processedResult)->{if(Mono.class.isAssignableFrom(processedResult.getClass())){return(Mono<?>)processedResult;}returnMono.justOrEmpty(processedResult);}) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::postProcess -- reactor.core.publisher.Mono::fromSupplier : Mono.fromSupplier(()->{if(this.authorizationManagerinstanceofMethodAuthorizationDeniedHandlerhandler){returnhandler.handleDeniedInvocation(methodInvocation,decision);}returnthis.defaultHandler.handleDeniedInvocation(methodInvocation,decision);}) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::postProcess -- org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler::handleDeniedInvocation : this.defaultHandler.handleDeniedInvocation(methodInvocation,decision) 
org.springframework.security.authorization.method.AuthorizationManagerAfterReactiveMethodInterceptor::postProcess -- reactor.core.publisher.Mono::justOrEmpty : Mono.justOrEmpty(processedResult) 
class KotlinDelegate    {
  asFlow(publisher : org.springframework.security.authorization.method.Publisher) : java.lang.Object
}
org.springframework.security.authorization.method.KotlinDelegate::asFlow -- org.springframework.security.authorization.method.ReactiveFlowKt::asFlow : ReactiveFlowKt.asFlow(publisher) 
class AuthorizationManagerBeforeMethodInterceptor  implements org.springframework.security.authorization.method.AuthorizationAdvisor  {
  securityContextHolderStrategy : java.util.function.Supplier
  logger : org.apache.commons.logging.Log
  pointcut : org.springframework.aop.Pointcut
  authorizationManager : org.springframework.security.authorization.AuthorizationManager
  defaultHandler : org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler
  order : int
  eventPublisher : org.springframework.security.authorization.AuthorizationEventPublisher
  AuthorizationManagerBeforeMethodInterceptor(pointcut : org.springframework.aop.Pointcut, authorizationManager : org.springframework.security.authorization.AuthorizationManager) : None
  preAuthorize() : org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor
  preAuthorize(authorizationManager : org.springframework.security.authorization.method.PreAuthorizeAuthorizationManager) : org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor
  preAuthorize(authorizationManager : org.springframework.security.authorization.AuthorizationManager) : org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor
  secured() : org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor
  secured(authorizationManager : org.springframework.security.authorization.method.SecuredAuthorizationManager) : org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor
  secured(authorizationManager : org.springframework.security.authorization.AuthorizationManager) : org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor
  jsr250() : org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor
  jsr250(authorizationManager : org.springframework.security.authorization.method.Jsr250AuthorizationManager) : org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor
  jsr250(authorizationManager : org.springframework.security.authorization.AuthorizationManager) : org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor
  invoke(mi : org.aopalliance.intercept.MethodInvocation) : java.lang.Object
  getOrder() : int
  setOrder(order : int) : void
  setAuthorizationEventPublisher(eventPublisher : org.springframework.security.authorization.AuthorizationEventPublisher) : void
  getPointcut() : org.springframework.aop.Pointcut
  getAdvice() : org.aopalliance.aop.Advice
  isPerInstance() : boolean
  setSecurityContextHolderStrategy(securityContextHolderStrategy : org.springframework.security.core.context.SecurityContextHolderStrategy) : void
  attemptAuthorization(mi : org.aopalliance.intercept.MethodInvocation) : java.lang.Object
  proceed(mi : org.aopalliance.intercept.MethodInvocation) : java.lang.Object
  handle(mi : org.aopalliance.intercept.MethodInvocation, denied : org.springframework.security.authorization.AuthorizationDeniedException) : java.lang.Object
  handle(mi : org.aopalliance.intercept.MethodInvocation, result : org.springframework.security.authorization.AuthorizationResult) : java.lang.Object
  getAuthentication() : org.springframework.security.core.Authentication
}
org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor::AuthorizationManagerBeforeMethodInterceptor -- org.springframework.util.Assert::notNull : Assert.notNull(pointcut,"pointcut cannot be null") 
org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor::AuthorizationManagerBeforeMethodInterceptor -- org.springframework.util.Assert::notNull : Assert.notNull(authorizationManager,"authorizationManager cannot be null") 
org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor::preAuthorize -- org.springframework.security.authorization.method.AuthorizationMethodPointcuts::forAnnotations : AuthorizationMethodPointcuts.forAnnotations(PreAuthorize.class) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor::preAuthorize -- org.springframework.security.authorization.method.AuthorizationMethodPointcuts::forAnnotations : AuthorizationMethodPointcuts.forAnnotations(PreAuthorize.class) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor::secured -- org.springframework.security.authorization.method.AuthorizationMethodPointcuts::forAnnotations : AuthorizationMethodPointcuts.forAnnotations(Secured.class) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor::secured -- org.springframework.security.authorization.method.AuthorizationMethodPointcuts::forAnnotations : AuthorizationMethodPointcuts.forAnnotations(Secured.class) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor::jsr250 -- org.springframework.security.authorization.method.AuthorizationMethodPointcuts::forAnnotations : AuthorizationMethodPointcuts.forAnnotations(RolesAllowed.class,DenyAll.class,PermitAll.class) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor::jsr250 -- org.springframework.security.authorization.method.AuthorizationMethodPointcuts::forAnnotations : AuthorizationMethodPointcuts.forAnnotations(RolesAllowed.class,DenyAll.class,PermitAll.class) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor::setAuthorizationEventPublisher -- org.springframework.util.Assert::notNull : Assert.notNull(eventPublisher,"eventPublisher cannot be null") 
org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor::attemptAuthorization -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.of(()->"Authorizing method invocation "+mi)) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor::attemptAuthorization -- org.springframework.core.log.LogMessage::of : LogMessage.of(()->"Authorizing method invocation "+mi) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor::attemptAuthorization -- org.springframework.security.authorization.AuthorizationManager::authorize : this.authorizationManager.authorize(this::getAuthentication,mi) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor::attemptAuthorization -- org.springframework.security.authorization.AuthorizationEventPublisher::publishAuthorizationEvent : this.eventPublisher.publishAuthorizationEvent(this::getAuthentication,mi,result) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor::attemptAuthorization -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.of(()->"Failed to authorize "+mi+" with authorization manager "+this.authorizationManager+" and result "+result)) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor::attemptAuthorization -- org.springframework.core.log.LogMessage::of : LogMessage.of(()->"Failed to authorize "+mi+" with authorization manager "+this.authorizationManager+" and result "+result) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor::attemptAuthorization -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.of(()->"Authorized method invocation "+mi)) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor::attemptAuthorization -- org.springframework.core.log.LogMessage::of : LogMessage.of(()->"Authorized method invocation "+mi) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor::proceed -- org.aopalliance.intercept.MethodInvocation::proceed : mi.proceed() 
org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor::proceed -- org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler::handleDeniedInvocation : this.defaultHandler.handleDeniedInvocation(mi,ex) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor::handle -- org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler::handleDeniedInvocation : this.defaultHandler.handleDeniedInvocation(mi,denied) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor::handle -- org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler::handleDeniedInvocation : this.defaultHandler.handleDeniedInvocation(mi,result) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor::getAuthentication -- java.util.function.Supplier::get : this.securityContextHolderStrategy.get().getContext().getAuthentication() 
org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor::getAuthentication -- java.util.function.Supplier::get : this.securityContextHolderStrategy.get().getContext() 
org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor::getAuthentication -- java.util.function.Supplier::get : this.securityContextHolderStrategy.get() 
class AuthorizationManagerBeforeReactiveMethodInterceptor  implements org.springframework.security.authorization.method.AuthorizationAdvisor  {
  COROUTINES_FLOW_CLASS_NAME : java.lang.String
  RETURN_TYPE_METHOD_PARAMETER_INDEX : int
  pointcut : org.springframework.aop.Pointcut
  authorizationManager : org.springframework.security.authorization.ReactiveAuthorizationManager
  order : int
  defaultHandler : org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler
  preAuthorize() : org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor
  preAuthorize(authorizationManager : org.springframework.security.authorization.ReactiveAuthorizationManager) : org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor
  AuthorizationManagerBeforeReactiveMethodInterceptor(pointcut : org.springframework.aop.Pointcut, authorizationManager : org.springframework.security.authorization.ReactiveAuthorizationManager) : None
  invoke(mi : org.aopalliance.intercept.MethodInvocation) : java.lang.Object
  preAuthorized(mi : org.aopalliance.intercept.MethodInvocation, mapping : reactor.core.publisher.Flux) : reactor.core.publisher.Flux
  preAuthorized(mi : org.aopalliance.intercept.MethodInvocation, mapping : reactor.core.publisher.Mono) : reactor.core.publisher.Mono
  postProcess(decision : org.springframework.security.authorization.AuthorizationResult, mi : org.aopalliance.intercept.MethodInvocation) : reactor.core.publisher.Mono
  isMultiValue(returnType : java.lang.Class, adapter : org.springframework.core.ReactiveAdapter) : boolean
  getPointcut() : org.springframework.aop.Pointcut
  getAdvice() : org.aopalliance.aop.Advice
  isPerInstance() : boolean
  getOrder() : int
  setOrder(order : int) : void
}
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::preAuthorize -- org.springframework.security.authorization.method.AuthorizationMethodPointcuts::forAnnotations : AuthorizationMethodPointcuts.forAnnotations(PreAuthorize.class) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::AuthorizationManagerBeforeReactiveMethodInterceptor -- org.springframework.util.Assert::notNull : Assert.notNull(pointcut,"pointcut cannot be null") 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::AuthorizationManagerBeforeReactiveMethodInterceptor -- org.springframework.util.Assert::notNull : Assert.notNull(authorizationManager,"authorizationManager cannot be null") 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::invoke -- org.aopalliance.intercept.MethodInvocation::getMethod : mi.getMethod() 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::invoke -- org.springframework.core.KotlinDetector::isSuspendingFunction : KotlinDetector.isSuspendingFunction(method) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.COROUTINES_FLOW_CLASS_NAME::equals : COROUTINES_FLOW_CLASS_NAME.equals(newMethodParameter(method,RETURN_TYPE_METHOD_PARAMETER_INDEX).getParameterType().getName()) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::newMethodParameter : newMethodParameter(method,RETURN_TYPE_METHOD_PARAMETER_INDEX).getParameterType().getName() 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::newMethodParameter : newMethodParameter(method,RETURN_TYPE_METHOD_PARAMETER_INDEX).getParameterType() 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::invoke -- org.springframework.util.Assert::state : Assert.state(hasReactiveReturnType,()->"The returnType "+type+" on "+method+" must return an instance of org.reactivestreams.Publisher "+"(for example, a Mono or Flux) or the function must be a Kotlin coroutine "+"in order to support Reactor Context") 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::invoke -- org.springframework.core.ReactiveAdapterRegistry::getSharedInstance : ReactiveAdapterRegistry.getSharedInstance().getAdapter(type) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::invoke -- org.springframework.core.ReactiveAdapterRegistry::getSharedInstance : ReactiveAdapterRegistry.getSharedInstance() 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::invoke -- reactor.core.publisher.Flux::defer : Flux.defer(()->ReactiveMethodInvocationUtils.proceed(mi)) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.ReactiveMethodInvocationUtils::proceed : ReactiveMethodInvocationUtils.proceed(mi) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::invoke -- org.springframework.util.Assert::state : Assert.state(adapter!=null,()->"The returnType "+type+" on "+method+" must have a org.springframework.core.ReactiveAdapter registered") 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::invoke -- reactor.core.publisher.Flux::defer : Flux.defer(()->adapter.toPublisher(ReactiveMethodInvocationUtils.proceed(mi))) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.ReactiveMethodInvocationUtils::proceed : ReactiveMethodInvocationUtils.proceed(mi) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.KotlinDelegate::asFlow : KotlinDelegate.asFlow(response) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::invoke -- reactor.core.publisher.Flux::defer : Flux.defer(()->ReactiveMethodInvocationUtils.proceed(mi)) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.ReactiveMethodInvocationUtils::proceed : ReactiveMethodInvocationUtils.proceed(mi) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::invoke -- reactor.core.publisher.Mono::defer : Mono.defer(()->ReactiveMethodInvocationUtils.proceed(mi)) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.ReactiveMethodInvocationUtils::proceed : ReactiveMethodInvocationUtils.proceed(mi) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::preAuthorized -- org.springframework.security.authorization.method.ReactiveAuthenticationUtils::getAuthentication : ReactiveAuthenticationUtils.getAuthentication() 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::preAuthorized -- org.springframework.security.authorization.ReactiveAuthorizationManager::authorize : this.authorizationManager.authorize(authentication,mi).switchIfEmpty(Mono.just(newAuthorizationDecision(false))).flatMapMany((decision)->{if(decision.isGranted()){returnmapping.onErrorResume(AuthorizationDeniedException.class,(deniedEx)->postProcess(deniedEx,mi));}returnpostProcess(decision,mi);}) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::preAuthorized -- org.springframework.security.authorization.ReactiveAuthorizationManager::authorize : this.authorizationManager.authorize(authentication,mi).switchIfEmpty(Mono.just(newAuthorizationDecision(false))) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::preAuthorized -- org.springframework.security.authorization.ReactiveAuthorizationManager::authorize : this.authorizationManager.authorize(authentication,mi) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::preAuthorized -- reactor.core.publisher.Mono::just : Mono.just(newAuthorizationDecision(false)) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::preAuthorized -- reactor.core.publisher.Flux::onErrorResume : mapping.onErrorResume(AuthorizationDeniedException.class,(deniedEx)->postProcess(deniedEx,mi)) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::preAuthorized -- org.springframework.security.authorization.method.ReactiveAuthenticationUtils::getAuthentication : ReactiveAuthenticationUtils.getAuthentication() 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::preAuthorized -- org.springframework.security.authorization.ReactiveAuthorizationManager::authorize : this.authorizationManager.authorize(authentication,mi).switchIfEmpty(Mono.just(newAuthorizationDecision(false))).flatMap((decision)->{if(decision.isGranted()){returnmapping.onErrorResume(AuthorizationDeniedException.class,(deniedEx)->postProcess(deniedEx,mi));}returnpostProcess(decision,mi);}) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::preAuthorized -- org.springframework.security.authorization.ReactiveAuthorizationManager::authorize : this.authorizationManager.authorize(authentication,mi).switchIfEmpty(Mono.just(newAuthorizationDecision(false))) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::preAuthorized -- org.springframework.security.authorization.ReactiveAuthorizationManager::authorize : this.authorizationManager.authorize(authentication,mi) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::preAuthorized -- reactor.core.publisher.Mono::just : Mono.just(newAuthorizationDecision(false)) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::preAuthorized -- reactor.core.publisher.Mono::onErrorResume : mapping.onErrorResume(AuthorizationDeniedException.class,(deniedEx)->postProcess(deniedEx,mi)) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::postProcess -- reactor.core.publisher.Mono::fromSupplier : Mono.fromSupplier(()->{if(this.authorizationManagerinstanceofMethodAuthorizationDeniedHandlerhandler){returnhandler.handleDeniedInvocation(mi,decision);}returnthis.defaultHandler.handleDeniedInvocation(mi,decision);}).flatMap((result)->{if(Mono.class.isAssignableFrom(result.getClass())){return(Mono<?>)result;}returnMono.justOrEmpty(result);}) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::postProcess -- reactor.core.publisher.Mono::fromSupplier : Mono.fromSupplier(()->{if(this.authorizationManagerinstanceofMethodAuthorizationDeniedHandlerhandler){returnhandler.handleDeniedInvocation(mi,decision);}returnthis.defaultHandler.handleDeniedInvocation(mi,decision);}) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::postProcess -- org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler::handleDeniedInvocation : this.defaultHandler.handleDeniedInvocation(mi,decision) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::postProcess -- reactor.core.publisher.Mono::justOrEmpty : Mono.justOrEmpty(result) 
org.springframework.security.authorization.method.AuthorizationManagerBeforeReactiveMethodInterceptor::isMultiValue -- org.springframework.core.ReactiveAdapter::isMultiValue : adapter.isMultiValue() 
class KotlinDelegate    {
  asFlow(publisher : org.springframework.security.authorization.method.Publisher) : java.lang.Object
}
org.springframework.security.authorization.method.KotlinDelegate::asFlow -- org.springframework.security.authorization.method.ReactiveFlowKt::asFlow : ReactiveFlowKt.asFlow(publisher) 
class AuthorizationMethodPointcuts    {
  forAllAnnotations() : org.springframework.aop.Pointcut
  forAnnotations() : org.springframework.aop.Pointcut
  classOrMethod(annotation : java.lang.Class) : org.springframework.aop.Pointcut
  AuthorizationMethodPointcuts() : None
}
org.springframework.security.authorization.method.AuthorizationMethodPointcuts::classOrMethod -- org.springframework.aop.support.Pointcuts::union : Pointcuts.union(newAnnotationMatchingPointcut(null,annotation,true),newAnnotationMatchingPointcut(annotation,true)) 
interface AuthorizationProxy    {
  toAuthorizedTarget() : java.lang.Object
}
class AuthorizeReturnObjectMethodInterceptor  implements org.springframework.security.authorization.method.AuthorizationAdvisor  {
  authorizationProxyFactory : org.springframework.security.authorization.AuthorizationProxyFactory
  pointcut : org.springframework.aop.Pointcut
  order : int
  AuthorizeReturnObjectMethodInterceptor(authorizationProxyFactory : org.springframework.security.authorization.AuthorizationProxyFactory) : None
  invoke(mi : org.aopalliance.intercept.MethodInvocation) : java.lang.Object
  getOrder() : int
  setOrder(order : int) : void
  getPointcut() : org.springframework.aop.Pointcut
  setPointcut(pointcut : org.springframework.aop.Pointcut) : void
  getAdvice() : org.aopalliance.aop.Advice
  isPerInstance() : boolean
}
org.springframework.security.authorization.method.AuthorizeReturnObjectMethodInterceptor::AuthorizeReturnObjectMethodInterceptor -- org.springframework.util.Assert::notNull : Assert.notNull(authorizationProxyFactory,"authorizationManager cannot be null") 
org.springframework.security.authorization.method.AuthorizeReturnObjectMethodInterceptor::invoke -- org.aopalliance.intercept.MethodInvocation::proceed : mi.proceed() 
org.springframework.security.authorization.method.AuthorizeReturnObjectMethodInterceptor::invoke -- org.springframework.security.authorization.AuthorizationProxyFactory::proxy : this.authorizationProxyFactory.proxy(result) 
class MethodReturnTypePointcut extends org.springframework.security.authorization.method.StaticMethodMatcherPointcut   {
  returnTypeMatches : org.springframework.security.authorization.method.Predicate
  MethodReturnTypePointcut(returnTypeMatches : org.springframework.security.authorization.method.Predicate) : None
  matches(method : org.springframework.security.authorization.method.Method, targetClass : java.lang.Class) : boolean
}
org.springframework.security.authorization.method.MethodReturnTypePointcut::matches -- org.springframework.security.authorization.method.Predicate::test : this.returnTypeMatches.test(method.getReturnType()) 
org.springframework.security.authorization.method.MethodReturnTypePointcut::matches -- org.springframework.security.authorization.method.Method::getReturnType : method.getReturnType() 
class ExpressionAttribute    {
  NULL_ATTRIBUTE : org.springframework.security.authorization.method.ExpressionAttribute
  expression : org.springframework.expression.Expression
  ExpressionAttribute(expression : org.springframework.expression.Expression) : None
  getExpression() : org.springframework.expression.Expression
  toString() : java.lang.String
}
org.springframework.security.authorization.method.ExpressionAttribute::toString -- org.springframework.security.authorization.method.ExpressionAttribute::getClass : getClass().getSimpleName() 
org.springframework.security.authorization.method.ExpressionAttribute::toString -- org.springframework.expression.Expression::getExpressionString : this.expression.getExpressionString() 
class ExpressionAttributeAuthorizationDecision extends org.springframework.security.authorization.AuthorizationDecision   {
  expressionAttribute : org.springframework.security.authorization.method.ExpressionAttribute
  ExpressionAttributeAuthorizationDecision(granted : boolean, expressionAttribute : org.springframework.security.authorization.method.ExpressionAttribute) : None
  getExpressionAttribute() : org.springframework.security.authorization.method.ExpressionAttribute
  toString() : java.lang.String
}
org.springframework.security.authorization.method.ExpressionAttributeAuthorizationDecision::toString -- org.springframework.security.authorization.method.ExpressionAttributeAuthorizationDecision::getClass : getClass().getSimpleName() 
class ExpressionUtils    {
  ExpressionUtils() : None
  evaluate(expr : org.springframework.expression.Expression, ctx : org.springframework.expression.EvaluationContext) : org.springframework.security.authorization.AuthorizationResult
  findAuthorizationException(ex : org.springframework.expression.EvaluationException) : org.springframework.security.authorization.AuthorizationDeniedException
}
org.springframework.security.authorization.method.ExpressionUtils::evaluate -- org.springframework.expression.Expression::getValue : expr.getValue(ctx) 
org.springframework.security.authorization.method.ExpressionUtils::evaluate -- org.springframework.expression.Expression::getExpressionString : expr.getExpressionString() 
org.springframework.security.authorization.method.ExpressionUtils::findAuthorizationException -- org.springframework.expression.EvaluationException::getCause : ex.getCause() 
class Jsr250AuthorizationManager  implements org.springframework.security.authorization.AuthorizationManager  {
  registry : org.springframework.security.authorization.method.Jsr250AuthorizationManagerRegistry
  authoritiesAuthorizationManager : org.springframework.security.authorization.AuthorizationManager
  rolePrefix : java.lang.String
  setAuthoritiesAuthorizationManager(authoritiesAuthorizationManager : org.springframework.security.authorization.AuthorizationManager) : void
  setRolePrefix(rolePrefix : java.lang.String) : void
  check(authentication : java.util.function.Supplier, methodInvocation : org.aopalliance.intercept.MethodInvocation) : org.springframework.security.authorization.AuthorizationDecision
}
org.springframework.security.authorization.method.Jsr250AuthorizationManager::setAuthoritiesAuthorizationManager -- org.springframework.util.Assert::notNull : Assert.notNull(authoritiesAuthorizationManager,"authoritiesAuthorizationManager cannot be null") 
org.springframework.security.authorization.method.Jsr250AuthorizationManager::setRolePrefix -- org.springframework.util.Assert::notNull : Assert.notNull(rolePrefix,"rolePrefix cannot be null") 
org.springframework.security.authorization.method.Jsr250AuthorizationManager::check -- org.springframework.security.authorization.method.Jsr250AuthorizationManagerRegistry::getManager : this.registry.getManager(methodInvocation) 
class Jsr250AuthorizationManagerRegistry extends org.springframework.security.authorization.method.AbstractAuthorizationManagerRegistry   {
  scanner : org.springframework.security.authorization.method.SecurityAnnotationScanner
  resolveManager(method : org.springframework.security.authorization.method.Method, targetClass : java.lang.Class) : org.springframework.security.authorization.method.AuthorizationManager
  findJsr250Annotation(method : org.springframework.security.authorization.method.Method, targetClass : java.lang.Class) : org.springframework.security.authorization.method.Annotation
  getAllowedRolesWithPrefix(rolesAllowed : org.springframework.security.authorization.method.RolesAllowed) : org.springframework.security.authorization.method.Set
}
org.springframework.security.authorization.method.Jsr250AuthorizationManagerRegistry::resolveManager -- org.springframework.security.authorization.method.SingleResultAuthorizationManager::denyAll : SingleResultAuthorizationManager.denyAll() 
org.springframework.security.authorization.method.Jsr250AuthorizationManagerRegistry::resolveManager -- org.springframework.security.authorization.method.SingleResultAuthorizationManager::permitAll : SingleResultAuthorizationManager.permitAll() 
org.springframework.security.authorization.method.Jsr250AuthorizationManagerRegistry::findJsr250Annotation -- org.springframework.security.authorization.method.Method::getDeclaringClass : method.getDeclaringClass() 
org.springframework.security.authorization.method.Jsr250AuthorizationManagerRegistry::findJsr250Annotation -- org.springframework.security.authorization.method.SecurityAnnotationScanner::scan : this.scanner.scan(method,targetClassToUse) 
org.springframework.security.authorization.method.Jsr250AuthorizationManagerRegistry::getAllowedRolesWithPrefix -- org.springframework.security.authorization.method.RolesAllowed::value : rolesAllowed.value().length 
org.springframework.security.authorization.method.Jsr250AuthorizationManagerRegistry::getAllowedRolesWithPrefix -- org.springframework.security.authorization.method.RolesAllowed::value : rolesAllowed.value() 
org.springframework.security.authorization.method.Jsr250AuthorizationManagerRegistry::getAllowedRolesWithPrefix -- org.springframework.security.authorization.method.RolesAllowed::value : rolesAllowed.value() 
interface AuthorizationManagerCheckAdapter    {
  check(authentication : org.springframework.security.authorization.method.Supplier, object : org.springframework.security.authorization.method.T) : org.springframework.security.authorization.method.AuthorizationDecision
  authorize(authentication : org.springframework.security.authorization.method.Supplier, object : org.springframework.security.authorization.method.T) : org.springframework.security.authorization.method.AuthorizationResult
}
interface MethodAuthorizationDeniedHandler    {
  handleDeniedInvocation(methodInvocation : org.aopalliance.intercept.MethodInvocation, authorizationResult : org.springframework.security.authorization.AuthorizationResult) : java.lang.Object
  handleDeniedInvocationResult(methodInvocationResult : org.springframework.security.authorization.method.MethodInvocationResult, authorizationResult : org.springframework.security.authorization.AuthorizationResult) : java.lang.Object
}
org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler::handleDeniedInvocationResult -- org.springframework.security.authorization.method.MethodInvocationResult::getMethodInvocation : methodInvocationResult.getMethodInvocation() 
class MethodExpressionAuthorizationManager  implements org.springframework.security.authorization.AuthorizationManager  {
  expressionHandler : org.springframework.security.access.expression.SecurityExpressionHandler
  expression : org.springframework.expression.Expression
  MethodExpressionAuthorizationManager(expressionString : java.lang.String) : None
  setExpressionHandler(expressionHandler : org.springframework.security.access.expression.SecurityExpressionHandler) : void
  check(authentication : java.util.function.Supplier, context : org.aopalliance.intercept.MethodInvocation) : org.springframework.security.authorization.AuthorizationDecision
  toString() : java.lang.String
}
org.springframework.security.authorization.method.MethodExpressionAuthorizationManager::MethodExpressionAuthorizationManager -- org.springframework.util.Assert::hasText : Assert.hasText(expressionString,"expressionString cannot be empty") 
org.springframework.security.authorization.method.MethodExpressionAuthorizationManager::MethodExpressionAuthorizationManager -- org.springframework.security.access.expression.SecurityExpressionHandler::getExpressionParser : this.expressionHandler.getExpressionParser().parseExpression(expressionString) 
org.springframework.security.authorization.method.MethodExpressionAuthorizationManager::MethodExpressionAuthorizationManager -- org.springframework.security.access.expression.SecurityExpressionHandler::getExpressionParser : this.expressionHandler.getExpressionParser() 
org.springframework.security.authorization.method.MethodExpressionAuthorizationManager::setExpressionHandler -- org.springframework.util.Assert::notNull : Assert.notNull(expressionHandler,"expressionHandler cannot be null") 
org.springframework.security.authorization.method.MethodExpressionAuthorizationManager::setExpressionHandler -- org.springframework.security.access.expression.SecurityExpressionHandler::getExpressionParser : expressionHandler.getExpressionParser().parseExpression(this.expression.getExpressionString()) 
org.springframework.security.authorization.method.MethodExpressionAuthorizationManager::setExpressionHandler -- org.springframework.security.access.expression.SecurityExpressionHandler::getExpressionParser : expressionHandler.getExpressionParser() 
org.springframework.security.authorization.method.MethodExpressionAuthorizationManager::setExpressionHandler -- org.springframework.expression.Expression::getExpressionString : this.expression.getExpressionString() 
org.springframework.security.authorization.method.MethodExpressionAuthorizationManager::check -- org.springframework.security.access.expression.SecurityExpressionHandler::createEvaluationContext : this.expressionHandler.createEvaluationContext(authentication,context) 
org.springframework.security.authorization.method.MethodExpressionAuthorizationManager::check -- org.springframework.security.access.expression.ExpressionUtils::evaluateAsBoolean : ExpressionUtils.evaluateAsBoolean(this.expression,ctx) 
class MethodInvocationResult    {
  methodInvocation : org.aopalliance.intercept.MethodInvocation
  result : java.lang.Object
  MethodInvocationResult(methodInvocation : org.aopalliance.intercept.MethodInvocation, result : java.lang.Object) : None
  getMethodInvocation() : org.aopalliance.intercept.MethodInvocation
  getResult() : java.lang.Object
}
org.springframework.security.authorization.method.MethodInvocationResult::MethodInvocationResult -- org.springframework.util.Assert::notNull : Assert.notNull(methodInvocation,"methodInvocation cannot be null") 
class NoOpAuthorizationEventPublisher  implements org.springframework.security.authorization.AuthorizationEventPublisher  {
  publishAuthorizationEvent(authentication : java.util.function.Supplier, object : org.springframework.security.authorization.method.T, decision : org.springframework.security.authorization.AuthorizationDecision) : void
  publishAuthorizationEvent(authentication : java.util.function.Supplier, object : org.springframework.security.authorization.method.T, result : org.springframework.security.authorization.AuthorizationResult) : void
}
class PostAuthorizeAuthorizationManager  implements org.springframework.security.authorization.AuthorizationManager  {
  registry : org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry
  setExpressionHandler(expressionHandler : org.springframework.security.access.expression.method.MethodSecurityExpressionHandler) : void
  setTemplateDefaults(defaults : org.springframework.security.authorization.method.PrePostTemplateDefaults) : void
  setTemplateDefaults(defaults : org.springframework.security.core.annotation.AnnotationTemplateExpressionDefaults) : void
  setApplicationContext(context : org.springframework.context.ApplicationContext) : void
  check(authentication : java.util.function.Supplier, mi : org.springframework.security.authorization.method.MethodInvocationResult) : org.springframework.security.authorization.AuthorizationDecision
  handleDeniedInvocation(methodInvocation : org.aopalliance.intercept.MethodInvocation, authorizationResult : org.springframework.security.authorization.AuthorizationResult) : java.lang.Object
  handleDeniedInvocationResult(methodInvocationResult : org.springframework.security.authorization.method.MethodInvocationResult, authorizationResult : org.springframework.security.authorization.AuthorizationResult) : java.lang.Object
}
org.springframework.security.authorization.method.PostAuthorizeAuthorizationManager::setExpressionHandler -- org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::setExpressionHandler : this.registry.setExpressionHandler(expressionHandler) 
org.springframework.security.authorization.method.PostAuthorizeAuthorizationManager::setTemplateDefaults -- org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::setTemplateDefaults : this.registry.setTemplateDefaults(defaults) 
org.springframework.security.authorization.method.PostAuthorizeAuthorizationManager::setTemplateDefaults -- org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::setTemplateDefaults : this.registry.setTemplateDefaults(defaults) 
org.springframework.security.authorization.method.PostAuthorizeAuthorizationManager::setApplicationContext -- org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::setApplicationContext : this.registry.setApplicationContext(context) 
org.springframework.security.authorization.method.PostAuthorizeAuthorizationManager::check -- org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::getAttribute : this.registry.getAttribute(mi.getMethodInvocation()) 
org.springframework.security.authorization.method.PostAuthorizeAuthorizationManager::check -- org.springframework.security.authorization.method.MethodInvocationResult::getMethodInvocation : mi.getMethodInvocation() 
org.springframework.security.authorization.method.PostAuthorizeAuthorizationManager::check -- org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::getExpressionHandler : this.registry.getExpressionHandler() 
org.springframework.security.authorization.method.PostAuthorizeAuthorizationManager::check -- org.springframework.security.authorization.method.MethodInvocationResult::getMethodInvocation : mi.getMethodInvocation() 
org.springframework.security.authorization.method.PostAuthorizeAuthorizationManager::check -- org.springframework.security.authorization.method.MethodInvocationResult::getResult : mi.getResult() 
org.springframework.security.authorization.method.PostAuthorizeAuthorizationManager::check -- org.springframework.security.authorization.method.ExpressionUtils::evaluate : ExpressionUtils.evaluate(attribute.getExpression(),ctx) 
org.springframework.security.authorization.method.PostAuthorizeAuthorizationManager::handleDeniedInvocation -- org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::getAttribute : this.registry.getAttribute(methodInvocation) 
org.springframework.security.authorization.method.PostAuthorizeAuthorizationManager::handleDeniedInvocationResult -- org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::getAttribute : this.registry.getAttribute(methodInvocationResult.getMethodInvocation()) 
org.springframework.security.authorization.method.PostAuthorizeAuthorizationManager::handleDeniedInvocationResult -- org.springframework.security.authorization.method.MethodInvocationResult::getMethodInvocation : methodInvocationResult.getMethodInvocation() 
class PostAuthorizeExpressionAttribute extends org.springframework.security.authorization.method.ExpressionAttribute   {
  handler : org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler
  PostAuthorizeExpressionAttribute(expression : org.springframework.expression.Expression, handler : org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler) : None
  getHandler() : org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler
}
org.springframework.security.authorization.method.PostAuthorizeExpressionAttribute::PostAuthorizeExpressionAttribute -- org.springframework.util.Assert::notNull : Assert.notNull(handler,"handler cannot be null") 
class PostAuthorizeExpressionAttributeRegistry extends org.springframework.security.authorization.method.AbstractExpressionAttributeRegistry   {
  defaultHandler : org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler
  handleAuthorizationDeniedScanner : org.springframework.security.core.annotation.SecurityAnnotationScanner
  handlerResolver : java.util.function.Function
  postAuthorizeScanner : org.springframework.security.core.annotation.SecurityAnnotationScanner
  PostAuthorizeExpressionAttributeRegistry() : None
  resolveAttribute(method : java.lang.reflect.Method, targetClass : java.lang.Class) : org.springframework.security.authorization.method.ExpressionAttribute
  resolveHandler(method : java.lang.reflect.Method, targetClass : java.lang.Class) : org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler
  findPostAuthorizeAnnotation(method : java.lang.reflect.Method, targetClass : java.lang.Class) : org.springframework.security.access.prepost.PostAuthorize
  setApplicationContext(context : org.springframework.context.ApplicationContext) : void
  setTemplateDefaults(templateDefaults : org.springframework.security.core.annotation.AnnotationTemplateExpressionDefaults) : void
  resolveHandler(context : org.springframework.context.ApplicationContext, handlerClass : java.lang.Class) : org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler
}
org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::resolveAttribute -- org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::getExpressionHandler : getExpressionHandler().getExpressionParser().parseExpression(postAuthorize.value()) 
org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::resolveAttribute -- org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::getExpressionHandler : getExpressionHandler().getExpressionParser() 
org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::resolveHandler -- org.springframework.security.core.annotation.SecurityAnnotationScanner::scan : this.handleAuthorizationDeniedScanner.scan(method,targetClassToUse) 
org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::resolveHandler -- java.util.function.Function::apply : this.handlerResolver.apply(deniedHandler.handlerClass()) 
org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::findPostAuthorizeAnnotation -- org.springframework.security.core.annotation.SecurityAnnotationScanner::scan : this.postAuthorizeScanner.scan(method,targetClassToUse) 
org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::setApplicationContext -- org.springframework.util.Assert::notNull : Assert.notNull(context,"context cannot be null") 
org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::setTemplateDefaults -- org.springframework.security.core.annotation.SecurityAnnotationScanners::requireUnique : SecurityAnnotationScanners.requireUnique(PostAuthorize.class,templateDefaults) 
org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::resolveHandler -- org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler::getClass : this.defaultHandler.getClass() 
org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::resolveHandler -- org.springframework.context.ApplicationContext::getBeanNamesForType : context.getBeanNamesForType(handlerClass) 
org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::resolveHandler -- java.lang.Class::getName : handlerClass.getName() 
org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::resolveHandler -- java.lang.Class::getName : handlerClass.getName() 
org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::resolveHandler -- java.util.Arrays::toString : Arrays.toString(beanNames) 
org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::resolveHandler -- org.springframework.context.ApplicationContext::getBean : context.getBean(beanNames[0],handlerClass) 
class PostAuthorizeReactiveAuthorizationManager  implements org.springframework.security.authorization.ReactiveAuthorizationManager  {
  registry : org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry
  PostAuthorizeReactiveAuthorizationManager() : None
  PostAuthorizeReactiveAuthorizationManager(expressionHandler : org.springframework.security.access.expression.method.MethodSecurityExpressionHandler) : None
  setTemplateDefaults(defaults : org.springframework.security.authorization.method.PrePostTemplateDefaults) : void
  setTemplateDefaults(defaults : org.springframework.security.core.annotation.AnnotationTemplateExpressionDefaults) : void
  setApplicationContext(context : org.springframework.context.ApplicationContext) : void
  check(authentication : reactor.core.publisher.Mono, result : org.springframework.security.authorization.method.MethodInvocationResult) : reactor.core.publisher.Mono
  handleDeniedInvocation(methodInvocation : org.aopalliance.intercept.MethodInvocation, authorizationResult : org.springframework.security.authorization.AuthorizationResult) : java.lang.Object
  handleDeniedInvocationResult(methodInvocationResult : org.springframework.security.authorization.method.MethodInvocationResult, authorizationResult : org.springframework.security.authorization.AuthorizationResult) : java.lang.Object
}
org.springframework.security.authorization.method.PostAuthorizeReactiveAuthorizationManager::PostAuthorizeReactiveAuthorizationManager -- org.springframework.util.Assert::notNull : Assert.notNull(expressionHandler,"expressionHandler cannot be null") 
org.springframework.security.authorization.method.PostAuthorizeReactiveAuthorizationManager::PostAuthorizeReactiveAuthorizationManager -- org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::setExpressionHandler : this.registry.setExpressionHandler(expressionHandler) 
org.springframework.security.authorization.method.PostAuthorizeReactiveAuthorizationManager::setTemplateDefaults -- org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::setTemplateDefaults : this.registry.setTemplateDefaults(defaults) 
org.springframework.security.authorization.method.PostAuthorizeReactiveAuthorizationManager::setTemplateDefaults -- org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::setTemplateDefaults : this.registry.setTemplateDefaults(defaults) 
org.springframework.security.authorization.method.PostAuthorizeReactiveAuthorizationManager::setApplicationContext -- org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::setApplicationContext : this.registry.setApplicationContext(context) 
org.springframework.security.authorization.method.PostAuthorizeReactiveAuthorizationManager::check -- org.springframework.security.authorization.method.MethodInvocationResult::getMethodInvocation : result.getMethodInvocation() 
org.springframework.security.authorization.method.PostAuthorizeReactiveAuthorizationManager::check -- org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::getAttribute : this.registry.getAttribute(mi) 
org.springframework.security.authorization.method.PostAuthorizeReactiveAuthorizationManager::check -- reactor.core.publisher.Mono::empty : Mono.empty() 
org.springframework.security.authorization.method.PostAuthorizeReactiveAuthorizationManager::check -- org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::getExpressionHandler : this.registry.getExpressionHandler() 
org.springframework.security.authorization.method.PostAuthorizeReactiveAuthorizationManager::check -- reactor.core.publisher.Mono::map : authentication.map((auth)->expressionHandler.createEvaluationContext(auth,mi)).doOnNext((ctx)->expressionHandler.setReturnObject(result.getResult(),ctx)).flatMap((ctx)->ReactiveExpressionUtils.evaluate(attribute.getExpression(),ctx)).cast(AuthorizationDecision.class) 
org.springframework.security.authorization.method.PostAuthorizeReactiveAuthorizationManager::check -- reactor.core.publisher.Mono::map : authentication.map((auth)->expressionHandler.createEvaluationContext(auth,mi)).doOnNext((ctx)->expressionHandler.setReturnObject(result.getResult(),ctx)).flatMap((ctx)->ReactiveExpressionUtils.evaluate(attribute.getExpression(),ctx)) 
org.springframework.security.authorization.method.PostAuthorizeReactiveAuthorizationManager::check -- reactor.core.publisher.Mono::map : authentication.map((auth)->expressionHandler.createEvaluationContext(auth,mi)).doOnNext((ctx)->expressionHandler.setReturnObject(result.getResult(),ctx)) 
org.springframework.security.authorization.method.PostAuthorizeReactiveAuthorizationManager::check -- reactor.core.publisher.Mono::map : authentication.map((auth)->expressionHandler.createEvaluationContext(auth,mi)) 
org.springframework.security.authorization.method.PostAuthorizeReactiveAuthorizationManager::check -- org.springframework.security.authorization.method.MethodInvocationResult::getResult : result.getResult() 
org.springframework.security.authorization.method.PostAuthorizeReactiveAuthorizationManager::check -- org.springframework.security.authorization.method.ReactiveExpressionUtils::evaluate : ReactiveExpressionUtils.evaluate(attribute.getExpression(),ctx) 
org.springframework.security.authorization.method.PostAuthorizeReactiveAuthorizationManager::handleDeniedInvocation -- org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::getAttribute : this.registry.getAttribute(methodInvocation) 
org.springframework.security.authorization.method.PostAuthorizeReactiveAuthorizationManager::handleDeniedInvocationResult -- org.springframework.security.authorization.method.PostAuthorizeExpressionAttributeRegistry::getAttribute : this.registry.getAttribute(methodInvocationResult.getMethodInvocation()) 
org.springframework.security.authorization.method.PostAuthorizeReactiveAuthorizationManager::handleDeniedInvocationResult -- org.springframework.security.authorization.method.MethodInvocationResult::getMethodInvocation : methodInvocationResult.getMethodInvocation() 
class PostFilterAuthorizationMethodInterceptor  implements org.springframework.security.authorization.method.AuthorizationAdvisor  {
  securityContextHolderStrategy : java.util.function.Supplier
  registry : org.springframework.security.authorization.method.PostFilterExpressionAttributeRegistry
  order : int
  pointcut : org.springframework.aop.Pointcut
  PostFilterAuthorizationMethodInterceptor() : None
  setExpressionHandler(expressionHandler : org.springframework.security.access.expression.method.MethodSecurityExpressionHandler) : void
  setTemplateDefaults(defaults : org.springframework.security.authorization.method.PrePostTemplateDefaults) : void
  setTemplateDefaults(defaults : org.springframework.security.core.annotation.AnnotationTemplateExpressionDefaults) : void
  getOrder() : int
  setOrder(order : int) : void
  getPointcut() : org.springframework.aop.Pointcut
  getAdvice() : org.aopalliance.aop.Advice
  isPerInstance() : boolean
  setSecurityContextHolderStrategy(strategy : org.springframework.security.core.context.SecurityContextHolderStrategy) : void
  invoke(mi : org.aopalliance.intercept.MethodInvocation) : java.lang.Object
  getAuthentication() : org.springframework.security.core.Authentication
}
org.springframework.security.authorization.method.PostFilterAuthorizationMethodInterceptor::PostFilterAuthorizationMethodInterceptor -- org.springframework.security.authorization.method.AuthorizationMethodPointcuts::forAnnotations : AuthorizationMethodPointcuts.forAnnotations(PostFilter.class) 
org.springframework.security.authorization.method.PostFilterAuthorizationMethodInterceptor::setExpressionHandler -- org.springframework.security.authorization.method.PostFilterExpressionAttributeRegistry::setExpressionHandler : this.registry.setExpressionHandler(expressionHandler) 
org.springframework.security.authorization.method.PostFilterAuthorizationMethodInterceptor::setTemplateDefaults -- org.springframework.security.authorization.method.PostFilterExpressionAttributeRegistry::setTemplateDefaults : this.registry.setTemplateDefaults(defaults) 
org.springframework.security.authorization.method.PostFilterAuthorizationMethodInterceptor::setTemplateDefaults -- org.springframework.security.authorization.method.PostFilterExpressionAttributeRegistry::setTemplateDefaults : this.registry.setTemplateDefaults(defaults) 
org.springframework.security.authorization.method.PostFilterAuthorizationMethodInterceptor::invoke -- org.aopalliance.intercept.MethodInvocation::proceed : mi.proceed() 
org.springframework.security.authorization.method.PostFilterAuthorizationMethodInterceptor::invoke -- org.springframework.security.authorization.method.PostFilterExpressionAttributeRegistry::getAttribute : this.registry.getAttribute(mi) 
org.springframework.security.authorization.method.PostFilterAuthorizationMethodInterceptor::invoke -- org.springframework.security.authorization.method.PostFilterExpressionAttributeRegistry::getExpressionHandler : this.registry.getExpressionHandler() 
org.springframework.security.authorization.method.PostFilterAuthorizationMethodInterceptor::getAuthentication -- java.util.function.Supplier::get : this.securityContextHolderStrategy.get().getContext().getAuthentication() 
org.springframework.security.authorization.method.PostFilterAuthorizationMethodInterceptor::getAuthentication -- java.util.function.Supplier::get : this.securityContextHolderStrategy.get().getContext() 
org.springframework.security.authorization.method.PostFilterAuthorizationMethodInterceptor::getAuthentication -- java.util.function.Supplier::get : this.securityContextHolderStrategy.get() 
class PostFilterAuthorizationReactiveMethodInterceptor  implements org.springframework.security.authorization.method.AuthorizationAdvisor  {
  registry : org.springframework.security.authorization.method.PostFilterExpressionAttributeRegistry
  pointcut : org.springframework.aop.Pointcut
  order : int
  PostFilterAuthorizationReactiveMethodInterceptor() : None
  PostFilterAuthorizationReactiveMethodInterceptor(expressionHandler : org.springframework.security.access.expression.method.MethodSecurityExpressionHandler) : None
  setTemplateDefaults(defaults : org.springframework.security.authorization.method.PrePostTemplateDefaults) : void
  setTemplateDefaults(defaults : org.springframework.security.core.annotation.AnnotationTemplateExpressionDefaults) : void
  invoke(mi : org.aopalliance.intercept.MethodInvocation) : java.lang.Object
  isMultiValue(returnType : java.lang.Class, adapter : org.springframework.core.ReactiveAdapter) : boolean
  filterSingleValue(publisher : org.reactivestreams.Publisher, ctx : org.springframework.expression.EvaluationContext, attribute : org.springframework.security.authorization.method.ExpressionAttribute) : reactor.core.publisher.Mono
  filterMultiValue(publisher : org.reactivestreams.Publisher, ctx : org.springframework.expression.EvaluationContext, attribute : org.springframework.security.authorization.method.ExpressionAttribute) : reactor.core.publisher.Flux
  setFilterObject(ctx : org.springframework.expression.EvaluationContext, result : java.lang.Object) : void
  postFilter(ctx : org.springframework.expression.EvaluationContext, result : java.lang.Object, attribute : org.springframework.security.authorization.method.ExpressionAttribute) : reactor.core.publisher.Mono
  getPointcut() : org.springframework.aop.Pointcut
  getAdvice() : org.aopalliance.aop.Advice
  isPerInstance() : boolean
  getOrder() : int
  setOrder(order : int) : void
}
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::PostFilterAuthorizationReactiveMethodInterceptor -- org.springframework.util.Assert::notNull : Assert.notNull(expressionHandler,"expressionHandler cannot be null") 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::PostFilterAuthorizationReactiveMethodInterceptor -- org.springframework.security.authorization.method.PostFilterExpressionAttributeRegistry::setExpressionHandler : this.registry.setExpressionHandler(expressionHandler) 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::setTemplateDefaults -- org.springframework.security.authorization.method.PostFilterExpressionAttributeRegistry::setTemplateDefaults : this.registry.setTemplateDefaults(defaults) 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::setTemplateDefaults -- org.springframework.security.authorization.method.PostFilterExpressionAttributeRegistry::setTemplateDefaults : this.registry.setTemplateDefaults(defaults) 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.PostFilterExpressionAttributeRegistry::getAttribute : this.registry.getAttribute(mi) 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.ReactiveMethodInvocationUtils::proceed : ReactiveMethodInvocationUtils.proceed(mi) 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.ReactiveAuthenticationUtils::getAuthentication : ReactiveAuthenticationUtils.getAuthentication().map((auth)->this.registry.getExpressionHandler().createEvaluationContext(auth,mi)) 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.ReactiveAuthenticationUtils::getAuthentication : ReactiveAuthenticationUtils.getAuthentication() 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.PostFilterExpressionAttributeRegistry::getExpressionHandler : this.registry.getExpressionHandler().createEvaluationContext(auth,mi) 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.PostFilterExpressionAttributeRegistry::getExpressionHandler : this.registry.getExpressionHandler() 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::invoke -- org.aopalliance.intercept.MethodInvocation::getMethod : mi.getMethod() 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::invoke -- org.springframework.util.Assert::state : Assert.state(Publisher.class.isAssignableFrom(type),()->String.format("The parameter type %s on %s must be an instance of org.reactivestreams.Publisher "+"(for example, a Mono or Flux) in order to support Reactor Context",type,method)) 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::invoke -- java.lang.String::format : String.format("The parameter type %s on %s must be an instance of org.reactivestreams.Publisher "+"(for example, a Mono or Flux) in order to support Reactor Context",type,method) 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::invoke -- org.springframework.core.ReactiveAdapterRegistry::getSharedInstance : ReactiveAdapterRegistry.getSharedInstance().getAdapter(type) 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::invoke -- org.springframework.core.ReactiveAdapterRegistry::getSharedInstance : ReactiveAdapterRegistry.getSharedInstance() 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::invoke -- reactor.core.publisher.Flux::defer : Flux.defer(()->ReactiveMethodInvocationUtils.proceed(mi)) 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.ReactiveMethodInvocationUtils::proceed : ReactiveMethodInvocationUtils.proceed(mi) 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::invoke -- reactor.core.publisher.Mono::defer : Mono.defer(()->ReactiveMethodInvocationUtils.proceed(mi)) 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.ReactiveMethodInvocationUtils::proceed : ReactiveMethodInvocationUtils.proceed(mi) 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::isMultiValue -- org.springframework.core.ReactiveAdapter::isMultiValue : adapter.isMultiValue() 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::filterSingleValue -- reactor.core.publisher.Mono::from : Mono.from(publisher).doOnNext((result)->setFilterObject(ctx,result)).flatMap((result)->postFilter(ctx,result,attribute)) 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::filterSingleValue -- reactor.core.publisher.Mono::from : Mono.from(publisher).doOnNext((result)->setFilterObject(ctx,result)) 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::filterSingleValue -- reactor.core.publisher.Mono::from : Mono.from(publisher) 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::filterMultiValue -- reactor.core.publisher.Flux::from : Flux.from(publisher).doOnNext((result)->setFilterObject(ctx,result)).flatMap((result)->postFilter(ctx,result,attribute)) 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::filterMultiValue -- reactor.core.publisher.Flux::from : Flux.from(publisher).doOnNext((result)->setFilterObject(ctx,result)) 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::filterMultiValue -- reactor.core.publisher.Flux::from : Flux.from(publisher) 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::setFilterObject -- org.springframework.expression.EvaluationContext::getRootObject : ctx.getRootObject().getValue() 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::setFilterObject -- org.springframework.expression.EvaluationContext::getRootObject : ctx.getRootObject() 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::postFilter -- org.springframework.security.authorization.method.ReactiveExpressionUtils::evaluateAsBoolean : ReactiveExpressionUtils.evaluateAsBoolean(attribute.getExpression(),ctx).flatMap((granted)->granted?Mono.just(result):Mono.empty()) 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::postFilter -- org.springframework.security.authorization.method.ReactiveExpressionUtils::evaluateAsBoolean : ReactiveExpressionUtils.evaluateAsBoolean(attribute.getExpression(),ctx) 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::postFilter -- org.springframework.security.authorization.method.ExpressionAttribute::getExpression : attribute.getExpression() 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::postFilter -- reactor.core.publisher.Mono::just : Mono.just(result) 
org.springframework.security.authorization.method.PostFilterAuthorizationReactiveMethodInterceptor::postFilter -- reactor.core.publisher.Mono::empty : Mono.empty() 
class PostFilterExpressionAttributeRegistry extends org.springframework.security.authorization.method.AbstractExpressionAttributeRegistry   {
  scanner : org.springframework.security.core.annotation.SecurityAnnotationScanner
  resolveAttribute(method : java.lang.reflect.Method, targetClass : java.lang.Class) : org.springframework.security.authorization.method.ExpressionAttribute
  setTemplateDefaults(defaults : org.springframework.security.core.annotation.AnnotationTemplateExpressionDefaults) : void
  findPostFilterAnnotation(method : java.lang.reflect.Method, targetClass : java.lang.Class) : org.springframework.security.access.prepost.PostFilter
}
org.springframework.security.authorization.method.PostFilterExpressionAttributeRegistry::resolveAttribute -- org.springframework.security.authorization.method.PostFilterExpressionAttributeRegistry::getExpressionHandler : getExpressionHandler().getExpressionParser().parseExpression(postFilter.value()) 
org.springframework.security.authorization.method.PostFilterExpressionAttributeRegistry::resolveAttribute -- org.springframework.security.authorization.method.PostFilterExpressionAttributeRegistry::getExpressionHandler : getExpressionHandler().getExpressionParser() 
org.springframework.security.authorization.method.PostFilterExpressionAttributeRegistry::setTemplateDefaults -- org.springframework.security.core.annotation.SecurityAnnotationScanners::requireUnique : SecurityAnnotationScanners.requireUnique(PostFilter.class,defaults) 
org.springframework.security.authorization.method.PostFilterExpressionAttributeRegistry::findPostFilterAnnotation -- org.springframework.security.core.annotation.SecurityAnnotationScanner::scan : this.scanner.scan(method,targetClassToUse) 
class PreAuthorizeAuthorizationManager  implements org.springframework.security.authorization.AuthorizationManager  {
  registry : org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry
  setExpressionHandler(expressionHandler : org.springframework.security.access.expression.method.MethodSecurityExpressionHandler) : void
  setTemplateDefaults(defaults : org.springframework.security.authorization.method.PrePostTemplateDefaults) : void
  setTemplateDefaults(defaults : org.springframework.security.core.annotation.AnnotationTemplateExpressionDefaults) : void
  setApplicationContext(context : org.springframework.context.ApplicationContext) : void
  check(authentication : java.util.function.Supplier, mi : org.aopalliance.intercept.MethodInvocation) : org.springframework.security.authorization.AuthorizationDecision
  handleDeniedInvocation(methodInvocation : org.aopalliance.intercept.MethodInvocation, authorizationResult : org.springframework.security.authorization.AuthorizationResult) : java.lang.Object
}
org.springframework.security.authorization.method.PreAuthorizeAuthorizationManager::setExpressionHandler -- org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::setExpressionHandler : this.registry.setExpressionHandler(expressionHandler) 
org.springframework.security.authorization.method.PreAuthorizeAuthorizationManager::setTemplateDefaults -- org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::setTemplateDefaults : this.registry.setTemplateDefaults(defaults) 
org.springframework.security.authorization.method.PreAuthorizeAuthorizationManager::setTemplateDefaults -- org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::setTemplateDefaults : this.registry.setTemplateDefaults(defaults) 
org.springframework.security.authorization.method.PreAuthorizeAuthorizationManager::setApplicationContext -- org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::setApplicationContext : this.registry.setApplicationContext(context) 
org.springframework.security.authorization.method.PreAuthorizeAuthorizationManager::check -- org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::getAttribute : this.registry.getAttribute(mi) 
org.springframework.security.authorization.method.PreAuthorizeAuthorizationManager::check -- org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::getExpressionHandler : this.registry.getExpressionHandler().createEvaluationContext(authentication,mi) 
org.springframework.security.authorization.method.PreAuthorizeAuthorizationManager::check -- org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::getExpressionHandler : this.registry.getExpressionHandler() 
org.springframework.security.authorization.method.PreAuthorizeAuthorizationManager::check -- org.springframework.security.authorization.method.ExpressionUtils::evaluate : ExpressionUtils.evaluate(attribute.getExpression(),ctx) 
org.springframework.security.authorization.method.PreAuthorizeAuthorizationManager::handleDeniedInvocation -- org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::getAttribute : this.registry.getAttribute(methodInvocation) 
class PreAuthorizeExpressionAttribute extends org.springframework.security.authorization.method.ExpressionAttribute   {
  handler : org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler
  PreAuthorizeExpressionAttribute(expression : org.springframework.expression.Expression, handler : org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler) : None
  getHandler() : org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler
}
org.springframework.security.authorization.method.PreAuthorizeExpressionAttribute::PreAuthorizeExpressionAttribute -- org.springframework.util.Assert::notNull : Assert.notNull(handler,"handler cannot be null") 
class PreAuthorizeExpressionAttributeRegistry extends org.springframework.security.authorization.method.AbstractExpressionAttributeRegistry   {
  defaultHandler : org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler
  handleAuthorizationDeniedScanner : org.springframework.security.core.annotation.SecurityAnnotationScanner
  handlerResolver : java.util.function.Function
  preAuthorizeScanner : org.springframework.security.core.annotation.SecurityAnnotationScanner
  PreAuthorizeExpressionAttributeRegistry() : None
  resolveAttribute(method : java.lang.reflect.Method, targetClass : java.lang.Class) : org.springframework.security.authorization.method.ExpressionAttribute
  resolveHandler(method : java.lang.reflect.Method, targetClass : java.lang.Class) : org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler
  findPreAuthorizeAnnotation(method : java.lang.reflect.Method, targetClass : java.lang.Class) : org.springframework.security.access.prepost.PreAuthorize
  setApplicationContext(context : org.springframework.context.ApplicationContext) : void
  setTemplateDefaults(defaults : org.springframework.security.core.annotation.AnnotationTemplateExpressionDefaults) : void
  resolveHandler(context : org.springframework.context.ApplicationContext, handlerClass : java.lang.Class) : org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler
}
org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::resolveAttribute -- org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::getExpressionHandler : getExpressionHandler().getExpressionParser().parseExpression(preAuthorize.value()) 
org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::resolveAttribute -- org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::getExpressionHandler : getExpressionHandler().getExpressionParser() 
org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::resolveHandler -- org.springframework.security.core.annotation.SecurityAnnotationScanner::scan : this.handleAuthorizationDeniedScanner.scan(method,targetClassToUse) 
org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::resolveHandler -- java.util.function.Function::apply : this.handlerResolver.apply(deniedHandler.handlerClass()) 
org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::findPreAuthorizeAnnotation -- org.springframework.security.core.annotation.SecurityAnnotationScanner::scan : this.preAuthorizeScanner.scan(method,targetClassToUse) 
org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::setApplicationContext -- org.springframework.util.Assert::notNull : Assert.notNull(context,"context cannot be null") 
org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::setTemplateDefaults -- org.springframework.security.core.annotation.SecurityAnnotationScanners::requireUnique : SecurityAnnotationScanners.requireUnique(PreAuthorize.class,defaults) 
org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::resolveHandler -- org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler::getClass : this.defaultHandler.getClass() 
org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::resolveHandler -- org.springframework.context.ApplicationContext::getBeanNamesForType : context.getBeanNamesForType(handlerClass) 
org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::resolveHandler -- java.lang.Class::getName : handlerClass.getName() 
org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::resolveHandler -- java.lang.Class::getName : handlerClass.getName() 
org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::resolveHandler -- java.util.Arrays::toString : Arrays.toString(beanNames) 
org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::resolveHandler -- org.springframework.context.ApplicationContext::getBean : context.getBean(beanNames[0],handlerClass) 
class PreAuthorizeReactiveAuthorizationManager  implements org.springframework.security.authorization.ReactiveAuthorizationManager  {
  registry : org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry
  PreAuthorizeReactiveAuthorizationManager() : None
  PreAuthorizeReactiveAuthorizationManager(expressionHandler : org.springframework.security.access.expression.method.MethodSecurityExpressionHandler) : None
  setTemplateDefaults(defaults : org.springframework.security.authorization.method.PrePostTemplateDefaults) : void
  setTemplateDefaults(defaults : org.springframework.security.core.annotation.AnnotationTemplateExpressionDefaults) : void
  setApplicationContext(context : org.springframework.context.ApplicationContext) : void
  check(authentication : reactor.core.publisher.Mono, mi : org.aopalliance.intercept.MethodInvocation) : reactor.core.publisher.Mono
  handleDeniedInvocation(methodInvocation : org.aopalliance.intercept.MethodInvocation, authorizationResult : org.springframework.security.authorization.AuthorizationResult) : java.lang.Object
}
org.springframework.security.authorization.method.PreAuthorizeReactiveAuthorizationManager::PreAuthorizeReactiveAuthorizationManager -- org.springframework.util.Assert::notNull : Assert.notNull(expressionHandler,"expressionHandler cannot be null") 
org.springframework.security.authorization.method.PreAuthorizeReactiveAuthorizationManager::PreAuthorizeReactiveAuthorizationManager -- org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::setExpressionHandler : this.registry.setExpressionHandler(expressionHandler) 
org.springframework.security.authorization.method.PreAuthorizeReactiveAuthorizationManager::setTemplateDefaults -- org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::setTemplateDefaults : this.registry.setTemplateDefaults(defaults) 
org.springframework.security.authorization.method.PreAuthorizeReactiveAuthorizationManager::setTemplateDefaults -- org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::setTemplateDefaults : this.registry.setTemplateDefaults(defaults) 
org.springframework.security.authorization.method.PreAuthorizeReactiveAuthorizationManager::setApplicationContext -- org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::setApplicationContext : this.registry.setApplicationContext(context) 
org.springframework.security.authorization.method.PreAuthorizeReactiveAuthorizationManager::check -- org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::getAttribute : this.registry.getAttribute(mi) 
org.springframework.security.authorization.method.PreAuthorizeReactiveAuthorizationManager::check -- reactor.core.publisher.Mono::empty : Mono.empty() 
org.springframework.security.authorization.method.PreAuthorizeReactiveAuthorizationManager::check -- reactor.core.publisher.Mono::map : authentication.map((auth)->this.registry.getExpressionHandler().createEvaluationContext(auth,mi)).flatMap((ctx)->ReactiveExpressionUtils.evaluate(attribute.getExpression(),ctx)).cast(AuthorizationDecision.class) 
org.springframework.security.authorization.method.PreAuthorizeReactiveAuthorizationManager::check -- reactor.core.publisher.Mono::map : authentication.map((auth)->this.registry.getExpressionHandler().createEvaluationContext(auth,mi)).flatMap((ctx)->ReactiveExpressionUtils.evaluate(attribute.getExpression(),ctx)) 
org.springframework.security.authorization.method.PreAuthorizeReactiveAuthorizationManager::check -- reactor.core.publisher.Mono::map : authentication.map((auth)->this.registry.getExpressionHandler().createEvaluationContext(auth,mi)) 
org.springframework.security.authorization.method.PreAuthorizeReactiveAuthorizationManager::check -- org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::getExpressionHandler : this.registry.getExpressionHandler().createEvaluationContext(auth,mi) 
org.springframework.security.authorization.method.PreAuthorizeReactiveAuthorizationManager::check -- org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::getExpressionHandler : this.registry.getExpressionHandler() 
org.springframework.security.authorization.method.PreAuthorizeReactiveAuthorizationManager::check -- org.springframework.security.authorization.method.ReactiveExpressionUtils::evaluate : ReactiveExpressionUtils.evaluate(attribute.getExpression(),ctx) 
org.springframework.security.authorization.method.PreAuthorizeReactiveAuthorizationManager::handleDeniedInvocation -- org.springframework.security.authorization.method.PreAuthorizeExpressionAttributeRegistry::getAttribute : this.registry.getAttribute(methodInvocation) 
class PreFilterAuthorizationMethodInterceptor  implements org.springframework.security.authorization.method.AuthorizationAdvisor  {
  securityContextHolderStrategy : java.util.function.Supplier
  registry : org.springframework.security.authorization.method.PreFilterExpressionAttributeRegistry
  order : int
  pointcut : org.springframework.aop.Pointcut
  PreFilterAuthorizationMethodInterceptor() : None
  setExpressionHandler(expressionHandler : org.springframework.security.access.expression.method.MethodSecurityExpressionHandler) : void
  setTemplateDefaults(defaults : org.springframework.security.authorization.method.PrePostTemplateDefaults) : void
  setTemplateDefaults(defaults : org.springframework.security.core.annotation.AnnotationTemplateExpressionDefaults) : void
  getOrder() : int
  setOrder(order : int) : void
  getPointcut() : org.springframework.aop.Pointcut
  getAdvice() : org.aopalliance.aop.Advice
  isPerInstance() : boolean
  setSecurityContextHolderStrategy(strategy : org.springframework.security.core.context.SecurityContextHolderStrategy) : void
  invoke(mi : org.aopalliance.intercept.MethodInvocation) : java.lang.Object
  findFilterTarget(filterTargetName : java.lang.String, ctx : org.springframework.expression.EvaluationContext, methodInvocation : org.aopalliance.intercept.MethodInvocation) : java.lang.Object
  getAuthentication() : org.springframework.security.core.Authentication
}
org.springframework.security.authorization.method.PreFilterAuthorizationMethodInterceptor::PreFilterAuthorizationMethodInterceptor -- org.springframework.security.authorization.method.AuthorizationMethodPointcuts::forAnnotations : AuthorizationMethodPointcuts.forAnnotations(PreFilter.class) 
org.springframework.security.authorization.method.PreFilterAuthorizationMethodInterceptor::setExpressionHandler -- org.springframework.security.authorization.method.PreFilterExpressionAttributeRegistry::setExpressionHandler : this.registry.setExpressionHandler(expressionHandler) 
org.springframework.security.authorization.method.PreFilterAuthorizationMethodInterceptor::setTemplateDefaults -- org.springframework.security.authorization.method.PreFilterExpressionAttributeRegistry::setTemplateDefaults : this.registry.setTemplateDefaults(defaults) 
org.springframework.security.authorization.method.PreFilterAuthorizationMethodInterceptor::setTemplateDefaults -- org.springframework.security.authorization.method.PreFilterExpressionAttributeRegistry::setTemplateDefaults : this.registry.setTemplateDefaults(defaults) 
org.springframework.security.authorization.method.PreFilterAuthorizationMethodInterceptor::invoke -- org.springframework.security.authorization.method.PreFilterExpressionAttributeRegistry::getAttribute : this.registry.getAttribute(mi) 
org.springframework.security.authorization.method.PreFilterAuthorizationMethodInterceptor::invoke -- org.aopalliance.intercept.MethodInvocation::proceed : mi.proceed() 
org.springframework.security.authorization.method.PreFilterAuthorizationMethodInterceptor::invoke -- org.springframework.security.authorization.method.PreFilterExpressionAttributeRegistry::getExpressionHandler : this.registry.getExpressionHandler() 
org.springframework.security.authorization.method.PreFilterAuthorizationMethodInterceptor::invoke -- org.aopalliance.intercept.MethodInvocation::proceed : mi.proceed() 
org.springframework.security.authorization.method.PreFilterAuthorizationMethodInterceptor::findFilterTarget -- org.springframework.util.StringUtils::hasText : StringUtils.hasText(filterTargetName) 
org.springframework.security.authorization.method.PreFilterAuthorizationMethodInterceptor::findFilterTarget -- org.springframework.expression.EvaluationContext::lookupVariable : ctx.lookupVariable(filterTargetName) 
org.springframework.security.authorization.method.PreFilterAuthorizationMethodInterceptor::findFilterTarget -- org.springframework.util.Assert::notNull : Assert.notNull(filterTarget,()->"Filter target was null, or no argument with name '"+filterTargetName+"' found in method.") 
org.springframework.security.authorization.method.PreFilterAuthorizationMethodInterceptor::findFilterTarget -- org.aopalliance.intercept.MethodInvocation::getArguments : methodInvocation.getArguments() 
org.springframework.security.authorization.method.PreFilterAuthorizationMethodInterceptor::findFilterTarget -- org.springframework.util.Assert::state : Assert.state(arguments.length==1,"Unable to determine the method argument for filtering. Specify the filter target.") 
org.springframework.security.authorization.method.PreFilterAuthorizationMethodInterceptor::findFilterTarget -- org.springframework.util.Assert::notNull : Assert.notNull(filterTarget,"Filter target was null. Make sure you passing the correct value in the method argument.") 
org.springframework.security.authorization.method.PreFilterAuthorizationMethodInterceptor::findFilterTarget -- org.springframework.util.Assert::state : Assert.state(!filterTarget.getClass().isArray(),"Pre-filtering on array types is not supported. Using a Collection will solve this problem.") 
org.springframework.security.authorization.method.PreFilterAuthorizationMethodInterceptor::getAuthentication -- java.util.function.Supplier::get : this.securityContextHolderStrategy.get().getContext().getAuthentication() 
org.springframework.security.authorization.method.PreFilterAuthorizationMethodInterceptor::getAuthentication -- java.util.function.Supplier::get : this.securityContextHolderStrategy.get().getContext() 
org.springframework.security.authorization.method.PreFilterAuthorizationMethodInterceptor::getAuthentication -- java.util.function.Supplier::get : this.securityContextHolderStrategy.get() 
class PreFilterAuthorizationReactiveMethodInterceptor  implements org.springframework.security.authorization.method.AuthorizationAdvisor  {
  registry : org.springframework.security.authorization.method.PreFilterExpressionAttributeRegistry
  pointcut : org.springframework.aop.Pointcut
  parameterNameDiscoverer : org.springframework.core.ParameterNameDiscoverer
  order : int
  PreFilterAuthorizationReactiveMethodInterceptor() : None
  PreFilterAuthorizationReactiveMethodInterceptor(expressionHandler : org.springframework.security.access.expression.method.MethodSecurityExpressionHandler) : None
  setTemplateDefaults(defaults : org.springframework.security.authorization.method.PrePostTemplateDefaults) : void
  setTemplateDefaults(defaults : org.springframework.security.core.annotation.AnnotationTemplateExpressionDefaults) : void
  setParameterNameDiscoverer(parameterNameDiscoverer : org.springframework.core.ParameterNameDiscoverer) : void
  invoke(mi : org.aopalliance.intercept.MethodInvocation) : java.lang.Object
  findFilterTarget(name : java.lang.String, mi : org.aopalliance.intercept.MethodInvocation) : org.springframework.security.authorization.method.FilterTarget
  isMultiValue(returnType : java.lang.Class, adapter : org.springframework.core.ReactiveAdapter) : boolean
  filterSingleValue(filterTarget : org.reactivestreams.Publisher, filterExpression : org.springframework.expression.Expression, ctx : org.springframework.expression.EvaluationContext) : reactor.core.publisher.Mono
  filterMultiValue(filterTarget : org.reactivestreams.Publisher, filterExpression : org.springframework.expression.Expression, ctx : org.springframework.expression.EvaluationContext) : reactor.core.publisher.Flux
  getPointcut() : org.springframework.aop.Pointcut
  getAdvice() : org.aopalliance.aop.Advice
  isPerInstance() : boolean
  getOrder() : int
  setOrder(order : int) : void
}
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::PreFilterAuthorizationReactiveMethodInterceptor -- org.springframework.util.Assert::notNull : Assert.notNull(expressionHandler,"expressionHandler cannot be null") 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::PreFilterAuthorizationReactiveMethodInterceptor -- org.springframework.security.authorization.method.PreFilterExpressionAttributeRegistry::setExpressionHandler : this.registry.setExpressionHandler(expressionHandler) 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::setTemplateDefaults -- org.springframework.security.authorization.method.PreFilterExpressionAttributeRegistry::setTemplateDefaults : this.registry.setTemplateDefaults(defaults) 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::setTemplateDefaults -- org.springframework.security.authorization.method.PreFilterExpressionAttributeRegistry::setTemplateDefaults : this.registry.setTemplateDefaults(defaults) 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::setParameterNameDiscoverer -- org.springframework.util.Assert::notNull : Assert.notNull(parameterNameDiscoverer,"parameterNameDiscoverer cannot be null") 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.PreFilterExpressionAttributeRegistry::getAttribute : this.registry.getAttribute(mi) 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.ReactiveMethodInvocationUtils::proceed : ReactiveMethodInvocationUtils.proceed(mi) 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.ReactiveAuthenticationUtils::getAuthentication : ReactiveAuthenticationUtils.getAuthentication().map((auth)->this.registry.getExpressionHandler().createEvaluationContext(auth,mi)) 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.ReactiveAuthenticationUtils::getAuthentication : ReactiveAuthenticationUtils.getAuthentication() 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.PreFilterExpressionAttributeRegistry::getExpressionHandler : this.registry.getExpressionHandler().createEvaluationContext(auth,mi) 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.PreFilterExpressionAttributeRegistry::getExpressionHandler : this.registry.getExpressionHandler() 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::invoke -- org.aopalliance.intercept.MethodInvocation::getMethod : mi.getMethod() 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::invoke -- org.springframework.util.Assert::state : Assert.state(Publisher.class.isAssignableFrom(type),()->String.format("The parameter type %s on %s must be an instance of org.reactivestreams.Publisher "+"(for example, a Mono or Flux) in order to support Reactor Context",type,method)) 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::invoke -- java.lang.String::format : String.format("The parameter type %s on %s must be an instance of org.reactivestreams.Publisher "+"(for example, a Mono or Flux) in order to support Reactor Context",type,method) 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::invoke -- org.springframework.core.ReactiveAdapterRegistry::getSharedInstance : ReactiveAdapterRegistry.getSharedInstance().getAdapter(type) 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::invoke -- org.springframework.core.ReactiveAdapterRegistry::getSharedInstance : ReactiveAdapterRegistry.getSharedInstance() 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::invoke -- org.aopalliance.intercept.MethodInvocation::getArguments : mi.getArguments() 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::invoke -- org.aopalliance.intercept.MethodInvocation::getArguments : mi.getArguments() 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::invoke -- org.springframework.security.authorization.method.ReactiveMethodInvocationUtils::proceed : ReactiveMethodInvocationUtils.proceed(mi) 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::findFilterTarget -- org.springframework.util.StringUtils::hasText : StringUtils.hasText(name) 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::findFilterTarget -- org.aopalliance.intercept.MethodInvocation::getThis : mi.getThis() 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::findFilterTarget -- org.springframework.aop.support.AopUtils::getTargetClass : AopUtils.getTargetClass(target) 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::findFilterTarget -- org.springframework.aop.support.AopUtils::getMostSpecificMethod : AopUtils.getMostSpecificMethod(mi.getMethod(),targetClass) 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::findFilterTarget -- org.aopalliance.intercept.MethodInvocation::getMethod : mi.getMethod() 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::findFilterTarget -- org.springframework.core.ParameterNameDiscoverer::getParameterNames : this.parameterNameDiscoverer.getParameterNames(specificMethod) 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::findFilterTarget -- org.aopalliance.intercept.MethodInvocation::getArguments : mi.getArguments() 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::findFilterTarget -- java.lang.String::equals : name.equals(parameterNames[index]) 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::findFilterTarget -- org.springframework.util.Assert::notNull : Assert.notNull(value,"Filter target was null, or no argument with name '"+name+"' found in method.") 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::findFilterTarget -- org.aopalliance.intercept.MethodInvocation::getArguments : mi.getArguments() 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::findFilterTarget -- org.springframework.util.Assert::state : Assert.state(arguments.length==1,"Unable to determine the method argument for filtering. Specify the filter target.") 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::findFilterTarget -- org.springframework.util.Assert::notNull : Assert.notNull(value,"Filter target was null. Make sure you passing the correct value in the method argument.") 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::findFilterTarget -- org.springframework.util.Assert::state : Assert.state(valueinstanceofPublisher<?>,"Filter target must be an instance of Publisher.") 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::isMultiValue -- org.springframework.core.ReactiveAdapter::isMultiValue : adapter.isMultiValue() 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::filterSingleValue -- org.springframework.expression.EvaluationContext::getRootObject : ctx.getRootObject().getValue() 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::filterSingleValue -- org.springframework.expression.EvaluationContext::getRootObject : ctx.getRootObject() 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::filterSingleValue -- reactor.core.publisher.Mono::from : Mono.from(filterTarget).filterWhen((filterObject)->{rootObject.setFilterObject(filterObject);returnReactiveExpressionUtils.evaluateAsBoolean(filterExpression,ctx);}) 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::filterSingleValue -- reactor.core.publisher.Mono::from : Mono.from(filterTarget) 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::filterSingleValue -- org.springframework.security.authorization.method.ReactiveExpressionUtils::evaluateAsBoolean : ReactiveExpressionUtils.evaluateAsBoolean(filterExpression,ctx) 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::filterMultiValue -- org.springframework.expression.EvaluationContext::getRootObject : ctx.getRootObject().getValue() 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::filterMultiValue -- org.springframework.expression.EvaluationContext::getRootObject : ctx.getRootObject() 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::filterMultiValue -- reactor.core.publisher.Flux::from : Flux.from(filterTarget).filterWhen((filterObject)->{rootObject.setFilterObject(filterObject);returnReactiveExpressionUtils.evaluateAsBoolean(filterExpression,ctx);}) 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::filterMultiValue -- reactor.core.publisher.Flux::from : Flux.from(filterTarget) 
org.springframework.security.authorization.method.PreFilterAuthorizationReactiveMethodInterceptor::filterMultiValue -- org.springframework.security.authorization.method.ReactiveExpressionUtils::evaluateAsBoolean : ReactiveExpressionUtils.evaluateAsBoolean(filterExpression,ctx) 
class FilterTarget    {
  value : org.springframework.security.authorization.method.Publisher
  index : int
  FilterTarget(value : org.springframework.security.authorization.method.Publisher, index : int) : None
}
class PreFilterExpressionAttributeRegistry extends org.springframework.security.authorization.method.AbstractExpressionAttributeRegistry   {
  scanner : org.springframework.security.core.annotation.SecurityAnnotationScanner
  resolveAttribute(method : java.lang.reflect.Method, targetClass : java.lang.Class) : org.springframework.security.authorization.method.PreFilterExpressionAttribute
  setTemplateDefaults(defaults : org.springframework.security.core.annotation.AnnotationTemplateExpressionDefaults) : void
  findPreFilterAnnotation(method : java.lang.reflect.Method, targetClass : java.lang.Class) : org.springframework.security.access.prepost.PreFilter
}
org.springframework.security.authorization.method.PreFilterExpressionAttributeRegistry::resolveAttribute -- org.springframework.security.authorization.method.PreFilterExpressionAttributeRegistry::getExpressionHandler : getExpressionHandler().getExpressionParser().parseExpression(preFilter.value()) 
org.springframework.security.authorization.method.PreFilterExpressionAttributeRegistry::resolveAttribute -- org.springframework.security.authorization.method.PreFilterExpressionAttributeRegistry::getExpressionHandler : getExpressionHandler().getExpressionParser() 
org.springframework.security.authorization.method.PreFilterExpressionAttributeRegistry::setTemplateDefaults -- org.springframework.security.core.annotation.SecurityAnnotationScanners::requireUnique : SecurityAnnotationScanners.requireUnique(PreFilter.class,defaults) 
org.springframework.security.authorization.method.PreFilterExpressionAttributeRegistry::findPreFilterAnnotation -- org.springframework.security.core.annotation.SecurityAnnotationScanner::scan : this.scanner.scan(method,targetClassToUse) 
class PreFilterExpressionAttribute extends org.springframework.security.authorization.method.ExpressionAttribute   {
  NULL_ATTRIBUTE : org.springframework.security.authorization.method.PreFilterExpressionAttribute
  filterTarget : java.lang.String
  PreFilterExpressionAttribute(expression : org.springframework.security.authorization.method.Expression, filterTarget : java.lang.String) : None
  getFilterTarget() : java.lang.String
}
class PrePostTemplateDefaults    {
  ignoreUnknown : boolean
  isIgnoreUnknown() : boolean
  setIgnoreUnknown(ignoreUnknown : boolean) : void
}
class ReactiveAuthenticationUtils    {
  ANONYMOUS : org.springframework.security.core.Authentication
  getAuthentication() : reactor.core.publisher.Mono
  ReactiveAuthenticationUtils() : None
}
org.springframework.security.authorization.method.ReactiveAuthenticationUtils::getAuthentication -- org.springframework.security.core.context.ReactiveSecurityContextHolder::getContext : ReactiveSecurityContextHolder.getContext().map(SecurityContext::getAuthentication).defaultIfEmpty(ANONYMOUS) 
org.springframework.security.authorization.method.ReactiveAuthenticationUtils::getAuthentication -- org.springframework.security.core.context.ReactiveSecurityContextHolder::getContext : ReactiveSecurityContextHolder.getContext().map(SecurityContext::getAuthentication) 
org.springframework.security.authorization.method.ReactiveAuthenticationUtils::getAuthentication -- org.springframework.security.core.context.ReactiveSecurityContextHolder::getContext : ReactiveSecurityContextHolder.getContext() 
class ReactiveExpressionUtils    {
  evaluate(expr : org.springframework.expression.Expression, ctx : org.springframework.expression.EvaluationContext) : reactor.core.publisher.Mono
  adapt(expr : org.springframework.expression.Expression, value : java.lang.Object) : reactor.core.publisher.Mono
  evaluateAsBoolean(expr : org.springframework.expression.Expression, ctx : org.springframework.expression.EvaluationContext) : reactor.core.publisher.Mono
  createInvalidReturnTypeMono(expr : org.springframework.expression.Expression) : reactor.core.publisher.Mono
  ReactiveExpressionUtils() : None
}
org.springframework.security.authorization.method.ReactiveExpressionUtils::evaluate -- reactor.core.publisher.Mono::defer : Mono.defer(()->{Objectvalue;try{value=expr.getValue(ctx);}catch(EvaluationExceptionex){returnMono.error(()->newIllegalArgumentException("Failed to evaluate expression '"+expr.getExpressionString()+"'",ex));}if(valueinstanceofMono<?>mono){returnmono.flatMap((data)->adapt(expr,data));}returnadapt(expr,value);}) 
org.springframework.security.authorization.method.ReactiveExpressionUtils::evaluate -- org.springframework.expression.Expression::getValue : expr.getValue(ctx) 
org.springframework.security.authorization.method.ReactiveExpressionUtils::evaluate -- reactor.core.publisher.Mono::error : Mono.error(()->newIllegalArgumentException("Failed to evaluate expression '"+expr.getExpressionString()+"'",ex)) 
org.springframework.security.authorization.method.ReactiveExpressionUtils::evaluate -- org.springframework.expression.Expression::getExpressionString : expr.getExpressionString() 
org.springframework.security.authorization.method.ReactiveExpressionUtils::adapt -- reactor.core.publisher.Mono::just : Mono.just(newExpressionAuthorizationDecision(granted,expr)) 
org.springframework.security.authorization.method.ReactiveExpressionUtils::adapt -- reactor.core.publisher.Mono::just : Mono.just(decision) 
org.springframework.security.authorization.method.ReactiveExpressionUtils::evaluateAsBoolean -- reactor.core.publisher.Mono::defer : Mono.defer(()->{Objectvalue;try{value=expr.getValue(ctx);}catch(EvaluationExceptionex){returnMono.error(()->newIllegalArgumentException("Failed to evaluate expression '"+expr.getExpressionString()+"'",ex));}if(valueinstanceofBoolean){returnMono.just((Boolean)value);}if(valueinstanceofMono<?>){Mono<?>monoValue=(Mono<?>)value;returnmonoValue.filter(Boolean.class::isInstance).map(Boolean.class::cast).switchIfEmpty(createInvalidReturnTypeMono(expr));}returncreateInvalidReturnTypeMono(expr);}) 
org.springframework.security.authorization.method.ReactiveExpressionUtils::evaluateAsBoolean -- org.springframework.expression.Expression::getValue : expr.getValue(ctx) 
org.springframework.security.authorization.method.ReactiveExpressionUtils::evaluateAsBoolean -- reactor.core.publisher.Mono::error : Mono.error(()->newIllegalArgumentException("Failed to evaluate expression '"+expr.getExpressionString()+"'",ex)) 
org.springframework.security.authorization.method.ReactiveExpressionUtils::evaluateAsBoolean -- org.springframework.expression.Expression::getExpressionString : expr.getExpressionString() 
org.springframework.security.authorization.method.ReactiveExpressionUtils::evaluateAsBoolean -- reactor.core.publisher.Mono::just : Mono.just((Boolean)value) 
org.springframework.security.authorization.method.ReactiveExpressionUtils::createInvalidReturnTypeMono -- reactor.core.publisher.Mono::error : Mono.error(()->newIllegalStateException("Expression: '"+expr.getExpressionString()+"' must return boolean, Mono<Boolean>, AuthorizationResult, or Mono<AuthorizationResult>")) 
org.springframework.security.authorization.method.ReactiveExpressionUtils::createInvalidReturnTypeMono -- org.springframework.expression.Expression::getExpressionString : expr.getExpressionString() 
class ReactiveMethodInvocationUtils    {
  proceed(mi : org.aopalliance.intercept.MethodInvocation) : org.springframework.security.authorization.method.T
  ReactiveMethodInvocationUtils() : None
}
org.springframework.security.authorization.method.ReactiveMethodInvocationUtils::proceed -- org.aopalliance.intercept.MethodInvocation::proceed : mi.proceed() 
org.springframework.security.authorization.method.ReactiveMethodInvocationUtils::proceed -- reactor.core.Exceptions::propagate : Exceptions.propagate(ex) 
class ReflectiveMethodAuthorizationDeniedHandler  implements org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler  {
  logger : org.apache.commons.logging.Log
  targetClass : java.lang.Class
  managerClass : java.lang.Class
  ReflectiveMethodAuthorizationDeniedHandler(targetClass : java.lang.Class, managerClass : java.lang.Class) : None
  handleDeniedInvocation(methodInvocation : org.aopalliance.intercept.MethodInvocation, authorizationResult : org.springframework.security.authorization.AuthorizationResult) : java.lang.Object
  handleDeniedInvocationResult(methodInvocationResult : org.springframework.security.authorization.method.MethodInvocationResult, authorizationResult : org.springframework.security.authorization.AuthorizationResult) : java.lang.Object
  constructMethodAuthorizationDeniedHandler() : org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler
}
org.springframework.security.authorization.method.ReflectiveMethodAuthorizationDeniedHandler::ReflectiveMethodAuthorizationDeniedHandler -- org.apache.commons.logging.Log::debug : this.logger.debug("Will attempt to instantiate handlerClass attributes using reflection since no application context was supplied to "+managerClass) 
org.springframework.security.authorization.method.ReflectiveMethodAuthorizationDeniedHandler::handleDeniedInvocation -- org.springframework.security.authorization.method.ReflectiveMethodAuthorizationDeniedHandler::constructMethodAuthorizationDeniedHandler : constructMethodAuthorizationDeniedHandler().handleDeniedInvocation(methodInvocation,authorizationResult) 
org.springframework.security.authorization.method.ReflectiveMethodAuthorizationDeniedHandler::handleDeniedInvocationResult -- org.springframework.security.authorization.method.ReflectiveMethodAuthorizationDeniedHandler::constructMethodAuthorizationDeniedHandler : constructMethodAuthorizationDeniedHandler().handleDeniedInvocationResult(methodInvocationResult,authorizationResult) 
org.springframework.security.authorization.method.ReflectiveMethodAuthorizationDeniedHandler::constructMethodAuthorizationDeniedHandler -- java.lang.Class::getConstructor : this.targetClass.getConstructor().newInstance() 
org.springframework.security.authorization.method.ReflectiveMethodAuthorizationDeniedHandler::constructMethodAuthorizationDeniedHandler -- java.lang.Class::getConstructor : this.targetClass.getConstructor() 
class SecuredAuthorizationManager  implements org.springframework.security.authorization.AuthorizationManager  {
  authoritiesAuthorizationManager : org.springframework.security.authorization.AuthorizationManager
  cachedAuthorities : java.util.Map
  scanner : org.springframework.security.core.annotation.SecurityAnnotationScanner
  setAuthoritiesAuthorizationManager(authoritiesAuthorizationManager : org.springframework.security.authorization.AuthorizationManager) : void
  check(authentication : java.util.function.Supplier, mi : org.aopalliance.intercept.MethodInvocation) : org.springframework.security.authorization.AuthorizationDecision
  getAuthorities(methodInvocation : org.aopalliance.intercept.MethodInvocation) : java.util.Set
  resolveAuthorities(method : java.lang.reflect.Method, targetClass : java.lang.Class) : java.util.Set
  findSecuredAnnotation(method : java.lang.reflect.Method, targetClass : java.lang.Class) : org.springframework.security.access.annotation.Secured
}
org.springframework.security.authorization.method.SecuredAuthorizationManager::setAuthoritiesAuthorizationManager -- org.springframework.util.Assert::notNull : Assert.notNull(authoritiesAuthorizationManager,"authoritiesAuthorizationManager cannot be null") 
org.springframework.security.authorization.method.SecuredAuthorizationManager::check -- org.springframework.security.authorization.AuthorizationManager::check : this.authoritiesAuthorizationManager.check(authentication,authorities) 
org.springframework.security.authorization.method.SecuredAuthorizationManager::getAuthorities -- org.aopalliance.intercept.MethodInvocation::getMethod : methodInvocation.getMethod() 
org.springframework.security.authorization.method.SecuredAuthorizationManager::getAuthorities -- org.aopalliance.intercept.MethodInvocation::getThis : methodInvocation.getThis() 
org.springframework.security.authorization.method.SecuredAuthorizationManager::getAuthorities -- java.util.Map::computeIfAbsent : this.cachedAuthorities.computeIfAbsent(cacheKey,(k)->resolveAuthorities(method,targetClass)) 
org.springframework.security.authorization.method.SecuredAuthorizationManager::resolveAuthorities -- java.util.Set::of : Set.of(secured.value()) 
org.springframework.security.authorization.method.SecuredAuthorizationManager::resolveAuthorities -- java.util.Collections::emptySet : Collections.emptySet() 
org.springframework.security.authorization.method.SecuredAuthorizationManager::findSecuredAnnotation -- java.lang.reflect.Method::getDeclaringClass : method.getDeclaringClass() 
org.springframework.security.authorization.method.SecuredAuthorizationManager::findSecuredAnnotation -- org.springframework.security.core.annotation.SecurityAnnotationScanner::scan : this.scanner.scan(method,targetClassToUse) 
class ThrowingMethodAuthorizationDeniedHandler  implements org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler  {
  handleDeniedInvocation(methodInvocation : org.aopalliance.intercept.MethodInvocation, authorizationResult : org.springframework.security.authorization.AuthorizationResult) : java.lang.Object
  handleDeniedInvocationResult(methodInvocationResult : org.springframework.security.authorization.method.MethodInvocationResult, authorizationResult : org.springframework.security.authorization.AuthorizationResult) : java.lang.Object
}
}
class AuthenticatedAuthorizationManager  implements org.springframework.security.authorization.AuthorizationManager  {
  authorizationStrategy : org.springframework.security.authorization.AbstractAuthorizationStrategy
  AuthenticatedAuthorizationManager() : None
  AuthenticatedAuthorizationManager(authorizationStrategy : org.springframework.security.authorization.AbstractAuthorizationStrategy) : None
  setTrustResolver(trustResolver : org.springframework.security.authentication.AuthenticationTrustResolver) : void
  authenticated() : org.springframework.security.authorization.AuthenticatedAuthorizationManager
  fullyAuthenticated() : org.springframework.security.authorization.AuthenticatedAuthorizationManager
  rememberMe() : org.springframework.security.authorization.AuthenticatedAuthorizationManager
  anonymous() : org.springframework.security.authorization.AuthenticatedAuthorizationManager
  check(authentication : java.util.function.Supplier, object : org.springframework.security.authorization.T) : org.springframework.security.authorization.AuthorizationDecision
}
org.springframework.security.authorization.AuthenticatedAuthorizationManager::setTrustResolver -- org.springframework.security.authorization.AbstractAuthorizationStrategy::setTrustResolver : this.authorizationStrategy.setTrustResolver(trustResolver) 
org.springframework.security.authorization.AuthenticatedAuthorizationManager::check -- org.springframework.security.authorization.AbstractAuthorizationStrategy::isGranted : this.authorizationStrategy.isGranted(authentication.get()) 
org.springframework.security.authorization.AuthenticatedAuthorizationManager::check -- java.util.function.Supplier::get : authentication.get() 
class AbstractAuthorizationStrategy    {
  trustResolver : org.springframework.security.authorization.AuthenticationTrustResolver
  setTrustResolver(trustResolver : org.springframework.security.authorization.AuthenticationTrustResolver) : void
  isGranted(authentication : org.springframework.security.authorization.Authentication) : boolean
}
org.springframework.security.authorization.AbstractAuthorizationStrategy::setTrustResolver -- org.springframework.security.authorization.Assert::notNull : Assert.notNull(trustResolver,"trustResolver cannot be null") 
class AuthenticatedAuthorizationStrategy extends org.springframework.security.authorization.AbstractAuthorizationStrategy   {
  isGranted(authentication : org.springframework.security.authorization.Authentication) : boolean
}
class FullyAuthenticatedAuthorizationStrategy extends org.springframework.security.authorization.AuthenticatedAuthorizationStrategy   {
  isGranted(authentication : org.springframework.security.authorization.Authentication) : boolean
}
class AnonymousAuthorizationStrategy extends org.springframework.security.authorization.AbstractAuthorizationStrategy   {
  isGranted(authentication : org.springframework.security.authorization.Authentication) : boolean
}
class RememberMeAuthorizationStrategy extends org.springframework.security.authorization.AbstractAuthorizationStrategy   {
  isGranted(authentication : org.springframework.security.authorization.Authentication) : boolean
}
class AuthenticatedReactiveAuthorizationManager  implements org.springframework.security.authorization.ReactiveAuthorizationManager  {
  authTrustResolver : org.springframework.security.authentication.AuthenticationTrustResolver
  AuthenticatedReactiveAuthorizationManager() : None
  check(authentication : reactor.core.publisher.Mono, object : org.springframework.security.authorization.T) : reactor.core.publisher.Mono
  getAuthorizationDecision(authentication : org.springframework.security.core.Authentication) : org.springframework.security.authorization.AuthorizationDecision
  isNotAnonymous(authentication : org.springframework.security.core.Authentication) : boolean
  authenticated() : org.springframework.security.authorization.AuthenticatedReactiveAuthorizationManager
}
org.springframework.security.authorization.AuthenticatedReactiveAuthorizationManager::check -- reactor.core.publisher.Mono::filter : authentication.filter(this::isNotAnonymous).map(this::getAuthorizationDecision).defaultIfEmpty(newAuthorizationDecision(false)) 
org.springframework.security.authorization.AuthenticatedReactiveAuthorizationManager::check -- reactor.core.publisher.Mono::filter : authentication.filter(this::isNotAnonymous).map(this::getAuthorizationDecision) 
org.springframework.security.authorization.AuthenticatedReactiveAuthorizationManager::check -- reactor.core.publisher.Mono::filter : authentication.filter(this::isNotAnonymous) 
org.springframework.security.authorization.AuthenticatedReactiveAuthorizationManager::getAuthorizationDecision -- org.springframework.security.core.Authentication::isAuthenticated : authentication.isAuthenticated() 
org.springframework.security.authorization.AuthenticatedReactiveAuthorizationManager::isNotAnonymous -- org.springframework.security.authentication.AuthenticationTrustResolver::isAnonymous : this.authTrustResolver.isAnonymous(authentication) 
class AuthoritiesAuthorizationManager  implements org.springframework.security.authorization.AuthorizationManager  {
  roleHierarchy : org.springframework.security.access.hierarchicalroles.RoleHierarchy
  setRoleHierarchy(roleHierarchy : org.springframework.security.access.hierarchicalroles.RoleHierarchy) : void
  check(authentication : java.util.function.Supplier, authorities : java.util.Collection) : org.springframework.security.authorization.AuthorityAuthorizationDecision
  isGranted(authentication : org.springframework.security.core.Authentication, authorities : java.util.Collection) : boolean
  isAuthorized(authentication : org.springframework.security.core.Authentication, authorities : java.util.Collection) : boolean
  getGrantedAuthorities(authentication : org.springframework.security.core.Authentication) : java.util.Collection
}
org.springframework.security.authorization.AuthoritiesAuthorizationManager::setRoleHierarchy -- org.springframework.util.Assert::notNull : Assert.notNull(roleHierarchy,"roleHierarchy cannot be null") 
org.springframework.security.authorization.AuthoritiesAuthorizationManager::check -- java.util.function.Supplier::get : authentication.get() 
org.springframework.security.authorization.AuthoritiesAuthorizationManager::check -- org.springframework.security.core.authority.AuthorityUtils::createAuthorityList : AuthorityUtils.createAuthorityList(authorities) 
org.springframework.security.authorization.AuthoritiesAuthorizationManager::isAuthorized -- java.util.Collection::contains : authorities.contains(grantedAuthority.getAuthority()) 
org.springframework.security.authorization.AuthoritiesAuthorizationManager::getGrantedAuthorities -- org.springframework.security.access.hierarchicalroles.RoleHierarchy::getReachableGrantedAuthorities : this.roleHierarchy.getReachableGrantedAuthorities(authentication.getAuthorities()) 
org.springframework.security.authorization.AuthoritiesAuthorizationManager::getGrantedAuthorities -- org.springframework.security.core.Authentication::getAuthorities : authentication.getAuthorities() 
class AuthorityAuthorizationDecision extends org.springframework.security.authorization.AuthorizationDecision   {
  serialVersionUID : long
  authorities : java.util.Collection
  AuthorityAuthorizationDecision(granted : boolean, authorities : java.util.Collection) : None
  getAuthorities() : java.util.Collection
  toString() : java.lang.String
}
org.springframework.security.authorization.AuthorityAuthorizationDecision::toString -- org.springframework.security.authorization.AuthorityAuthorizationDecision::getClass : getClass().getSimpleName() 
class AuthorityAuthorizationManager  implements org.springframework.security.authorization.AuthorizationManager  {
  ROLE_PREFIX : java.lang.String
  delegate : org.springframework.security.authorization.AuthoritiesAuthorizationManager
  authorities : java.util.Set
  AuthorityAuthorizationManager() : None
  setRoleHierarchy(roleHierarchy : org.springframework.security.access.hierarchicalroles.RoleHierarchy) : void
  hasRole(role : java.lang.String) : org.springframework.security.authorization.AuthorityAuthorizationManager
  hasAuthority(authority : java.lang.String) : org.springframework.security.authorization.AuthorityAuthorizationManager
  hasAnyRole() : org.springframework.security.authorization.AuthorityAuthorizationManager
  hasAnyRole(rolePrefix : java.lang.String, roles : org.springframework.security.authorization.String[]) : org.springframework.security.authorization.AuthorityAuthorizationManager
  hasAnyAuthority() : org.springframework.security.authorization.AuthorityAuthorizationManager
  toNamedRolesArray(rolePrefix : java.lang.String, roles : org.springframework.security.authorization.String[]) : org.springframework.security.authorization.String[]
  check(authentication : java.util.function.Supplier, object : org.springframework.security.authorization.T) : org.springframework.security.authorization.AuthorizationDecision
  toString() : java.lang.String
}
org.springframework.security.authorization.AuthorityAuthorizationManager::AuthorityAuthorizationManager -- java.util.Set::of : Set.of(authorities) 
org.springframework.security.authorization.AuthorityAuthorizationManager::setRoleHierarchy -- org.springframework.security.authorization.AuthoritiesAuthorizationManager::setRoleHierarchy : this.delegate.setRoleHierarchy(roleHierarchy) 
org.springframework.security.authorization.AuthorityAuthorizationManager::hasRole -- org.springframework.util.Assert::notNull : Assert.notNull(role,"role cannot be null") 
org.springframework.security.authorization.AuthorityAuthorizationManager::hasRole -- org.springframework.util.Assert::isTrue : Assert.isTrue(!role.startsWith(ROLE_PREFIX),()->role+" should not start with "+ROLE_PREFIX+" since "+ROLE_PREFIX+" is automatically prepended when using hasRole. Consider using hasAuthority instead.") 
org.springframework.security.authorization.AuthorityAuthorizationManager::hasRole -- java.lang.String::startsWith : role.startsWith(ROLE_PREFIX) 
org.springframework.security.authorization.AuthorityAuthorizationManager::hasAuthority -- org.springframework.util.Assert::notNull : Assert.notNull(authority,"authority cannot be null") 
org.springframework.security.authorization.AuthorityAuthorizationManager::hasAnyRole -- org.springframework.util.Assert::notNull : Assert.notNull(rolePrefix,"rolePrefix cannot be null") 
org.springframework.security.authorization.AuthorityAuthorizationManager::hasAnyRole -- org.springframework.util.Assert::notEmpty : Assert.notEmpty(roles,"roles cannot be empty") 
org.springframework.security.authorization.AuthorityAuthorizationManager::hasAnyRole -- org.springframework.util.Assert::noNullElements : Assert.noNullElements(roles,"roles cannot contain null values") 
org.springframework.security.authorization.AuthorityAuthorizationManager::hasAnyAuthority -- org.springframework.util.Assert::notEmpty : Assert.notEmpty(authorities,"authorities cannot be empty") 
org.springframework.security.authorization.AuthorityAuthorizationManager::hasAnyAuthority -- org.springframework.util.Assert::noNullElements : Assert.noNullElements(authorities,"authorities cannot contain null values") 
org.springframework.security.authorization.AuthorityAuthorizationManager::toNamedRolesArray -- org.springframework.util.Assert::isTrue : Assert.isTrue(rolePrefix.isEmpty()||!role.startsWith(rolePrefix),()->role+" should not start with "+rolePrefix+" since "+rolePrefix+" is automatically prepended when using hasAnyRole. Consider using hasAnyAuthority instead.") 
org.springframework.security.authorization.AuthorityAuthorizationManager::toNamedRolesArray -- java.lang.String::isEmpty : rolePrefix.isEmpty() 
org.springframework.security.authorization.AuthorityAuthorizationManager::check -- org.springframework.security.authorization.AuthoritiesAuthorizationManager::check : this.delegate.check(authentication,this.authorities) 
class AuthorityReactiveAuthorizationManager  implements org.springframework.security.authorization.ReactiveAuthorizationManager  {
  authorities : java.util.List
  AuthorityReactiveAuthorizationManager() : None
  check(authentication : reactor.core.publisher.Mono, object : org.springframework.security.authorization.T) : reactor.core.publisher.Mono
  hasAuthority(authority : java.lang.String) : org.springframework.security.authorization.AuthorityReactiveAuthorizationManager
  hasAnyAuthority() : org.springframework.security.authorization.AuthorityReactiveAuthorizationManager
  hasRole(role : java.lang.String) : org.springframework.security.authorization.AuthorityReactiveAuthorizationManager
  hasAnyRole() : org.springframework.security.authorization.AuthorityReactiveAuthorizationManager
  toNamedRolesArray() : org.springframework.security.authorization.String[]
}
org.springframework.security.authorization.AuthorityReactiveAuthorizationManager::AuthorityReactiveAuthorizationManager -- org.springframework.security.core.authority.AuthorityUtils::createAuthorityList : AuthorityUtils.createAuthorityList(authorities) 
org.springframework.security.authorization.AuthorityReactiveAuthorizationManager::check -- reactor.core.publisher.Mono::filter : authentication.filter(Authentication::isAuthenticated).flatMapIterable(Authentication::getAuthorities).map(GrantedAuthority::getAuthority).any((grantedAuthority)->this.authorities.stream().anyMatch((authority)->authority.getAuthority().equals(grantedAuthority))).map((granted)->((AuthorizationDecision)newAuthorityAuthorizationDecision(granted,this.authorities))).defaultIfEmpty(newAuthorityAuthorizationDecision(false,this.authorities)) 
org.springframework.security.authorization.AuthorityReactiveAuthorizationManager::check -- reactor.core.publisher.Mono::filter : authentication.filter(Authentication::isAuthenticated).flatMapIterable(Authentication::getAuthorities).map(GrantedAuthority::getAuthority).any((grantedAuthority)->this.authorities.stream().anyMatch((authority)->authority.getAuthority().equals(grantedAuthority))).map((granted)->((AuthorizationDecision)newAuthorityAuthorizationDecision(granted,this.authorities))) 
org.springframework.security.authorization.AuthorityReactiveAuthorizationManager::check -- reactor.core.publisher.Mono::filter : authentication.filter(Authentication::isAuthenticated).flatMapIterable(Authentication::getAuthorities).map(GrantedAuthority::getAuthority).any((grantedAuthority)->this.authorities.stream().anyMatch((authority)->authority.getAuthority().equals(grantedAuthority))) 
org.springframework.security.authorization.AuthorityReactiveAuthorizationManager::check -- reactor.core.publisher.Mono::filter : authentication.filter(Authentication::isAuthenticated).flatMapIterable(Authentication::getAuthorities).map(GrantedAuthority::getAuthority) 
org.springframework.security.authorization.AuthorityReactiveAuthorizationManager::check -- reactor.core.publisher.Mono::filter : authentication.filter(Authentication::isAuthenticated).flatMapIterable(Authentication::getAuthorities) 
org.springframework.security.authorization.AuthorityReactiveAuthorizationManager::check -- reactor.core.publisher.Mono::filter : authentication.filter(Authentication::isAuthenticated) 
org.springframework.security.authorization.AuthorityReactiveAuthorizationManager::check -- java.util.List::stream : this.authorities.stream().anyMatch((authority)->authority.getAuthority().equals(grantedAuthority)) 
org.springframework.security.authorization.AuthorityReactiveAuthorizationManager::check -- java.util.List::stream : this.authorities.stream() 
org.springframework.security.authorization.AuthorityReactiveAuthorizationManager::hasAuthority -- org.springframework.util.Assert::notNull : Assert.notNull(authority,"authority cannot be null") 
org.springframework.security.authorization.AuthorityReactiveAuthorizationManager::hasAnyAuthority -- org.springframework.util.Assert::notNull : Assert.notNull(authorities,"authorities cannot be null") 
org.springframework.security.authorization.AuthorityReactiveAuthorizationManager::hasAnyAuthority -- org.springframework.util.Assert::notNull : Assert.notNull(authority,"authority cannot be null") 
org.springframework.security.authorization.AuthorityReactiveAuthorizationManager::hasRole -- org.springframework.util.Assert::notNull : Assert.notNull(role,"role cannot be null") 
org.springframework.security.authorization.AuthorityReactiveAuthorizationManager::hasAnyRole -- org.springframework.util.Assert::notNull : Assert.notNull(roles,"roles cannot be null") 
org.springframework.security.authorization.AuthorityReactiveAuthorizationManager::hasAnyRole -- org.springframework.util.Assert::notNull : Assert.notNull(role,"role cannot be null") 
class AuthorizationDecision  implements org.springframework.security.authorization.AuthorizationResult  {
  serialVersionUID : long
  granted : boolean
  AuthorizationDecision(granted : boolean) : None
  isGranted() : boolean
  toString() : java.lang.String
}
org.springframework.security.authorization.AuthorizationDecision::toString -- org.springframework.security.authorization.AuthorizationDecision::getClass : getClass().getSimpleName() 
class AuthorizationDeniedException extends org.springframework.security.access.AccessDeniedException implements org.springframework.security.authorization.AuthorizationResult  {
  serialVersionUID : long
  result : org.springframework.security.authorization.AuthorizationResult
  AuthorizationDeniedException(msg : java.lang.String, authorizationResult : org.springframework.security.authorization.AuthorizationResult) : None
  AuthorizationDeniedException(msg : java.lang.String) : None
  getAuthorizationResult() : org.springframework.security.authorization.AuthorizationResult
  isGranted() : boolean
}
org.springframework.security.authorization.AuthorizationDeniedException::AuthorizationDeniedException -- org.springframework.util.Assert::notNull : Assert.notNull(authorizationResult,"authorizationResult cannot be null") 
org.springframework.security.authorization.AuthorizationDeniedException::AuthorizationDeniedException -- org.springframework.util.Assert::isTrue : Assert.isTrue(!authorizationResult.isGranted(),"Granted authorization results are not supported") 
org.springframework.security.authorization.AuthorizationDeniedException::AuthorizationDeniedException -- org.springframework.security.authorization.AuthorizationResult::isGranted : authorizationResult.isGranted() 
interface AuthorizationEventPublisher    {
  publishAuthorizationEvent(authentication : java.util.function.Supplier, object : org.springframework.security.authorization.T, decision : org.springframework.security.authorization.AuthorizationDecision) : void
  publishAuthorizationEvent(authentication : java.util.function.Supplier, object : org.springframework.security.authorization.T, result : org.springframework.security.authorization.AuthorizationResult) : void
}
interface AuthorizationManager    {
  verify(authentication : java.util.function.Supplier, object : org.springframework.security.authorization.T) : void
  check(authentication : java.util.function.Supplier, object : org.springframework.security.authorization.T) : org.springframework.security.authorization.AuthorizationDecision
  authorize(authentication : java.util.function.Supplier, object : org.springframework.security.authorization.T) : org.springframework.security.authorization.AuthorizationResult
}
class AuthorizationManagers    {
  anyOf() : org.springframework.security.authorization.AuthorizationManager
  anyOf(allAbstainDefaultDecision : org.springframework.security.authorization.AuthorizationDecision) : org.springframework.security.authorization.AuthorizationManager
  allOf() : org.springframework.security.authorization.AuthorizationManager
  allOf(allAbstainDefaultDecision : org.springframework.security.authorization.AuthorizationDecision) : org.springframework.security.authorization.AuthorizationManager
  not(manager : org.springframework.security.authorization.AuthorizationManager) : org.springframework.security.authorization.AuthorizationManager
  AuthorizationManagers() : None
}
org.springframework.security.authorization.AuthorizationManagers::not -- org.springframework.security.authorization.AuthorizationManager::authorize : manager.authorize(authentication,object) 
class CompositeAuthorizationDecision extends org.springframework.security.authorization.AuthorizationDecision   {
  results : org.springframework.security.authorization.List
  CompositeAuthorizationDecision(granted : boolean, results : org.springframework.security.authorization.List) : None
  toString() : java.lang.String
}
class NotAuthorizationDecision extends org.springframework.security.authorization.AuthorizationDecision   {
  result : org.springframework.security.authorization.AuthorizationResult
  NotAuthorizationDecision(result : org.springframework.security.authorization.AuthorizationResult) : None
  toString() : java.lang.String
}
org.springframework.security.authorization.NotAuthorizationDecision::NotAuthorizationDecision -- org.springframework.security.authorization.AuthorizationResult::isGranted : result.isGranted() 
interface AuthorizationManagerCheckAdapter    {
  check(authentication : org.springframework.security.authorization.Supplier, object : org.springframework.security.authorization.T) : org.springframework.security.authorization.AuthorizationDecision
  authorize(authentication : org.springframework.security.authorization.Supplier, object : org.springframework.security.authorization.T) : org.springframework.security.authorization.AuthorizationResult
}
class AuthorizationObservationContext extends org.springframework.security.authorization.Observation.Context   {
  authentication : org.springframework.security.core.Authentication
  object : org.springframework.security.authorization.T
  authorizationResult : org.springframework.security.authorization.AuthorizationResult
  AuthorizationObservationContext(object : org.springframework.security.authorization.T) : None
  getAuthentication() : org.springframework.security.core.Authentication
  setAuthentication(authentication : org.springframework.security.core.Authentication) : void
  getObject() : org.springframework.security.authorization.T
  getDecision() : org.springframework.security.authorization.AuthorizationDecision
  setDecision(decision : org.springframework.security.authorization.AuthorizationDecision) : void
  getAuthorizationResult() : org.springframework.security.authorization.AuthorizationResult
  setAuthorizationResult(authorizationResult : org.springframework.security.authorization.AuthorizationResult) : void
}
org.springframework.security.authorization.AuthorizationObservationContext::AuthorizationObservationContext -- org.springframework.util.Assert::notNull : Assert.notNull(object,"object cannot be null") 
class AuthorizationObservationConvention  implements io.micrometer.observation.ObservationConvention  {
  OBSERVATION_NAME : java.lang.String
  getName() : java.lang.String
  getContextualName(context : org.springframework.security.authorization.AuthorizationObservationContext) : java.lang.String
  getLowCardinalityKeyValues(context : org.springframework.security.authorization.AuthorizationObservationContext) : io.micrometer.common.KeyValues
  getHighCardinalityKeyValues(context : org.springframework.security.authorization.AuthorizationObservationContext) : io.micrometer.common.KeyValues
  supportsContext(context : org.springframework.security.authorization.Observation.Context) : boolean
  getAuthenticationType(context : org.springframework.security.authorization.AuthorizationObservationContext) : java.lang.String
  getObjectType(context : org.springframework.security.authorization.AuthorizationObservationContext) : java.lang.String
  getAuthorizationDecision(context : org.springframework.security.authorization.AuthorizationObservationContext) : java.lang.String
  getAuthorities(context : org.springframework.security.authorization.AuthorizationObservationContext) : java.lang.String
  getDecisionDetails(context : org.springframework.security.authorization.AuthorizationObservationContext) : java.lang.String
}
org.springframework.security.authorization.AuthorizationObservationConvention::getLowCardinalityKeyValues -- io.micrometer.common.KeyValues::of : KeyValues.of("spring.security.authentication.type",getAuthenticationType(context)).and("spring.security.object",getObjectType(context)).and("spring.security.authorization.decision",getAuthorizationDecision(context)) 
org.springframework.security.authorization.AuthorizationObservationConvention::getLowCardinalityKeyValues -- io.micrometer.common.KeyValues::of : KeyValues.of("spring.security.authentication.type",getAuthenticationType(context)).and("spring.security.object",getObjectType(context)) 
org.springframework.security.authorization.AuthorizationObservationConvention::getLowCardinalityKeyValues -- io.micrometer.common.KeyValues::of : KeyValues.of("spring.security.authentication.type",getAuthenticationType(context)) 
org.springframework.security.authorization.AuthorizationObservationConvention::getHighCardinalityKeyValues -- io.micrometer.common.KeyValues::of : KeyValues.of("spring.security.authentication.authorities",getAuthorities(context)).and("spring.security.authorization.decision.details",getDecisionDetails(context)) 
org.springframework.security.authorization.AuthorizationObservationConvention::getHighCardinalityKeyValues -- io.micrometer.common.KeyValues::of : KeyValues.of("spring.security.authentication.authorities",getAuthorities(context)) 
org.springframework.security.authorization.AuthorizationObservationConvention::getAuthenticationType -- org.springframework.security.authorization.AuthorizationObservationContext::getAuthentication : context.getAuthentication() 
org.springframework.security.authorization.AuthorizationObservationConvention::getAuthenticationType -- org.springframework.security.authorization.AuthorizationObservationContext::getAuthentication : context.getAuthentication().getClass().getSimpleName() 
org.springframework.security.authorization.AuthorizationObservationConvention::getAuthenticationType -- org.springframework.security.authorization.AuthorizationObservationContext::getAuthentication : context.getAuthentication().getClass() 
org.springframework.security.authorization.AuthorizationObservationConvention::getAuthenticationType -- org.springframework.security.authorization.AuthorizationObservationContext::getAuthentication : context.getAuthentication() 
org.springframework.security.authorization.AuthorizationObservationConvention::getObjectType -- org.springframework.security.authorization.AuthorizationObservationContext::getObject : context.getObject() 
org.springframework.security.authorization.AuthorizationObservationConvention::getObjectType -- org.springframework.security.authorization.AuthorizationObservationContext::getObject : context.getObject() 
org.springframework.security.authorization.AuthorizationObservationConvention::getObjectType -- org.springframework.security.authorization.AuthorizationObservationContext::getObject : context.getObject().getClass().getSimpleName() 
org.springframework.security.authorization.AuthorizationObservationConvention::getObjectType -- org.springframework.security.authorization.AuthorizationObservationContext::getObject : context.getObject().getClass() 
org.springframework.security.authorization.AuthorizationObservationConvention::getObjectType -- org.springframework.security.authorization.AuthorizationObservationContext::getObject : context.getObject() 
org.springframework.security.authorization.AuthorizationObservationConvention::getAuthorizationDecision -- org.springframework.security.authorization.AuthorizationObservationContext::getAuthorizationResult : context.getAuthorizationResult() 
org.springframework.security.authorization.AuthorizationObservationConvention::getAuthorizationDecision -- java.lang.String::valueOf : String.valueOf(context.getAuthorizationResult().isGranted()) 
org.springframework.security.authorization.AuthorizationObservationConvention::getAuthorizationDecision -- org.springframework.security.authorization.AuthorizationObservationContext::getAuthorizationResult : context.getAuthorizationResult().isGranted() 
org.springframework.security.authorization.AuthorizationObservationConvention::getAuthorizationDecision -- org.springframework.security.authorization.AuthorizationObservationContext::getAuthorizationResult : context.getAuthorizationResult() 
org.springframework.security.authorization.AuthorizationObservationConvention::getAuthorities -- org.springframework.security.authorization.AuthorizationObservationContext::getAuthentication : context.getAuthentication() 
org.springframework.security.authorization.AuthorizationObservationConvention::getAuthorities -- java.lang.String::valueOf : String.valueOf(context.getAuthentication().getAuthorities()) 
org.springframework.security.authorization.AuthorizationObservationConvention::getAuthorities -- org.springframework.security.authorization.AuthorizationObservationContext::getAuthentication : context.getAuthentication().getAuthorities() 
org.springframework.security.authorization.AuthorizationObservationConvention::getAuthorities -- org.springframework.security.authorization.AuthorizationObservationContext::getAuthentication : context.getAuthentication() 
org.springframework.security.authorization.AuthorizationObservationConvention::getDecisionDetails -- org.springframework.security.authorization.AuthorizationObservationContext::getAuthorizationResult : context.getAuthorizationResult() 
org.springframework.security.authorization.AuthorizationObservationConvention::getDecisionDetails -- org.springframework.security.authorization.AuthorizationObservationContext::getAuthorizationResult : context.getAuthorizationResult() 
org.springframework.security.authorization.AuthorizationObservationConvention::getDecisionDetails -- java.lang.String::valueOf : String.valueOf(decision) 
interface AuthorizationProxyFactory    {
  proxy(object : java.lang.Object) : java.lang.Object
}
interface AuthorizationResult    {
  isGranted() : boolean
}
class ExpressionAuthorizationDecision extends org.springframework.security.authorization.AuthorizationDecision   {
  expression : org.springframework.expression.Expression
  ExpressionAuthorizationDecision(granted : boolean, expressionAttribute : org.springframework.expression.Expression) : None
  getExpression() : org.springframework.expression.Expression
  toString() : java.lang.String
}
org.springframework.security.authorization.ExpressionAuthorizationDecision::toString -- org.springframework.security.authorization.ExpressionAuthorizationDecision::getClass : getClass().getSimpleName() 
org.springframework.security.authorization.ExpressionAuthorizationDecision::toString -- org.springframework.expression.Expression::getExpressionString : this.expression.getExpressionString() 
class ObservationAuthorizationManager  implements org.springframework.security.authorization.AuthorizationManager  {
  registry : io.micrometer.observation.ObservationRegistry
  delegate : org.springframework.security.authorization.AuthorizationManager
  convention : io.micrometer.observation.ObservationConvention
  messages : org.springframework.context.support.MessageSourceAccessor
  handler : org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler
  ObservationAuthorizationManager(registry : io.micrometer.observation.ObservationRegistry, delegate : org.springframework.security.authorization.AuthorizationManager) : None
  check(authentication : java.util.function.Supplier, object : org.springframework.security.authorization.T) : org.springframework.security.authorization.AuthorizationDecision
  setObservationConvention(convention : io.micrometer.observation.ObservationConvention) : void
  setMessageSource(messageSource : org.springframework.context.MessageSource) : void
  handleDeniedInvocation(methodInvocation : org.aopalliance.intercept.MethodInvocation, authorizationResult : org.springframework.security.authorization.AuthorizationResult) : java.lang.Object
  handleDeniedInvocationResult(methodInvocationResult : org.springframework.security.authorization.method.MethodInvocationResult, authorizationResult : org.springframework.security.authorization.AuthorizationResult) : java.lang.Object
}
org.springframework.security.authorization.ObservationAuthorizationManager::check -- java.util.function.Supplier::get : authentication.get() 
org.springframework.security.authorization.ObservationAuthorizationManager::check -- io.micrometer.observation.Observation::createNotStarted : Observation.createNotStarted(this.convention,()->context,this.registry).start() 
org.springframework.security.authorization.ObservationAuthorizationManager::check -- io.micrometer.observation.Observation::createNotStarted : Observation.createNotStarted(this.convention,()->context,this.registry) 
org.springframework.security.authorization.ObservationAuthorizationManager::check -- org.springframework.security.authorization.AuthorizationManager::check : this.delegate.check(wrapped,object) 
org.springframework.security.authorization.ObservationAuthorizationManager::check -- org.springframework.context.support.MessageSourceAccessor::getMessage : this.messages.getMessage("AbstractAccessDecisionManager.accessDenied","Access Denied") 
org.springframework.security.authorization.ObservationAuthorizationManager::setObservationConvention -- org.springframework.util.Assert::notNull : Assert.notNull(convention,"The observation convention cannot be null") 
org.springframework.security.authorization.ObservationAuthorizationManager::handleDeniedInvocation -- org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler::handleDeniedInvocation : this.handler.handleDeniedInvocation(methodInvocation,authorizationResult) 
org.springframework.security.authorization.ObservationAuthorizationManager::handleDeniedInvocationResult -- org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler::handleDeniedInvocationResult : this.handler.handleDeniedInvocationResult(methodInvocationResult,authorizationResult) 
class ObservationReactiveAuthorizationManager  implements org.springframework.security.authorization.ReactiveAuthorizationManager  {
  registry : io.micrometer.observation.ObservationRegistry
  delegate : org.springframework.security.authorization.ReactiveAuthorizationManager
  convention : io.micrometer.observation.ObservationConvention
  handler : org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler
  ObservationReactiveAuthorizationManager(registry : io.micrometer.observation.ObservationRegistry, delegate : org.springframework.security.authorization.ReactiveAuthorizationManager) : None
  check(authentication : reactor.core.publisher.Mono, object : org.springframework.security.authorization.T) : reactor.core.publisher.Mono
  setObservationConvention(convention : io.micrometer.observation.ObservationConvention) : void
  handleDeniedInvocation(methodInvocation : org.aopalliance.intercept.MethodInvocation, authorizationResult : org.springframework.security.authorization.AuthorizationResult) : java.lang.Object
  handleDeniedInvocationResult(methodInvocationResult : org.springframework.security.authorization.method.MethodInvocationResult, authorizationResult : org.springframework.security.authorization.AuthorizationResult) : java.lang.Object
}
org.springframework.security.authorization.ObservationReactiveAuthorizationManager::check -- reactor.core.publisher.Mono::map : authentication.map((auth)->{context.setAuthentication(auth);returncontext.getAuthentication();}) 
org.springframework.security.authorization.ObservationReactiveAuthorizationManager::check -- reactor.core.publisher.Mono::deferContextual : Mono.deferContextual((contextView)->{Observationobservation=Observation.createNotStarted(this.convention,()->context,this.registry).parentObservation(contextView.getOrDefault(ObservationThreadLocalAccessor.KEY,null)).start();returnthis.delegate.check(wrapped,object).doOnSuccess((decision)->{context.setAuthorizationResult(decision);if(decision==null||!decision.isGranted()){observation.error(newAccessDeniedException("Access Denied"));}observation.stop();}).doOnCancel(observation::stop).doOnError((t)->{observation.error(t);observation.stop();});}) 
org.springframework.security.authorization.ObservationReactiveAuthorizationManager::check -- io.micrometer.observation.Observation::createNotStarted : Observation.createNotStarted(this.convention,()->context,this.registry).parentObservation(contextView.getOrDefault(ObservationThreadLocalAccessor.KEY,null)).start() 
org.springframework.security.authorization.ObservationReactiveAuthorizationManager::check -- io.micrometer.observation.Observation::createNotStarted : Observation.createNotStarted(this.convention,()->context,this.registry).parentObservation(contextView.getOrDefault(ObservationThreadLocalAccessor.KEY,null)) 
org.springframework.security.authorization.ObservationReactiveAuthorizationManager::check -- io.micrometer.observation.Observation::createNotStarted : Observation.createNotStarted(this.convention,()->context,this.registry) 
org.springframework.security.authorization.ObservationReactiveAuthorizationManager::check -- org.springframework.security.authorization.ReactiveAuthorizationManager::check : this.delegate.check(wrapped,object).doOnSuccess((decision)->{context.setAuthorizationResult(decision);if(decision==null||!decision.isGranted()){observation.error(newAccessDeniedException("Access Denied"));}observation.stop();}).doOnCancel(observation::stop).doOnError((t)->{observation.error(t);observation.stop();}) 
org.springframework.security.authorization.ObservationReactiveAuthorizationManager::check -- org.springframework.security.authorization.ReactiveAuthorizationManager::check : this.delegate.check(wrapped,object).doOnSuccess((decision)->{context.setAuthorizationResult(decision);if(decision==null||!decision.isGranted()){observation.error(newAccessDeniedException("Access Denied"));}observation.stop();}).doOnCancel(observation::stop) 
org.springframework.security.authorization.ObservationReactiveAuthorizationManager::check -- org.springframework.security.authorization.ReactiveAuthorizationManager::check : this.delegate.check(wrapped,object).doOnSuccess((decision)->{context.setAuthorizationResult(decision);if(decision==null||!decision.isGranted()){observation.error(newAccessDeniedException("Access Denied"));}observation.stop();}) 
org.springframework.security.authorization.ObservationReactiveAuthorizationManager::check -- org.springframework.security.authorization.ReactiveAuthorizationManager::check : this.delegate.check(wrapped,object) 
org.springframework.security.authorization.ObservationReactiveAuthorizationManager::setObservationConvention -- org.springframework.util.Assert::notNull : Assert.notNull(convention,"The observation convention cannot be null") 
org.springframework.security.authorization.ObservationReactiveAuthorizationManager::handleDeniedInvocation -- org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler::handleDeniedInvocation : this.handler.handleDeniedInvocation(methodInvocation,authorizationResult) 
org.springframework.security.authorization.ObservationReactiveAuthorizationManager::handleDeniedInvocationResult -- org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler::handleDeniedInvocationResult : this.handler.handleDeniedInvocationResult(methodInvocationResult,authorizationResult) 
interface ReactiveAuthorizationManager    {
  check(authentication : reactor.core.publisher.Mono, object : org.springframework.security.authorization.T) : reactor.core.publisher.Mono
  verify(authentication : reactor.core.publisher.Mono, object : org.springframework.security.authorization.T) : reactor.core.publisher.Mono
  authorize(authentication : reactor.core.publisher.Mono, object : org.springframework.security.authorization.T) : reactor.core.publisher.Mono
}
org.springframework.security.authorization.ReactiveAuthorizationManager::verify -- org.springframework.security.authorization.ReactiveAuthorizationManager::check : check(authentication,object).filter(AuthorizationDecision::isGranted).switchIfEmpty(Mono.defer(()->Mono.error(newAccessDeniedException("Access Denied")))).flatMap((decision)->Mono.empty()) 
org.springframework.security.authorization.ReactiveAuthorizationManager::verify -- org.springframework.security.authorization.ReactiveAuthorizationManager::check : check(authentication,object).filter(AuthorizationDecision::isGranted).switchIfEmpty(Mono.defer(()->Mono.error(newAccessDeniedException("Access Denied")))) 
org.springframework.security.authorization.ReactiveAuthorizationManager::verify -- org.springframework.security.authorization.ReactiveAuthorizationManager::check : check(authentication,object).filter(AuthorizationDecision::isGranted) 
org.springframework.security.authorization.ReactiveAuthorizationManager::verify -- reactor.core.publisher.Mono::defer : Mono.defer(()->Mono.error(newAccessDeniedException("Access Denied"))) 
org.springframework.security.authorization.ReactiveAuthorizationManager::verify -- reactor.core.publisher.Mono::error : Mono.error(newAccessDeniedException("Access Denied")) 
org.springframework.security.authorization.ReactiveAuthorizationManager::verify -- reactor.core.publisher.Mono::empty : Mono.empty() 
org.springframework.security.authorization.ReactiveAuthorizationManager::authorize -- org.springframework.security.authorization.ReactiveAuthorizationManager::check : check(authentication,object).cast(AuthorizationResult.class) 
class SingleResultAuthorizationManager  implements org.springframework.security.authorization.AuthorizationManager  {
  DENY_MANAGER : org.springframework.security.authorization.SingleResultAuthorizationManager
  PERMIT_MANAGER : org.springframework.security.authorization.SingleResultAuthorizationManager
  result : org.springframework.security.authorization.AuthorizationResult
  SingleResultAuthorizationManager(result : org.springframework.security.authorization.AuthorizationResult) : None
  check(authentication : java.util.function.Supplier, object : org.springframework.security.authorization.C) : org.springframework.security.authorization.AuthorizationDecision
  authorize(authentication : java.util.function.Supplier, object : org.springframework.security.authorization.C) : org.springframework.security.authorization.AuthorizationResult
  denyAll() : org.springframework.security.authorization.SingleResultAuthorizationManager
  permitAll() : org.springframework.security.authorization.SingleResultAuthorizationManager
}
org.springframework.security.authorization.SingleResultAuthorizationManager::SingleResultAuthorizationManager -- org.springframework.util.Assert::notNull : Assert.notNull(result,"result cannot be null") 
class SpringAuthorizationEventPublisher  implements org.springframework.security.authorization.AuthorizationEventPublisher  {
  eventPublisher : org.springframework.context.ApplicationEventPublisher
  SpringAuthorizationEventPublisher(eventPublisher : org.springframework.context.ApplicationEventPublisher) : None
  publishAuthorizationEvent(authentication : java.util.function.Supplier, object : org.springframework.security.authorization.T, decision : org.springframework.security.authorization.AuthorizationDecision) : void
  publishAuthorizationEvent(authentication : java.util.function.Supplier, object : org.springframework.security.authorization.T, result : org.springframework.security.authorization.AuthorizationResult) : void
}
org.springframework.security.authorization.SpringAuthorizationEventPublisher::SpringAuthorizationEventPublisher -- org.springframework.util.Assert::notNull : Assert.notNull(eventPublisher,"eventPublisher cannot be null") 
org.springframework.security.authorization.SpringAuthorizationEventPublisher::publishAuthorizationEvent -- org.springframework.security.authorization.AuthorizationResult::isGranted : result.isGranted() 
org.springframework.security.authorization.SpringAuthorizationEventPublisher::publishAuthorizationEvent -- org.springframework.context.ApplicationEventPublisher::publishEvent : this.eventPublisher.publishEvent(failure) 
}
package concurrent {
class AbstractDelegatingSecurityContextSupport    {
  securityContextHolderStrategy : org.springframework.security.core.context.SecurityContextHolderStrategy
  securityContext : org.springframework.security.core.context.SecurityContext
  AbstractDelegatingSecurityContextSupport(securityContext : org.springframework.security.core.context.SecurityContext) : None
  setSecurityContextHolderStrategy(securityContextHolderStrategy : org.springframework.security.core.context.SecurityContextHolderStrategy) : void
  wrap(delegate : org.springframework.security.concurrent.Runnable) : org.springframework.security.concurrent.Runnable
  wrap(delegate : java.util.concurrent.Callable) : java.util.concurrent.Callable
}
org.springframework.security.concurrent.AbstractDelegatingSecurityContextSupport::setSecurityContextHolderStrategy -- org.springframework.util.Assert::notNull : Assert.notNull(securityContextHolderStrategy,"securityContextHolderStrategy cannot be null") 
org.springframework.security.concurrent.AbstractDelegatingSecurityContextSupport::wrap -- org.springframework.security.concurrent.DelegatingSecurityContextRunnable::create : DelegatingSecurityContextRunnable.create(delegate,this.securityContext,this.securityContextHolderStrategy) 
org.springframework.security.concurrent.AbstractDelegatingSecurityContextSupport::wrap -- org.springframework.security.concurrent.DelegatingSecurityContextCallable::create : DelegatingSecurityContextCallable.create(delegate,this.securityContext,this.securityContextHolderStrategy) 
class DelegatingSecurityContextCallable  implements java.util.concurrent.Callable  {
  delegate : java.util.concurrent.Callable
  explicitSecurityContextProvided : boolean
  delegateSecurityContext : org.springframework.security.core.context.SecurityContext
  securityContextHolderStrategy : org.springframework.security.core.context.SecurityContextHolderStrategy
  originalSecurityContext : org.springframework.security.core.context.SecurityContext
  DelegatingSecurityContextCallable(delegate : java.util.concurrent.Callable, securityContext : org.springframework.security.core.context.SecurityContext) : None
  DelegatingSecurityContextCallable(delegate : java.util.concurrent.Callable) : None
  DelegatingSecurityContextCallable(delegate : java.util.concurrent.Callable, securityContext : org.springframework.security.core.context.SecurityContext, explicitSecurityContextProvided : boolean) : None
  call() : org.springframework.security.concurrent.V
  setSecurityContextHolderStrategy(securityContextHolderStrategy : org.springframework.security.core.context.SecurityContextHolderStrategy) : void
  toString() : java.lang.String
  create(delegate : java.util.concurrent.Callable, securityContext : org.springframework.security.core.context.SecurityContext) : java.util.concurrent.Callable
  create(delegate : java.util.concurrent.Callable, securityContext : org.springframework.security.core.context.SecurityContext, securityContextHolderStrategy : org.springframework.security.core.context.SecurityContextHolderStrategy) : java.util.concurrent.Callable
}
org.springframework.security.concurrent.DelegatingSecurityContextCallable::DelegatingSecurityContextCallable -- org.springframework.security.core.context.SecurityContextHolder::getContext : SecurityContextHolder.getContext() 
org.springframework.security.concurrent.DelegatingSecurityContextCallable::DelegatingSecurityContextCallable -- org.springframework.util.Assert::notNull : Assert.notNull(delegate,"delegate cannot be null") 
org.springframework.security.concurrent.DelegatingSecurityContextCallable::DelegatingSecurityContextCallable -- org.springframework.util.Assert::notNull : Assert.notNull(securityContext,"securityContext cannot be null") 
org.springframework.security.concurrent.DelegatingSecurityContextCallable::call -- org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : this.securityContextHolderStrategy.getContext() 
org.springframework.security.concurrent.DelegatingSecurityContextCallable::call -- org.springframework.security.core.context.SecurityContextHolderStrategy::setContext : this.securityContextHolderStrategy.setContext(this.delegateSecurityContext) 
org.springframework.security.concurrent.DelegatingSecurityContextCallable::call -- java.util.concurrent.Callable::call : this.delegate.call() 
org.springframework.security.concurrent.DelegatingSecurityContextCallable::call -- org.springframework.security.core.context.SecurityContextHolderStrategy::createEmptyContext : this.securityContextHolderStrategy.createEmptyContext() 
org.springframework.security.concurrent.DelegatingSecurityContextCallable::call -- org.springframework.security.core.context.SecurityContextHolderStrategy::clearContext : this.securityContextHolderStrategy.clearContext() 
org.springframework.security.concurrent.DelegatingSecurityContextCallable::call -- org.springframework.security.core.context.SecurityContextHolderStrategy::setContext : this.securityContextHolderStrategy.setContext(this.originalSecurityContext) 
org.springframework.security.concurrent.DelegatingSecurityContextCallable::setSecurityContextHolderStrategy -- org.springframework.util.Assert::notNull : Assert.notNull(securityContextHolderStrategy,"securityContextHolderStrategy cannot be null") 
org.springframework.security.concurrent.DelegatingSecurityContextCallable::setSecurityContextHolderStrategy -- org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : securityContextHolderStrategy.getContext() 
org.springframework.security.concurrent.DelegatingSecurityContextCallable::toString -- java.util.concurrent.Callable::toString : this.delegate.toString() 
org.springframework.security.concurrent.DelegatingSecurityContextCallable::create -- org.springframework.util.Assert::notNull : Assert.notNull(delegate,"delegate cannot be null") 
org.springframework.security.concurrent.DelegatingSecurityContextCallable::create -- org.springframework.util.Assert::notNull : Assert.notNull(securityContextHolderStrategy,"securityContextHolderStrategy cannot be null") 
class DelegatingSecurityContextExecutor extends org.springframework.security.concurrent.AbstractDelegatingSecurityContextSupport implements java.util.concurrent.Executor  {
  delegate : java.util.concurrent.Executor
  DelegatingSecurityContextExecutor(delegateExecutor : java.util.concurrent.Executor, securityContext : org.springframework.security.core.context.SecurityContext) : None
  DelegatingSecurityContextExecutor(delegate : java.util.concurrent.Executor) : None
  execute(task : org.springframework.security.concurrent.Runnable) : void
  getDelegateExecutor() : java.util.concurrent.Executor
  setSecurityContextHolderStrategy(securityContextHolderStrategy : org.springframework.security.core.context.SecurityContextHolderStrategy) : void
}
org.springframework.security.concurrent.DelegatingSecurityContextExecutor::DelegatingSecurityContextExecutor -- org.springframework.util.Assert::notNull : Assert.notNull(delegateExecutor,"delegateExecutor cannot be null") 
org.springframework.security.concurrent.DelegatingSecurityContextExecutor::execute -- java.util.concurrent.Executor::execute : this.delegate.execute(wrap(task)) 
class DelegatingSecurityContextExecutorService extends org.springframework.security.concurrent.DelegatingSecurityContextExecutor implements java.util.concurrent.ExecutorService  {
  DelegatingSecurityContextExecutorService(delegateExecutorService : java.util.concurrent.ExecutorService, securityContext : org.springframework.security.core.context.SecurityContext) : None
  DelegatingSecurityContextExecutorService(delegate : java.util.concurrent.ExecutorService) : None
  shutdown() : void
  shutdownNow() : java.util.List
  isShutdown() : boolean
  isTerminated() : boolean
  awaitTermination(timeout : long, unit : java.util.concurrent.TimeUnit) : boolean
  submit(task : java.util.concurrent.Callable) : java.util.concurrent.Future
  submit(task : org.springframework.security.concurrent.Runnable, result : org.springframework.security.concurrent.T) : java.util.concurrent.Future
  submit(task : org.springframework.security.concurrent.Runnable) : java.util.concurrent.Future
  invokeAll(tasks : java.util.Collection) : java.util.List
  invokeAll(tasks : java.util.Collection, timeout : long, unit : java.util.concurrent.TimeUnit) : java.util.List
  invokeAny(tasks : java.util.Collection) : java.lang.Object
  invokeAny(tasks : java.util.Collection, timeout : long, unit : java.util.concurrent.TimeUnit) : java.lang.Object
  createTasks(tasks : java.util.Collection) : java.util.Collection
  getDelegate() : java.util.concurrent.ExecutorService
}
org.springframework.security.concurrent.DelegatingSecurityContextExecutorService::shutdown -- org.springframework.security.concurrent.DelegatingSecurityContextExecutorService::getDelegate : getDelegate().shutdown() 
org.springframework.security.concurrent.DelegatingSecurityContextExecutorService::shutdownNow -- org.springframework.security.concurrent.DelegatingSecurityContextExecutorService::getDelegate : getDelegate().shutdownNow() 
org.springframework.security.concurrent.DelegatingSecurityContextExecutorService::isShutdown -- org.springframework.security.concurrent.DelegatingSecurityContextExecutorService::getDelegate : getDelegate().isShutdown() 
org.springframework.security.concurrent.DelegatingSecurityContextExecutorService::isTerminated -- org.springframework.security.concurrent.DelegatingSecurityContextExecutorService::getDelegate : getDelegate().isTerminated() 
org.springframework.security.concurrent.DelegatingSecurityContextExecutorService::awaitTermination -- org.springframework.security.concurrent.DelegatingSecurityContextExecutorService::getDelegate : getDelegate().awaitTermination(timeout,unit) 
org.springframework.security.concurrent.DelegatingSecurityContextExecutorService::submit -- org.springframework.security.concurrent.DelegatingSecurityContextExecutorService::getDelegate : getDelegate().submit(wrap(task)) 
org.springframework.security.concurrent.DelegatingSecurityContextExecutorService::submit -- org.springframework.security.concurrent.DelegatingSecurityContextExecutorService::getDelegate : getDelegate().submit(wrap(task),result) 
org.springframework.security.concurrent.DelegatingSecurityContextExecutorService::submit -- org.springframework.security.concurrent.DelegatingSecurityContextExecutorService::getDelegate : getDelegate().submit(wrap(task)) 
org.springframework.security.concurrent.DelegatingSecurityContextExecutorService::invokeAll -- org.springframework.security.concurrent.DelegatingSecurityContextExecutorService::getDelegate : getDelegate().invokeAll(tasks) 
org.springframework.security.concurrent.DelegatingSecurityContextExecutorService::invokeAll -- org.springframework.security.concurrent.DelegatingSecurityContextExecutorService::getDelegate : getDelegate().invokeAll(tasks,timeout,unit) 
org.springframework.security.concurrent.DelegatingSecurityContextExecutorService::invokeAny -- org.springframework.security.concurrent.DelegatingSecurityContextExecutorService::getDelegate : getDelegate().invokeAny(tasks) 
org.springframework.security.concurrent.DelegatingSecurityContextExecutorService::invokeAny -- org.springframework.security.concurrent.DelegatingSecurityContextExecutorService::getDelegate : getDelegate().invokeAny(tasks,timeout,unit) 
org.springframework.security.concurrent.DelegatingSecurityContextExecutorService::createTasks -- java.util.Collection::size : tasks.size() 
class DelegatingSecurityContextRunnable  implements org.springframework.security.concurrent.Runnable  {
  delegate : org.springframework.security.concurrent.Runnable
  explicitSecurityContextProvided : boolean
  securityContextHolderStrategy : org.springframework.security.core.context.SecurityContextHolderStrategy
  delegateSecurityContext : org.springframework.security.core.context.SecurityContext
  originalSecurityContext : org.springframework.security.core.context.SecurityContext
  DelegatingSecurityContextRunnable(delegate : org.springframework.security.concurrent.Runnable, securityContext : org.springframework.security.core.context.SecurityContext) : None
  DelegatingSecurityContextRunnable(delegate : org.springframework.security.concurrent.Runnable) : None
  DelegatingSecurityContextRunnable(delegate : org.springframework.security.concurrent.Runnable, securityContext : org.springframework.security.core.context.SecurityContext, explicitSecurityContextProvided : boolean) : None
  run() : void
  setSecurityContextHolderStrategy(securityContextHolderStrategy : org.springframework.security.core.context.SecurityContextHolderStrategy) : void
  toString() : java.lang.String
  create(delegate : org.springframework.security.concurrent.Runnable, securityContext : org.springframework.security.core.context.SecurityContext) : org.springframework.security.concurrent.Runnable
  create(delegate : org.springframework.security.concurrent.Runnable, securityContext : org.springframework.security.core.context.SecurityContext, securityContextHolderStrategy : org.springframework.security.core.context.SecurityContextHolderStrategy) : org.springframework.security.concurrent.Runnable
}
org.springframework.security.concurrent.DelegatingSecurityContextRunnable::DelegatingSecurityContextRunnable -- org.springframework.security.core.context.SecurityContextHolder::getContext : SecurityContextHolder.getContext() 
org.springframework.security.concurrent.DelegatingSecurityContextRunnable::DelegatingSecurityContextRunnable -- org.springframework.util.Assert::notNull : Assert.notNull(delegate,"delegate cannot be null") 
org.springframework.security.concurrent.DelegatingSecurityContextRunnable::DelegatingSecurityContextRunnable -- org.springframework.util.Assert::notNull : Assert.notNull(securityContext,"securityContext cannot be null") 
org.springframework.security.concurrent.DelegatingSecurityContextRunnable::run -- org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : this.securityContextHolderStrategy.getContext() 
org.springframework.security.concurrent.DelegatingSecurityContextRunnable::run -- org.springframework.security.core.context.SecurityContextHolderStrategy::setContext : this.securityContextHolderStrategy.setContext(this.delegateSecurityContext) 
org.springframework.security.concurrent.DelegatingSecurityContextRunnable::run -- org.springframework.security.concurrent.Runnable::run : this.delegate.run() 
org.springframework.security.concurrent.DelegatingSecurityContextRunnable::run -- org.springframework.security.core.context.SecurityContextHolderStrategy::createEmptyContext : this.securityContextHolderStrategy.createEmptyContext() 
org.springframework.security.concurrent.DelegatingSecurityContextRunnable::run -- org.springframework.security.core.context.SecurityContextHolderStrategy::clearContext : this.securityContextHolderStrategy.clearContext() 
org.springframework.security.concurrent.DelegatingSecurityContextRunnable::run -- org.springframework.security.core.context.SecurityContextHolderStrategy::setContext : this.securityContextHolderStrategy.setContext(this.originalSecurityContext) 
org.springframework.security.concurrent.DelegatingSecurityContextRunnable::setSecurityContextHolderStrategy -- org.springframework.util.Assert::notNull : Assert.notNull(securityContextHolderStrategy,"securityContextHolderStrategy cannot be null") 
org.springframework.security.concurrent.DelegatingSecurityContextRunnable::setSecurityContextHolderStrategy -- org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : this.securityContextHolderStrategy.getContext() 
org.springframework.security.concurrent.DelegatingSecurityContextRunnable::toString -- org.springframework.security.concurrent.Runnable::toString : this.delegate.toString() 
org.springframework.security.concurrent.DelegatingSecurityContextRunnable::create -- org.springframework.util.Assert::notNull : Assert.notNull(delegate,"delegate cannot be  null") 
org.springframework.security.concurrent.DelegatingSecurityContextRunnable::create -- org.springframework.util.Assert::notNull : Assert.notNull(delegate,"delegate cannot be  null") 
org.springframework.security.concurrent.DelegatingSecurityContextRunnable::create -- org.springframework.util.Assert::notNull : Assert.notNull(securityContextHolderStrategy,"securityContextHolderStrategy cannot be null") 
class DelegatingSecurityContextScheduledExecutorService extends org.springframework.security.concurrent.DelegatingSecurityContextExecutorService implements java.util.concurrent.ScheduledExecutorService  {
  DelegatingSecurityContextScheduledExecutorService(delegateScheduledExecutorService : java.util.concurrent.ScheduledExecutorService, securityContext : org.springframework.security.core.context.SecurityContext) : None
  DelegatingSecurityContextScheduledExecutorService(delegate : java.util.concurrent.ScheduledExecutorService) : None
  schedule(command : org.springframework.security.concurrent.Runnable, delay : long, unit : java.util.concurrent.TimeUnit) : java.util.concurrent.ScheduledFuture
  schedule(callable : java.util.concurrent.Callable, delay : long, unit : java.util.concurrent.TimeUnit) : java.util.concurrent.ScheduledFuture
  scheduleAtFixedRate(command : org.springframework.security.concurrent.Runnable, initialDelay : long, period : long, unit : java.util.concurrent.TimeUnit) : java.util.concurrent.ScheduledFuture
  scheduleWithFixedDelay(command : org.springframework.security.concurrent.Runnable, initialDelay : long, delay : long, unit : java.util.concurrent.TimeUnit) : java.util.concurrent.ScheduledFuture
  getDelegate() : java.util.concurrent.ScheduledExecutorService
}
org.springframework.security.concurrent.DelegatingSecurityContextScheduledExecutorService::schedule -- org.springframework.security.concurrent.DelegatingSecurityContextScheduledExecutorService::getDelegate : getDelegate().schedule(wrap(command),delay,unit) 
org.springframework.security.concurrent.DelegatingSecurityContextScheduledExecutorService::schedule -- org.springframework.security.concurrent.DelegatingSecurityContextScheduledExecutorService::getDelegate : getDelegate().schedule(wrap(callable),delay,unit) 
org.springframework.security.concurrent.DelegatingSecurityContextScheduledExecutorService::scheduleAtFixedRate -- org.springframework.security.concurrent.DelegatingSecurityContextScheduledExecutorService::getDelegate : getDelegate().scheduleAtFixedRate(wrap(command),initialDelay,period,unit) 
org.springframework.security.concurrent.DelegatingSecurityContextScheduledExecutorService::scheduleWithFixedDelay -- org.springframework.security.concurrent.DelegatingSecurityContextScheduledExecutorService::getDelegate : getDelegate().scheduleWithFixedDelay(wrap(command),initialDelay,delay,unit) 
}
package context {
class DelegatingApplicationListener  implements org.springframework.context.ApplicationListener  {
  listeners : java.util.List
  onApplicationEvent(event : org.springframework.context.ApplicationEvent) : void
  addListener(smartApplicationListener : org.springframework.context.event.SmartApplicationListener) : void
}
org.springframework.security.context.DelegatingApplicationListener::onApplicationEvent -- org.springframework.context.ApplicationEvent::getSource : event.getSource() 
org.springframework.security.context.DelegatingApplicationListener::onApplicationEvent -- org.springframework.context.ApplicationEvent::getClass : event.getClass() 
org.springframework.security.context.DelegatingApplicationListener::addListener -- org.springframework.util.Assert::notNull : Assert.notNull(smartApplicationListener,"smartApplicationListener cannot be null") 
org.springframework.security.context.DelegatingApplicationListener::addListener -- java.util.List::add : this.listeners.add(smartApplicationListener) 
}
package converter {
class RsaKeyConverters    {
  DASHES : java.lang.String
  PKCS8_PEM_HEADER : java.lang.String
  PKCS8_PEM_FOOTER : java.lang.String
  X509_PEM_HEADER : java.lang.String
  X509_PEM_FOOTER : java.lang.String
  X509_CERT_HEADER : java.lang.String
  X509_CERT_FOOTER : java.lang.String
  RsaKeyConverters() : None
  pkcs8() : org.springframework.core.convert.converter.Converter
  x509() : org.springframework.core.convert.converter.Converter
  x509CertificateFactory() : java.security.cert.CertificateFactory
  readAllLines(source : java.io.InputStream) : java.util.List
  rsaFactory() : java.security.KeyFactory
  isNotPkcs8Wrapper(line : java.lang.String) : boolean
}
org.springframework.security.converter.RsaKeyConverters::pkcs8 -- org.springframework.util.Assert::isTrue : Assert.isTrue(!lines.isEmpty()&&lines.get(0).startsWith(PKCS8_PEM_HEADER),"Key is not in PEM-encoded PKCS#8 format, please check that the header begins with "+PKCS8_PEM_HEADER) 
org.springframework.security.converter.RsaKeyConverters::pkcs8 -- org.springframework.security.converter.RsaKeyConverters::isNotPkcs8Wrapper : RsaKeyConverters.isNotPkcs8Wrapper(line) 
org.springframework.security.converter.RsaKeyConverters::pkcs8 -- java.util.Base64::getDecoder : Base64.getDecoder().decode(base64Encoded.toString()) 
org.springframework.security.converter.RsaKeyConverters::pkcs8 -- java.util.Base64::getDecoder : Base64.getDecoder() 
org.springframework.security.converter.RsaKeyConverters::x509 -- org.springframework.util.Assert::notEmpty : Assert.notEmpty(lines,"Input stream is empty") 
org.springframework.security.converter.RsaKeyConverters::x509 -- org.springframework.util.Assert::notNull : Assert.notNull(decoder,"Key is not in PEM-encoded X.509 format or a valid X.509 certificate, please check that the header begins with "+X509_PEM_HEADER+" or "+X509_CERT_HEADER) 
org.springframework.security.converter.RsaKeyConverters::x509CertificateFactory -- java.security.cert.CertificateFactory::getInstance : CertificateFactory.getInstance("X.509") 
org.springframework.security.converter.RsaKeyConverters::readAllLines -- java.util.stream.Collectors::toList : Collectors.toList() 
org.springframework.security.converter.RsaKeyConverters::rsaFactory -- java.security.KeyFactory::getInstance : KeyFactory.getInstance("RSA") 
org.springframework.security.converter.RsaKeyConverters::isNotPkcs8Wrapper -- org.springframework.security.converter.PKCS8_PEM_HEADER::equals : PKCS8_PEM_HEADER.equals(line) 
org.springframework.security.converter.RsaKeyConverters::isNotPkcs8Wrapper -- org.springframework.security.converter.PKCS8_PEM_FOOTER::equals : PKCS8_PEM_FOOTER.equals(line) 
class X509PemDecoder  implements org.springframework.security.converter.Converter  {
  keyFactory : org.springframework.security.converter.KeyFactory
  X509PemDecoder(keyFactory : org.springframework.security.converter.KeyFactory) : None
  convert(lines : org.springframework.security.converter.List) : org.springframework.security.converter.RSAPublicKey
  isNotX509PemWrapper(line : java.lang.String) : boolean
}
org.springframework.security.converter.X509PemDecoder::convert -- org.springframework.security.converter.Base64::getDecoder : Base64.getDecoder().decode(base64Encoded.toString()) 
org.springframework.security.converter.X509PemDecoder::convert -- org.springframework.security.converter.Base64::getDecoder : Base64.getDecoder() 
org.springframework.security.converter.X509PemDecoder::convert -- org.springframework.security.converter.KeyFactory::generatePublic : this.keyFactory.generatePublic(newX509EncodedKeySpec(x509)) 
org.springframework.security.converter.X509PemDecoder::isNotX509PemWrapper -- org.springframework.security.converter.X509_PEM_HEADER::equals : X509_PEM_HEADER.equals(line) 
org.springframework.security.converter.X509PemDecoder::isNotX509PemWrapper -- org.springframework.security.converter.X509_PEM_FOOTER::equals : X509_PEM_FOOTER.equals(line) 
class X509CertificateDecoder  implements org.springframework.security.converter.Converter  {
  certificateFactory : org.springframework.security.converter.CertificateFactory
  X509CertificateDecoder(certificateFactory : org.springframework.security.converter.CertificateFactory) : None
  convert(lines : org.springframework.security.converter.List) : org.springframework.security.converter.RSAPublicKey
  isNotX509CertificateWrapper(line : java.lang.String) : boolean
}
org.springframework.security.converter.X509CertificateDecoder::convert -- org.springframework.security.converter.Base64::getDecoder : Base64.getDecoder().decode(base64Encoded.toString()) 
org.springframework.security.converter.X509CertificateDecoder::convert -- org.springframework.security.converter.Base64::getDecoder : Base64.getDecoder() 
org.springframework.security.converter.X509CertificateDecoder::convert -- org.springframework.security.converter.CertificateFactory::generateCertificate : this.certificateFactory.generateCertificate(x509CertStream) 
org.springframework.security.converter.X509CertificateDecoder::isNotX509CertificateWrapper -- org.springframework.security.converter.X509_CERT_HEADER::equals : X509_CERT_HEADER.equals(line) 
org.springframework.security.converter.X509CertificateDecoder::isNotX509CertificateWrapper -- org.springframework.security.converter.X509_CERT_FOOTER::equals : X509_CERT_FOOTER.equals(line) 
}
package core {
package annotation {
class AbstractSecurityAnnotationScanner  implements org.springframework.security.core.annotation.SecurityAnnotationScanner  {
  scan(method : java.lang.reflect.Method, targetClass : java.lang.Class) : org.springframework.security.core.annotation.A
  scan(parameter : java.lang.reflect.Parameter) : org.springframework.security.core.annotation.A
  merge(element : java.lang.reflect.AnnotatedElement, targetClass : java.lang.Class) : org.springframework.core.annotation.MergedAnnotation
}
org.springframework.security.core.annotation.AbstractSecurityAnnotationScanner::scan -- org.springframework.util.Assert::notNull : Assert.notNull(targetClass,"targetClass cannot be null") 
class AnnotationTemplateExpressionDefaults    {
  ignoreUnknown : boolean
  isIgnoreUnknown() : boolean
  setIgnoreUnknown(ignoreUnknown : boolean) : void
}
class ExpressionTemplateSecurityAnnotationScanner extends org.springframework.security.core.annotation.AbstractSecurityAnnotationScanner   {
  conversionService : org.springframework.core.convert.support.DefaultConversionService
  type : java.lang.Class
  unique : org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner
  templateDefaults : org.springframework.security.core.annotation.AnnotationTemplateExpressionDefaults
  ExpressionTemplateSecurityAnnotationScanner(type : java.lang.Class, templateDefaults : org.springframework.security.core.annotation.AnnotationTemplateExpressionDefaults) : None
  merge(element : java.lang.reflect.AnnotatedElement, targetClass : java.lang.Class) : org.springframework.core.annotation.MergedAnnotation
  resolvePlaceholders(mergedAnnotation : org.springframework.core.annotation.MergedAnnotation) : org.springframework.core.annotation.MergedAnnotation
}
org.springframework.security.core.annotation.ExpressionTemplateSecurityAnnotationScanner::ExpressionTemplateSecurityAnnotationScanner -- org.springframework.util.Assert::notNull : Assert.notNull(type,"type cannot be null") 
org.springframework.security.core.annotation.ExpressionTemplateSecurityAnnotationScanner::ExpressionTemplateSecurityAnnotationScanner -- org.springframework.util.Assert::notNull : Assert.notNull(templateDefaults,"templateDefaults cannot be null") 
org.springframework.security.core.annotation.ExpressionTemplateSecurityAnnotationScanner::merge -- org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::merge : this.unique.merge(parameter,targetClass) 
org.springframework.security.core.annotation.ExpressionTemplateSecurityAnnotationScanner::merge -- org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::merge : this.unique.merge(method,targetClass) 
org.springframework.security.core.annotation.ExpressionTemplateSecurityAnnotationScanner::merge -- java.lang.reflect.AnnotatedElement::getClass : element.getClass() 
org.springframework.security.core.annotation.ExpressionTemplateSecurityAnnotationScanner::resolvePlaceholders -- org.springframework.core.annotation.MergedAnnotation::getMetaSource : mergedAnnotation.getMetaSource() 
org.springframework.security.core.annotation.ExpressionTemplateSecurityAnnotationScanner::resolvePlaceholders -- org.springframework.security.core.annotation.AnnotationTemplateExpressionDefaults::isIgnoreUnknown : this.templateDefaults.isIgnoreUnknown() 
org.springframework.security.core.annotation.ExpressionTemplateSecurityAnnotationScanner::resolvePlaceholders -- org.springframework.core.annotation.MergedAnnotation::asMap : mergedAnnotation.asMap() 
org.springframework.security.core.annotation.ExpressionTemplateSecurityAnnotationScanner::resolvePlaceholders -- org.springframework.core.annotation.MergedAnnotation::getMetaSource : mergedAnnotation.getMetaSource().asMap() 
org.springframework.security.core.annotation.ExpressionTemplateSecurityAnnotationScanner::resolvePlaceholders -- org.springframework.core.annotation.MergedAnnotation::getMetaSource : mergedAnnotation.getMetaSource() 
org.springframework.security.core.annotation.ExpressionTemplateSecurityAnnotationScanner::resolvePlaceholders -- org.springframework.core.convert.support.DefaultConversionService::convert : conversionService.convert(value,String.class) 
org.springframework.security.core.annotation.ExpressionTemplateSecurityAnnotationScanner::resolvePlaceholders -- org.springframework.core.annotation.MergedAnnotation::asMap : mergedAnnotation.asMap() 
org.springframework.security.core.annotation.ExpressionTemplateSecurityAnnotationScanner::resolvePlaceholders -- org.springframework.core.annotation.MergedAnnotation::getSource : mergedAnnotation.getSource() 
org.springframework.security.core.annotation.ExpressionTemplateSecurityAnnotationScanner::resolvePlaceholders -- org.springframework.core.annotation.MergedAnnotation::of : MergedAnnotation.of(annotatedElement,this.type,properties) 
class ClassToStringConverter  implements org.springframework.security.core.annotation.GenericConverter  {
  getConvertibleTypes() : org.springframework.security.core.annotation.Set
  convert(source : java.lang.Object, sourceType : org.springframework.security.core.annotation.TypeDescriptor, targetType : org.springframework.security.core.annotation.TypeDescriptor) : java.lang.Object
}
org.springframework.security.core.annotation.ClassToStringConverter::getConvertibleTypes -- org.springframework.security.core.annotation.Collections::singleton : Collections.singleton(newConvertiblePair(Class.class,String.class)) 
org.springframework.security.core.annotation.ClassToStringConverter::convert -- java.lang.Object::toString : source.toString() 
interface SecurityAnnotationScanner    {
  scan(method : java.lang.reflect.Method, targetClass : java.lang.Class) : org.springframework.security.core.annotation.A
  scan(parameter : java.lang.reflect.Parameter) : org.springframework.security.core.annotation.A
}
class SecurityAnnotationScanners    {
  uniqueScanners : java.util.Map
  uniqueTemplateScanners : java.util.Map
  uniqueTypesScanners : java.util.Map
  SecurityAnnotationScanners() : None
  requireUnique(type : java.lang.Class) : org.springframework.security.core.annotation.SecurityAnnotationScanner
  requireUnique(type : java.lang.Class, templateDefaults : org.springframework.security.core.annotation.AnnotationTemplateExpressionDefaults) : org.springframework.security.core.annotation.SecurityAnnotationScanner
  requireUnique(types : java.util.List) : org.springframework.security.core.annotation.SecurityAnnotationScanner
}
org.springframework.security.core.annotation.SecurityAnnotationScanners::requireUnique -- java.util.Map::computeIfAbsent : uniqueScanners.computeIfAbsent(type,(t)->newUniqueSecurityAnnotationScanner<>(type)) 
org.springframework.security.core.annotation.SecurityAnnotationScanners::requireUnique -- java.util.Map::computeIfAbsent : uniqueTemplateScanners.computeIfAbsent(type,(t)->newExpressionTemplateSecurityAnnotationScanner<>(t,templateDefaults)) 
org.springframework.security.core.annotation.SecurityAnnotationScanners::requireUnique -- java.util.List::forEach : types.forEach((type)->casted.add((Class<Annotation>)type)) 
org.springframework.security.core.annotation.SecurityAnnotationScanners::requireUnique -- java.util.Map::computeIfAbsent : uniqueTypesScanners.computeIfAbsent(types,(t)->newUniqueSecurityAnnotationScanner<>(casted)) 
class UniqueSecurityAnnotationScanner extends org.springframework.security.core.annotation.AbstractSecurityAnnotationScanner   {
  types : java.util.List
  uniqueParameterAnnotationCache : java.util.Map
  uniqueMethodAnnotationCache : java.util.Map
  UniqueSecurityAnnotationScanner(type : java.lang.Class) : None
  UniqueSecurityAnnotationScanner(types : java.util.List) : None
  merge(element : java.lang.reflect.AnnotatedElement, targetClass : java.lang.Class) : org.springframework.core.annotation.MergedAnnotation
  requireUnique(element : java.lang.reflect.AnnotatedElement, annotations : java.util.List) : org.springframework.core.annotation.MergedAnnotation
  findParameterAnnotations(current : java.lang.reflect.Parameter) : java.util.List
  findClosestParameterAnnotations(method : java.lang.reflect.Method, clazz : java.lang.Class, current : java.lang.reflect.Parameter, visited : java.util.Set) : java.util.List
  findDirectParameterAnnotations(method : java.lang.reflect.Method, clazz : java.lang.Class, current : java.lang.reflect.Parameter) : java.util.List
  findMethodAnnotations(method : java.lang.reflect.Method, targetClass : java.lang.Class) : java.util.List
  findClosestMethodAnnotations(method : java.lang.reflect.Method, targetClass : java.lang.Class, classesToSkip : java.util.Set) : java.util.List
  findClosestClassAnnotations(targetClass : java.lang.Class, classesToSkip : java.util.Set) : java.util.List
  findDirectAnnotations(element : java.lang.reflect.AnnotatedElement) : java.util.List
}
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::UniqueSecurityAnnotationScanner -- org.springframework.util.Assert::notNull : Assert.notNull(type,"type cannot be null") 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::UniqueSecurityAnnotationScanner -- java.util.List::of : List.of(type) 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::UniqueSecurityAnnotationScanner -- org.springframework.util.Assert::notNull : Assert.notNull(types,"types cannot be null") 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::merge -- java.util.Map::computeIfAbsent : this.uniqueParameterAnnotationCache.computeIfAbsent(parameter,(p)->{List<MergedAnnotation<A>>annotations=findParameterAnnotations(p);returnrequireUnique(p,annotations);}) 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::merge -- java.util.Map::computeIfAbsent : this.uniqueMethodAnnotationCache.computeIfAbsent(newMethodClassKey(method,targetClass),(k)->{List<MergedAnnotation<A>>annotations=findMethodAnnotations(method,targetClass);returnrequireUnique(method,annotations);}) 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::merge -- java.lang.reflect.AnnotatedElement::getClass : element.getClass() 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::requireUnique -- java.util.List::size : annotations.size() 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::requireUnique -- java.util.List::get : annotations.get(0) 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::requireUnique -- java.util.List::size : annotations.size() 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findParameterAnnotations -- java.lang.reflect.Parameter::getDeclaringExecutable : current.getDeclaringExecutable() 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findParameterAnnotations -- java.util.Collections::emptyList : Collections.emptyList() 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findClosestParameterAnnotations -- java.util.Set::add : visited.add(clazz) 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findClosestParameterAnnotations -- java.util.Collections::emptyList : Collections.emptyList() 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findClosestParameterAnnotations -- java.lang.Class::getInterfaces : clazz.getInterfaces() 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findDirectParameterAnnotations -- java.lang.Class::getDeclaredMethod : clazz.getDeclaredMethod(method.getName(),method.getParameterTypes()) 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findDirectParameterAnnotations -- java.lang.reflect.Method::getName : method.getName() 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findDirectParameterAnnotations -- java.lang.reflect.Method::getParameterTypes : method.getParameterTypes() 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findDirectParameterAnnotations -- java.lang.reflect.Parameter::getName : current.getName() 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findDirectParameterAnnotations -- java.util.Collections::emptyList : Collections.emptyList() 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findMethodAnnotations -- org.springframework.util.ClassUtils::getMostSpecificMethod : ClassUtils.getMostSpecificMethod(method,targetClass) 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findMethodAnnotations -- java.lang.reflect.Method::getDeclaringClass : method.getDeclaringClass() 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findMethodAnnotations -- java.util.Collections::emptyList : Collections.emptyList() 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findClosestMethodAnnotations -- java.util.Set::contains : classesToSkip.contains(targetClass) 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findClosestMethodAnnotations -- java.util.Collections::emptyList : Collections.emptyList() 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findClosestMethodAnnotations -- java.util.Set::add : classesToSkip.add(targetClass) 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findClosestMethodAnnotations -- java.lang.Class::getDeclaredMethod : targetClass.getDeclaredMethod(method.getName(),method.getParameterTypes()) 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findClosestMethodAnnotations -- java.lang.reflect.Method::getName : method.getName() 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findClosestMethodAnnotations -- java.lang.reflect.Method::getParameterTypes : method.getParameterTypes() 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findClosestMethodAnnotations -- java.lang.Class::getSuperclass : targetClass.getSuperclass() 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findClosestMethodAnnotations -- java.lang.Class::getInterfaces : targetClass.getInterfaces() 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findClosestClassAnnotations -- java.util.Set::contains : classesToSkip.contains(targetClass) 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findClosestClassAnnotations -- java.util.Collections::emptyList : Collections.emptyList() 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findClosestClassAnnotations -- java.util.Set::add : classesToSkip.add(targetClass) 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findClosestClassAnnotations -- java.lang.Class::getSuperclass : targetClass.getSuperclass() 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findClosestClassAnnotations -- java.lang.Class::getInterfaces : targetClass.getInterfaces() 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findDirectAnnotations -- org.springframework.core.annotation.MergedAnnotations::from : MergedAnnotations.from(element,MergedAnnotations.SearchStrategy.DIRECT,RepeatableContainers.none()) 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findDirectAnnotations -- org.springframework.core.annotation.RepeatableContainers::none : RepeatableContainers.none() 
org.springframework.security.core.annotation.UniqueSecurityAnnotationScanner::findDirectAnnotations -- java.util.List::contains : this.types.contains(annotation.getType()) 
}
package authority {
package mapping {
interface Attributes2GrantedAuthoritiesMapper    {
  getGrantedAuthorities(attributes : java.util.Collection) : java.util.Collection
}
interface GrantedAuthoritiesMapper    {
  mapAuthorities(authorities : java.util.Collection) : java.util.Collection
}
class MapBasedAttributes2GrantedAuthoritiesMapper  implements org.springframework.security.core.authority.mapping.Attributes2GrantedAuthoritiesMapper,MappableAttributesRetriever,InitializingBean  {
  attributes2grantedAuthoritiesMap : java.util.Map
  stringSeparator : java.lang.String
  mappableAttributes : java.util.Set
  afterPropertiesSet() : void
  getGrantedAuthorities(attributes : java.util.Collection) : java.util.List
  getAttributes2grantedAuthoritiesMap() : java.util.Map
  setAttributes2grantedAuthoritiesMap(attributes2grantedAuthoritiesMap : java.util.Map) : void
  preProcessMap(orgMap : java.util.Map) : java.util.Map
  getGrantedAuthorityCollection(value : java.lang.Object) : java.util.Collection
  addGrantedAuthorityCollection(result : java.util.Collection, value : java.lang.Object) : void
  addGrantedAuthorityCollection(result : java.util.Collection, value : java.util.Collection) : void
  addGrantedAuthorityCollection(result : java.util.Collection, value : org.springframework.security.core.authority.mapping.Object[]) : void
  addGrantedAuthorityCollection(result : java.util.Collection, value : java.lang.String) : void
  getMappableAttributes() : java.util.Set
  getStringSeparator() : java.lang.String
  setStringSeparator(stringSeparator : java.lang.String) : void
}
org.springframework.security.core.authority.mapping.MapBasedAttributes2GrantedAuthoritiesMapper::afterPropertiesSet -- org.springframework.util.Assert::notNull : Assert.notNull(this.attributes2grantedAuthoritiesMap,"attributes2grantedAuthoritiesMap must be set") 
org.springframework.security.core.authority.mapping.MapBasedAttributes2GrantedAuthoritiesMapper::getGrantedAuthorities -- java.util.Map::get : this.attributes2grantedAuthoritiesMap.get(attribute) 
org.springframework.security.core.authority.mapping.MapBasedAttributes2GrantedAuthoritiesMapper::setAttributes2grantedAuthoritiesMap -- org.springframework.util.Assert::notEmpty : Assert.notEmpty(attributes2grantedAuthoritiesMap,"A non-empty attributes2grantedAuthoritiesMap must be supplied") 
org.springframework.security.core.authority.mapping.MapBasedAttributes2GrantedAuthoritiesMapper::setAttributes2grantedAuthoritiesMap -- java.util.Collections::unmodifiableSet : Collections.unmodifiableSet(this.attributes2grantedAuthoritiesMap.keySet()) 
org.springframework.security.core.authority.mapping.MapBasedAttributes2GrantedAuthoritiesMapper::setAttributes2grantedAuthoritiesMap -- java.util.Map::keySet : this.attributes2grantedAuthoritiesMap.keySet() 
org.springframework.security.core.authority.mapping.MapBasedAttributes2GrantedAuthoritiesMapper::preProcessMap -- java.util.Map::size : orgMap.size() 
org.springframework.security.core.authority.mapping.MapBasedAttributes2GrantedAuthoritiesMapper::preProcessMap -- java.util.Map::entrySet : orgMap.entrySet() 
org.springframework.security.core.authority.mapping.MapBasedAttributes2GrantedAuthoritiesMapper::preProcessMap -- org.springframework.util.Assert::isInstanceOf : Assert.isInstanceOf(String.class,entry.getKey(),"attributes2grantedAuthoritiesMap contains non-String objects as keys") 
org.springframework.security.core.authority.mapping.MapBasedAttributes2GrantedAuthoritiesMapper::addGrantedAuthorityCollection -- java.util.Collection::add : result.add((GrantedAuthority)value) 
org.springframework.security.core.authority.mapping.MapBasedAttributes2GrantedAuthoritiesMapper::addGrantedAuthorityCollection -- java.lang.Object::getClass : value.getClass().getName() 
org.springframework.security.core.authority.mapping.MapBasedAttributes2GrantedAuthoritiesMapper::addGrantedAuthorityCollection -- java.lang.Object::getClass : value.getClass() 
org.springframework.security.core.authority.mapping.MapBasedAttributes2GrantedAuthoritiesMapper::addGrantedAuthorityCollection -- org.springframework.util.StringUtils::hasText : StringUtils.hasText(token) 
org.springframework.security.core.authority.mapping.MapBasedAttributes2GrantedAuthoritiesMapper::addGrantedAuthorityCollection -- java.util.Collection::add : result.add(newSimpleGrantedAuthority(token)) 
interface MappableAttributesRetriever    {
  getMappableAttributes() : java.util.Set
}
class NullAuthoritiesMapper  implements org.springframework.security.core.authority.mapping.GrantedAuthoritiesMapper  {
  mapAuthorities(authorities : java.util.Collection) : java.util.Collection
}
class SimpleAttributes2GrantedAuthoritiesMapper  implements org.springframework.security.core.authority.mapping.Attributes2GrantedAuthoritiesMapper,InitializingBean  {
  attributePrefix : java.lang.String
  convertAttributeToUpperCase : boolean
  convertAttributeToLowerCase : boolean
  addPrefixIfAlreadyExisting : boolean
  afterPropertiesSet() : void
  getGrantedAuthorities(attributes : java.util.Collection) : java.util.List
  getGrantedAuthority(attribute : java.lang.String) : org.springframework.security.core.GrantedAuthority
  isConvertAttributeToLowerCase() : boolean
  setConvertAttributeToLowerCase(b : boolean) : void
  isConvertAttributeToUpperCase() : boolean
  setConvertAttributeToUpperCase(b : boolean) : void
  getAttributePrefix() : java.lang.String
  setAttributePrefix(string : java.lang.String) : void
  isAddPrefixIfAlreadyExisting() : boolean
  setAddPrefixIfAlreadyExisting(b : boolean) : void
}
org.springframework.security.core.authority.mapping.SimpleAttributes2GrantedAuthoritiesMapper::afterPropertiesSet -- org.springframework.util.Assert::isTrue : Assert.isTrue(!(isConvertAttributeToUpperCase()&&isConvertAttributeToLowerCase()),"Either convertAttributeToUpperCase or convertAttributeToLowerCase can be set to true, but not both") 
org.springframework.security.core.authority.mapping.SimpleAttributes2GrantedAuthoritiesMapper::getGrantedAuthorities -- java.util.Collection::size : attributes.size() 
org.springframework.security.core.authority.mapping.SimpleAttributes2GrantedAuthoritiesMapper::getGrantedAuthority -- java.lang.String::toLowerCase : attribute.toLowerCase(Locale.ROOT) 
org.springframework.security.core.authority.mapping.SimpleAttributes2GrantedAuthoritiesMapper::getGrantedAuthority -- java.lang.String::toUpperCase : attribute.toUpperCase(Locale.ROOT) 
org.springframework.security.core.authority.mapping.SimpleAttributes2GrantedAuthoritiesMapper::getGrantedAuthority -- java.lang.String::startsWith : attribute.startsWith(getAttributePrefix()) 
class SimpleAuthorityMapper  implements org.springframework.security.core.authority.mapping.GrantedAuthoritiesMapper,InitializingBean  {
  defaultAuthority : org.springframework.security.core.GrantedAuthority
  prefix : java.lang.String
  convertToUpperCase : boolean
  convertToLowerCase : boolean
  afterPropertiesSet() : void
  mapAuthorities(authorities : java.util.Collection) : java.util.Set
  mapAuthority(name : java.lang.String) : org.springframework.security.core.GrantedAuthority
  setPrefix(prefix : java.lang.String) : void
  setConvertToUpperCase(convertToUpperCase : boolean) : void
  setConvertToLowerCase(convertToLowerCase : boolean) : void
  setDefaultAuthority(authority : java.lang.String) : void
}
org.springframework.security.core.authority.mapping.SimpleAuthorityMapper::afterPropertiesSet -- org.springframework.util.Assert::isTrue : Assert.isTrue(!(this.convertToUpperCase&&this.convertToLowerCase),"Either convertToUpperCase or convertToLowerCase can be set to true, but not both") 
org.springframework.security.core.authority.mapping.SimpleAuthorityMapper::mapAuthorities -- java.util.Collection::size : authorities.size() 
org.springframework.security.core.authority.mapping.SimpleAuthorityMapper::mapAuthority -- java.lang.String::toUpperCase : name.toUpperCase(Locale.ROOT) 
org.springframework.security.core.authority.mapping.SimpleAuthorityMapper::mapAuthority -- java.lang.String::toLowerCase : name.toLowerCase(Locale.ROOT) 
org.springframework.security.core.authority.mapping.SimpleAuthorityMapper::mapAuthority -- java.lang.String::length : this.prefix.length() 
org.springframework.security.core.authority.mapping.SimpleAuthorityMapper::mapAuthority -- java.lang.String::startsWith : name.startsWith(this.prefix) 
org.springframework.security.core.authority.mapping.SimpleAuthorityMapper::setPrefix -- org.springframework.util.Assert::notNull : Assert.notNull(prefix,"prefix cannot be null") 
org.springframework.security.core.authority.mapping.SimpleAuthorityMapper::setDefaultAuthority -- org.springframework.util.Assert::hasText : Assert.hasText(authority,"The authority name cannot be set to an empty value") 
class SimpleMappableAttributesRetriever  implements org.springframework.security.core.authority.mapping.MappableAttributesRetriever  {
  mappableAttributes : java.util.Set
  getMappableAttributes() : java.util.Set
  setMappableAttributes(aMappableRoles : java.util.Set) : void
}
org.springframework.security.core.authority.mapping.SimpleMappableAttributesRetriever::setMappableAttributes -- java.util.Set::addAll : this.mappableAttributes.addAll(aMappableRoles) 
org.springframework.security.core.authority.mapping.SimpleMappableAttributesRetriever::setMappableAttributes -- java.util.Collections::unmodifiableSet : Collections.unmodifiableSet(this.mappableAttributes) 
}
class AuthorityUtils    {
  NO_AUTHORITIES : java.util.List
  AuthorityUtils() : None
  commaSeparatedStringToAuthorityList(authorityString : java.lang.String) : java.util.List
  authorityListToSet(userAuthorities : java.util.Collection) : java.util.Set
  createAuthorityList() : java.util.List
  createAuthorityList(authorities : java.util.Collection) : java.util.List
}
org.springframework.security.core.authority.AuthorityUtils::commaSeparatedStringToAuthorityList -- org.springframework.util.StringUtils::tokenizeToStringArray : StringUtils.tokenizeToStringArray(authorityString,",") 
org.springframework.security.core.authority.AuthorityUtils::authorityListToSet -- org.springframework.util.Assert::notNull : Assert.notNull(userAuthorities,"userAuthorities cannot be null") 
org.springframework.security.core.authority.AuthorityUtils::authorityListToSet -- java.util.Collection::size : userAuthorities.size() 
org.springframework.security.core.authority.AuthorityUtils::createAuthorityList -- java.util.Collection::size : authorities.size() 
interface GrantedAuthoritiesContainer    {
  getGrantedAuthorities() : java.util.Collection
}
class SimpleGrantedAuthority  implements org.springframework.security.core.GrantedAuthority  {
  serialVersionUID : long
  role : java.lang.String
  SimpleGrantedAuthority(role : java.lang.String) : None
  getAuthority() : java.lang.String
  equals(obj : java.lang.Object) : boolean
  hashCode() : int
  toString() : java.lang.String
}
org.springframework.security.core.authority.SimpleGrantedAuthority::SimpleGrantedAuthority -- org.springframework.util.Assert::hasText : Assert.hasText(role,"A granted authority textual representation is required") 
org.springframework.security.core.authority.SimpleGrantedAuthority::equals -- java.lang.String::equals : this.role.equals(sga.getAuthority()) 
org.springframework.security.core.authority.SimpleGrantedAuthority::hashCode -- java.lang.String::hashCode : this.role.hashCode() 
}
package context {
interface DeferredSecurityContext    {
  isGenerated() : boolean
}
class GlobalSecurityContextHolderStrategy  implements org.springframework.security.core.context.SecurityContextHolderStrategy  {
  contextHolder : org.springframework.security.core.context.SecurityContext
  clearContext() : void
  getContext() : org.springframework.security.core.context.SecurityContext
  setContext(context : org.springframework.security.core.context.SecurityContext) : void
  createEmptyContext() : org.springframework.security.core.context.SecurityContext
}
org.springframework.security.core.context.GlobalSecurityContextHolderStrategy::setContext -- org.springframework.util.Assert::notNull : Assert.notNull(context,"Only non-null SecurityContext instances are permitted") 
class InheritableThreadLocalSecurityContextHolderStrategy  implements org.springframework.security.core.context.SecurityContextHolderStrategy  {
  contextHolder : org.springframework.security.core.context.ThreadLocal
  clearContext() : void
  getContext() : org.springframework.security.core.context.SecurityContext
  getDeferredContext() : java.util.function.Supplier
  setContext(context : org.springframework.security.core.context.SecurityContext) : void
  setDeferredContext(deferredContext : java.util.function.Supplier) : void
  createEmptyContext() : org.springframework.security.core.context.SecurityContext
}
org.springframework.security.core.context.InheritableThreadLocalSecurityContextHolderStrategy::clearContext -- org.springframework.security.core.context.ThreadLocal::remove : contextHolder.remove() 
org.springframework.security.core.context.InheritableThreadLocalSecurityContextHolderStrategy::getContext -- org.springframework.security.core.context.InheritableThreadLocalSecurityContextHolderStrategy::getDeferredContext : getDeferredContext().get() 
org.springframework.security.core.context.InheritableThreadLocalSecurityContextHolderStrategy::getDeferredContext -- org.springframework.security.core.context.ThreadLocal::get : contextHolder.get() 
org.springframework.security.core.context.InheritableThreadLocalSecurityContextHolderStrategy::getDeferredContext -- org.springframework.security.core.context.ThreadLocal::set : contextHolder.set(result) 
org.springframework.security.core.context.InheritableThreadLocalSecurityContextHolderStrategy::setContext -- org.springframework.util.Assert::notNull : Assert.notNull(context,"Only non-null SecurityContext instances are permitted") 
org.springframework.security.core.context.InheritableThreadLocalSecurityContextHolderStrategy::setContext -- org.springframework.security.core.context.ThreadLocal::set : contextHolder.set(()->context) 
org.springframework.security.core.context.InheritableThreadLocalSecurityContextHolderStrategy::setDeferredContext -- org.springframework.util.Assert::notNull : Assert.notNull(deferredContext,"Only non-null Supplier instances are permitted") 
org.springframework.security.core.context.InheritableThreadLocalSecurityContextHolderStrategy::setDeferredContext -- java.util.function.Supplier::get : deferredContext.get() 
org.springframework.security.core.context.InheritableThreadLocalSecurityContextHolderStrategy::setDeferredContext -- org.springframework.util.Assert::notNull : Assert.notNull(result,"A Supplier<SecurityContext> returned null and is not allowed.") 
org.springframework.security.core.context.InheritableThreadLocalSecurityContextHolderStrategy::setDeferredContext -- org.springframework.security.core.context.ThreadLocal::set : contextHolder.set(notNullDeferredContext) 
class ListeningSecurityContextHolderStrategy  implements org.springframework.security.core.context.SecurityContextHolderStrategy  {
  listeners : java.util.Collection
  delegate : org.springframework.security.core.context.SecurityContextHolderStrategy
  ListeningSecurityContextHolderStrategy(listeners : java.util.Collection) : None
  ListeningSecurityContextHolderStrategy() : None
  ListeningSecurityContextHolderStrategy(delegate : org.springframework.security.core.context.SecurityContextHolderStrategy, listeners : java.util.Collection) : None
  ListeningSecurityContextHolderStrategy(delegate : org.springframework.security.core.context.SecurityContextHolderStrategy) : None
  clearContext() : void
  getContext() : org.springframework.security.core.context.SecurityContext
  getDeferredContext() : java.util.function.Supplier
  setContext(context : org.springframework.security.core.context.SecurityContext) : void
  setDeferredContext(deferredContext : java.util.function.Supplier) : void
  createEmptyContext() : org.springframework.security.core.context.SecurityContext
  publish(event : org.springframework.security.core.context.SecurityContextChangedEvent) : void
}
org.springframework.security.core.context.ListeningSecurityContextHolderStrategy::ListeningSecurityContextHolderStrategy -- org.springframework.util.Assert::notNull : Assert.notNull(delegate,"securityContextHolderStrategy cannot be null") 
org.springframework.security.core.context.ListeningSecurityContextHolderStrategy::ListeningSecurityContextHolderStrategy -- org.springframework.util.Assert::notNull : Assert.notNull(listeners,"securityContextChangedListeners cannot be null") 
org.springframework.security.core.context.ListeningSecurityContextHolderStrategy::ListeningSecurityContextHolderStrategy -- org.springframework.util.Assert::notEmpty : Assert.notEmpty(listeners,"securityContextChangedListeners cannot be empty") 
org.springframework.security.core.context.ListeningSecurityContextHolderStrategy::ListeningSecurityContextHolderStrategy -- org.springframework.util.Assert::noNullElements : Assert.noNullElements(listeners,"securityContextChangedListeners cannot contain null elements") 
org.springframework.security.core.context.ListeningSecurityContextHolderStrategy::ListeningSecurityContextHolderStrategy -- org.springframework.util.Assert::notNull : Assert.notNull(delegate,"securityContextHolderStrategy cannot be null") 
org.springframework.security.core.context.ListeningSecurityContextHolderStrategy::ListeningSecurityContextHolderStrategy -- org.springframework.util.Assert::notNull : Assert.notNull(listeners,"securityContextChangedListeners cannot be null") 
org.springframework.security.core.context.ListeningSecurityContextHolderStrategy::ListeningSecurityContextHolderStrategy -- org.springframework.util.Assert::notEmpty : Assert.notEmpty(listeners,"securityContextChangedListeners cannot be empty") 
org.springframework.security.core.context.ListeningSecurityContextHolderStrategy::ListeningSecurityContextHolderStrategy -- org.springframework.util.Assert::noNullElements : Assert.noNullElements(listeners,"securityContextChangedListeners cannot contain null elements") 
org.springframework.security.core.context.ListeningSecurityContextHolderStrategy::ListeningSecurityContextHolderStrategy -- java.util.Arrays::asList : Arrays.asList(listeners) 
org.springframework.security.core.context.ListeningSecurityContextHolderStrategy::clearContext -- org.springframework.security.core.context.SecurityContextHolderStrategy::getDeferredContext : this.delegate.getDeferredContext() 
org.springframework.security.core.context.ListeningSecurityContextHolderStrategy::clearContext -- org.springframework.security.core.context.SecurityContextHolderStrategy::clearContext : this.delegate.clearContext() 
org.springframework.security.core.context.ListeningSecurityContextHolderStrategy::getContext -- org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : this.delegate.getContext() 
org.springframework.security.core.context.ListeningSecurityContextHolderStrategy::getDeferredContext -- org.springframework.security.core.context.SecurityContextHolderStrategy::getDeferredContext : this.delegate.getDeferredContext() 
org.springframework.security.core.context.ListeningSecurityContextHolderStrategy::setDeferredContext -- org.springframework.security.core.context.SecurityContextHolderStrategy::setDeferredContext : this.delegate.setDeferredContext(newPublishOnceSupplier(getDeferredContext(),deferredContext)) 
org.springframework.security.core.context.ListeningSecurityContextHolderStrategy::createEmptyContext -- org.springframework.security.core.context.SecurityContextHolderStrategy::createEmptyContext : this.delegate.createEmptyContext() 
class PublishOnceSupplier  implements org.springframework.security.core.context.Supplier  {
  isPublished : org.springframework.security.core.context.AtomicBoolean
  old : org.springframework.security.core.context.Supplier
  updated : org.springframework.security.core.context.Supplier
  PublishOnceSupplier(old : org.springframework.security.core.context.Supplier, updated : org.springframework.security.core.context.Supplier) : None
  get() : org.springframework.security.core.context.SecurityContext
}
org.springframework.security.core.context.PublishOnceSupplier::get -- org.springframework.security.core.context.Supplier::get : this.updated.get() 
org.springframework.security.core.context.PublishOnceSupplier::get -- org.springframework.security.core.context.AtomicBoolean::compareAndSet : this.isPublished.compareAndSet(false,true) 
org.springframework.security.core.context.PublishOnceSupplier::get -- org.springframework.security.core.context.Supplier::get : this.old.get() 
class ObservationSecurityContextChangedListener  implements org.springframework.security.core.context.SecurityContextChangedListener  {
  SECURITY_CONTEXT_CREATED : java.lang.String
  SECURITY_CONTEXT_CHANGED : java.lang.String
  SECURITY_CONTEXT_CLEARED : java.lang.String
  registry : io.micrometer.observation.ObservationRegistry
  ObservationSecurityContextChangedListener(registry : io.micrometer.observation.ObservationRegistry) : None
  securityContextChanged(event : org.springframework.security.core.context.SecurityContextChangedEvent) : void
  getAuthentication(context : org.springframework.security.core.context.SecurityContext) : org.springframework.security.core.Authentication
}
org.springframework.security.core.context.ObservationSecurityContextChangedListener::securityContextChanged -- io.micrometer.observation.ObservationRegistry::getCurrentObservation : this.registry.getCurrentObservation() 
org.springframework.security.core.context.ObservationSecurityContextChangedListener::securityContextChanged -- org.springframework.security.core.context.SecurityContextChangedEvent::isCleared : event.isCleared() 
org.springframework.security.core.context.ObservationSecurityContextChangedListener::securityContextChanged -- org.springframework.security.core.context.SecurityContextChangedEvent::getOldContext : event.getOldContext() 
org.springframework.security.core.context.ObservationSecurityContextChangedListener::securityContextChanged -- org.springframework.security.core.context.SecurityContextChangedEvent::getNewContext : event.getNewContext() 
org.springframework.security.core.context.ObservationSecurityContextChangedListener::getAuthentication -- org.springframework.security.core.context.SecurityContext::getAuthentication : context.getAuthentication() 
class ReactiveSecurityContextHolder    {
  SECURITY_CONTEXT_KEY : java.lang.Class
  ReactiveSecurityContextHolder() : None
  getContext() : reactor.core.publisher.Mono
  hasSecurityContext(context : reactor.util.context.Context) : boolean
  getSecurityContext(context : reactor.util.context.Context) : reactor.core.publisher.Mono
  clearContext() : java.util.function.Function
  withSecurityContext(securityContext : reactor.core.publisher.Mono) : reactor.util.context.Context
  withAuthentication(authentication : org.springframework.security.core.Authentication) : reactor.util.context.Context
}
org.springframework.security.core.context.ReactiveSecurityContextHolder::getContext -- reactor.core.publisher.Mono::deferContextual : Mono.deferContextual(Mono::just).cast(Context.class).filter(ReactiveSecurityContextHolder::hasSecurityContext).flatMap(ReactiveSecurityContextHolder::getSecurityContext) 
org.springframework.security.core.context.ReactiveSecurityContextHolder::getContext -- reactor.core.publisher.Mono::deferContextual : Mono.deferContextual(Mono::just).cast(Context.class).filter(ReactiveSecurityContextHolder::hasSecurityContext) 
org.springframework.security.core.context.ReactiveSecurityContextHolder::getContext -- reactor.core.publisher.Mono::deferContextual : Mono.deferContextual(Mono::just).cast(Context.class) 
org.springframework.security.core.context.ReactiveSecurityContextHolder::getContext -- reactor.core.publisher.Mono::deferContextual : Mono.deferContextual(Mono::just) 
org.springframework.security.core.context.ReactiveSecurityContextHolder::hasSecurityContext -- reactor.util.context.Context::hasKey : context.hasKey(SECURITY_CONTEXT_KEY) 
org.springframework.security.core.context.ReactiveSecurityContextHolder::getSecurityContext -- reactor.util.context.Context::<Mono<SecurityContext>>get : context.<Mono<SecurityContext>>get(SECURITY_CONTEXT_KEY) 
org.springframework.security.core.context.ReactiveSecurityContextHolder::withSecurityContext -- reactor.util.context.Context::of : Context.of(SECURITY_CONTEXT_KEY,securityContext) 
org.springframework.security.core.context.ReactiveSecurityContextHolder::withAuthentication -- reactor.core.publisher.Mono::just : Mono.just(newSecurityContextImpl(authentication)) 
class ReactiveSecurityContextHolderThreadLocalAccessor  implements io.micrometer.context.ThreadLocalAccessor  {
  threadLocal : org.springframework.security.core.context.ThreadLocal
  key() : java.lang.Object
  getValue() : reactor.core.publisher.Mono
  setValue(securityContext : reactor.core.publisher.Mono) : void
  setValue() : void
}
org.springframework.security.core.context.ReactiveSecurityContextHolderThreadLocalAccessor::getValue -- org.springframework.security.core.context.ThreadLocal::get : threadLocal.get() 
org.springframework.security.core.context.ReactiveSecurityContextHolderThreadLocalAccessor::setValue -- org.springframework.util.Assert::notNull : Assert.notNull(securityContext,"securityContext cannot be null") 
org.springframework.security.core.context.ReactiveSecurityContextHolderThreadLocalAccessor::setValue -- org.springframework.security.core.context.ThreadLocal::set : threadLocal.set(securityContext) 
org.springframework.security.core.context.ReactiveSecurityContextHolderThreadLocalAccessor::setValue -- org.springframework.security.core.context.ThreadLocal::remove : threadLocal.remove() 
interface SecurityContext    {
  getAuthentication() : org.springframework.security.core.Authentication
  setAuthentication(authentication : org.springframework.security.core.Authentication) : void
}
class SecurityContextChangedEvent extends org.springframework.context.ApplicationEvent   {
  NO_CONTEXT : java.util.function.Supplier
  oldContext : java.util.function.Supplier
  newContext : java.util.function.Supplier
  SecurityContextChangedEvent(oldContext : java.util.function.Supplier, newContext : java.util.function.Supplier) : None
  SecurityContextChangedEvent(oldContext : org.springframework.security.core.context.SecurityContext, newContext : org.springframework.security.core.context.SecurityContext) : None
  getOldContext() : org.springframework.security.core.context.SecurityContext
  getNewContext() : org.springframework.security.core.context.SecurityContext
  isCleared() : boolean
}
org.springframework.security.core.context.SecurityContextChangedEvent::getOldContext -- java.util.function.Supplier::get : this.oldContext.get() 
org.springframework.security.core.context.SecurityContextChangedEvent::getNewContext -- java.util.function.Supplier::get : this.newContext.get() 
interface SecurityContextChangedListener    {
  securityContextChanged(event : org.springframework.security.core.context.SecurityContextChangedEvent) : void
}
class SecurityContextHolder    {
  MODE_THREADLOCAL : java.lang.String
  MODE_INHERITABLETHREADLOCAL : java.lang.String
  MODE_GLOBAL : java.lang.String
  MODE_PRE_INITIALIZED : java.lang.String
  SYSTEM_PROPERTY : java.lang.String
  strategyName : java.lang.String
  strategy : org.springframework.security.core.context.SecurityContextHolderStrategy
  initializeCount : int
  initialize() : void
  initializeStrategy() : void
  clearContext() : void
  getContext() : org.springframework.security.core.context.SecurityContext
  getDeferredContext() : java.util.function.Supplier
  getInitializeCount() : int
  setContext(context : org.springframework.security.core.context.SecurityContext) : void
  setDeferredContext(deferredContext : java.util.function.Supplier) : void
  setStrategyName(strategyName : java.lang.String) : void
  setContextHolderStrategy(strategy : org.springframework.security.core.context.SecurityContextHolderStrategy) : void
  getContextHolderStrategy() : org.springframework.security.core.context.SecurityContextHolderStrategy
  createEmptyContext() : org.springframework.security.core.context.SecurityContext
  toString() : java.lang.String
}
org.springframework.security.core.context.SecurityContextHolder::initializeStrategy -- org.springframework.security.core.context.MODE_PRE_INITIALIZED::equals : MODE_PRE_INITIALIZED.equals(strategyName) 
org.springframework.security.core.context.SecurityContextHolder::initializeStrategy -- org.springframework.util.Assert::state : Assert.state(strategy!=null,"When using "+MODE_PRE_INITIALIZED+", setContextHolderStrategy must be called with the fully constructed strategy") 
org.springframework.security.core.context.SecurityContextHolder::initializeStrategy -- org.springframework.util.StringUtils::hasText : StringUtils.hasText(strategyName) 
org.springframework.security.core.context.SecurityContextHolder::initializeStrategy -- java.lang.String::equals : strategyName.equals(MODE_THREADLOCAL) 
org.springframework.security.core.context.SecurityContextHolder::initializeStrategy -- java.lang.String::equals : strategyName.equals(MODE_INHERITABLETHREADLOCAL) 
org.springframework.security.core.context.SecurityContextHolder::initializeStrategy -- java.lang.String::equals : strategyName.equals(MODE_GLOBAL) 
org.springframework.security.core.context.SecurityContextHolder::initializeStrategy -- java.lang.Class::forName : Class.forName(strategyName) 
org.springframework.security.core.context.SecurityContextHolder::initializeStrategy -- org.springframework.util.ReflectionUtils::handleReflectionException : ReflectionUtils.handleReflectionException(ex) 
org.springframework.security.core.context.SecurityContextHolder::clearContext -- org.springframework.security.core.context.SecurityContextHolderStrategy::clearContext : strategy.clearContext() 
org.springframework.security.core.context.SecurityContextHolder::getContext -- org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : strategy.getContext() 
org.springframework.security.core.context.SecurityContextHolder::getDeferredContext -- org.springframework.security.core.context.SecurityContextHolderStrategy::getDeferredContext : strategy.getDeferredContext() 
org.springframework.security.core.context.SecurityContextHolder::setContext -- org.springframework.security.core.context.SecurityContextHolderStrategy::setContext : strategy.setContext(context) 
org.springframework.security.core.context.SecurityContextHolder::setDeferredContext -- org.springframework.security.core.context.SecurityContextHolderStrategy::setDeferredContext : strategy.setDeferredContext(deferredContext) 
org.springframework.security.core.context.SecurityContextHolder::setContextHolderStrategy -- org.springframework.util.Assert::notNull : Assert.notNull(strategy,"securityContextHolderStrategy cannot be null") 
org.springframework.security.core.context.SecurityContextHolder::createEmptyContext -- org.springframework.security.core.context.SecurityContextHolderStrategy::createEmptyContext : strategy.createEmptyContext() 
org.springframework.security.core.context.SecurityContextHolder::toString -- org.springframework.security.core.context.SecurityContextHolderStrategy::getClass : strategy.getClass().getSimpleName() 
org.springframework.security.core.context.SecurityContextHolder::toString -- org.springframework.security.core.context.SecurityContextHolderStrategy::getClass : strategy.getClass() 
interface SecurityContextHolderStrategy    {
  clearContext() : void
  getContext() : org.springframework.security.core.context.SecurityContext
  getDeferredContext() : java.util.function.Supplier
  setContext(context : org.springframework.security.core.context.SecurityContext) : void
  setDeferredContext(deferredContext : java.util.function.Supplier) : void
  createEmptyContext() : org.springframework.security.core.context.SecurityContext
}
org.springframework.security.core.context.SecurityContextHolderStrategy::setDeferredContext -- java.util.function.Supplier::get : deferredContext.get() 
class SecurityContextHolderThreadLocalAccessor  implements io.micrometer.context.ThreadLocalAccessor  {
  key() : java.lang.Object
  getValue() : org.springframework.security.core.context.SecurityContext
  setValue(securityContext : org.springframework.security.core.context.SecurityContext) : void
  setValue() : void
}
org.springframework.security.core.context.SecurityContextHolderThreadLocalAccessor::getValue -- org.springframework.security.core.context.SecurityContextHolder::getContext : SecurityContextHolder.getContext() 
org.springframework.security.core.context.SecurityContextHolderThreadLocalAccessor::getValue -- org.springframework.security.core.context.SecurityContextHolder::createEmptyContext : SecurityContextHolder.createEmptyContext() 
org.springframework.security.core.context.SecurityContextHolderThreadLocalAccessor::setValue -- org.springframework.util.Assert::notNull : Assert.notNull(securityContext,"securityContext cannot be null") 
org.springframework.security.core.context.SecurityContextHolderThreadLocalAccessor::setValue -- org.springframework.security.core.context.SecurityContextHolder::setContext : SecurityContextHolder.setContext(securityContext) 
org.springframework.security.core.context.SecurityContextHolderThreadLocalAccessor::setValue -- org.springframework.security.core.context.SecurityContextHolder::clearContext : SecurityContextHolder.clearContext() 
class SecurityContextImpl  implements org.springframework.security.core.context.SecurityContext  {
  serialVersionUID : long
  authentication : org.springframework.security.core.Authentication
  SecurityContextImpl() : None
  SecurityContextImpl(authentication : org.springframework.security.core.Authentication) : None
  equals(obj : java.lang.Object) : boolean
  getAuthentication() : org.springframework.security.core.Authentication
  hashCode() : int
  setAuthentication(authentication : org.springframework.security.core.Authentication) : void
  toString() : java.lang.String
}
org.springframework.security.core.context.SecurityContextImpl::equals -- org.springframework.security.core.context.SecurityContextImpl::getAuthentication : this.getAuthentication().equals(other.getAuthentication()) 
org.springframework.security.core.context.SecurityContextImpl::hashCode -- org.springframework.util.ObjectUtils::nullSafeHashCode : ObjectUtils.nullSafeHashCode(this.authentication) 
org.springframework.security.core.context.SecurityContextImpl::toString -- org.springframework.security.core.context.SecurityContextImpl::getClass : getClass().getSimpleName() 
class ThreadLocalSecurityContextHolderStrategy  implements org.springframework.security.core.context.SecurityContextHolderStrategy  {
  contextHolder : org.springframework.security.core.context.ThreadLocal
  clearContext() : void
  getContext() : org.springframework.security.core.context.SecurityContext
  getDeferredContext() : java.util.function.Supplier
  setContext(context : org.springframework.security.core.context.SecurityContext) : void
  setDeferredContext(deferredContext : java.util.function.Supplier) : void
  createEmptyContext() : org.springframework.security.core.context.SecurityContext
}
org.springframework.security.core.context.ThreadLocalSecurityContextHolderStrategy::clearContext -- org.springframework.security.core.context.ThreadLocal::remove : contextHolder.remove() 
org.springframework.security.core.context.ThreadLocalSecurityContextHolderStrategy::getContext -- org.springframework.security.core.context.ThreadLocalSecurityContextHolderStrategy::getDeferredContext : getDeferredContext().get() 
org.springframework.security.core.context.ThreadLocalSecurityContextHolderStrategy::getDeferredContext -- org.springframework.security.core.context.ThreadLocal::get : contextHolder.get() 
org.springframework.security.core.context.ThreadLocalSecurityContextHolderStrategy::getDeferredContext -- org.springframework.security.core.context.ThreadLocal::set : contextHolder.set(result) 
org.springframework.security.core.context.ThreadLocalSecurityContextHolderStrategy::setContext -- org.springframework.util.Assert::notNull : Assert.notNull(context,"Only non-null SecurityContext instances are permitted") 
org.springframework.security.core.context.ThreadLocalSecurityContextHolderStrategy::setContext -- org.springframework.security.core.context.ThreadLocal::set : contextHolder.set(()->context) 
org.springframework.security.core.context.ThreadLocalSecurityContextHolderStrategy::setDeferredContext -- org.springframework.util.Assert::notNull : Assert.notNull(deferredContext,"Only non-null Supplier instances are permitted") 
org.springframework.security.core.context.ThreadLocalSecurityContextHolderStrategy::setDeferredContext -- java.util.function.Supplier::get : deferredContext.get() 
org.springframework.security.core.context.ThreadLocalSecurityContextHolderStrategy::setDeferredContext -- org.springframework.util.Assert::notNull : Assert.notNull(result,"A Supplier<SecurityContext> returned null and is not allowed.") 
org.springframework.security.core.context.ThreadLocalSecurityContextHolderStrategy::setDeferredContext -- org.springframework.security.core.context.ThreadLocal::set : contextHolder.set(notNullDeferredContext) 
class TransientSecurityContext extends org.springframework.security.core.context.SecurityContextImpl   {
  serialVersionUID : long
  TransientSecurityContext() : None
  TransientSecurityContext(authentication : org.springframework.security.core.Authentication) : None
}
}
package parameters {
class AnnotationParameterNameDiscoverer  implements org.springframework.core.ParameterNameDiscoverer  {
  CONSTRUCTOR_METHODPARAM_FACTORY : org.springframework.security.core.parameters.ParameterNameFactory
  METHOD_METHODPARAM_FACTORY : org.springframework.security.core.parameters.ParameterNameFactory
  annotationClassesToUse : java.util.Set
  AnnotationParameterNameDiscoverer() : None
  AnnotationParameterNameDiscoverer(annotationClassesToUse : java.util.Set) : None
  getParameterNames(method : java.lang.reflect.Method) : org.springframework.security.core.parameters.String[]
  getParameterNames(constructor : java.lang.reflect.Constructor) : org.springframework.security.core.parameters.String[]
  lookupParameterNames(parameterNameFactory : org.springframework.security.core.parameters.ParameterNameFactory, t : org.springframework.security.core.parameters.T) : org.springframework.security.core.parameters.String[]
  findParameterName(parameterAnnotations : org.springframework.security.core.parameters.Annotation[]) : java.lang.String
}
org.springframework.security.core.parameters.AnnotationParameterNameDiscoverer::AnnotationParameterNameDiscoverer -- java.util.Arrays::asList : Arrays.asList(annotationClassToUse) 
org.springframework.security.core.parameters.AnnotationParameterNameDiscoverer::AnnotationParameterNameDiscoverer -- org.springframework.util.Assert::notEmpty : Assert.notEmpty(annotationClassesToUse,"annotationClassesToUse cannot be null or empty") 
org.springframework.security.core.parameters.AnnotationParameterNameDiscoverer::getParameterNames -- org.springframework.core.BridgeMethodResolver::findBridgedMethod : BridgeMethodResolver.findBridgedMethod(method) 
org.springframework.security.core.parameters.AnnotationParameterNameDiscoverer::getParameterNames -- java.lang.reflect.Method::getDeclaringClass : method.getDeclaringClass() 
org.springframework.security.core.parameters.AnnotationParameterNameDiscoverer::getParameterNames -- org.springframework.util.ReflectionUtils::findMethod : ReflectionUtils.findMethod(intrfc,method.getName(),method.getParameterTypes()) 
org.springframework.security.core.parameters.AnnotationParameterNameDiscoverer::getParameterNames -- java.lang.reflect.Method::getName : method.getName() 
org.springframework.security.core.parameters.AnnotationParameterNameDiscoverer::getParameterNames -- java.lang.reflect.Method::getParameterTypes : method.getParameterTypes() 
org.springframework.security.core.parameters.AnnotationParameterNameDiscoverer::lookupParameterNames -- org.springframework.security.core.parameters.ParameterNameFactory::findParameterAnnotations : parameterNameFactory.findParameterAnnotations(t) 
org.springframework.security.core.parameters.AnnotationParameterNameDiscoverer::findParameterName -- java.util.Set::contains : this.annotationClassesToUse.contains(paramAnnotation.annotationType().getName()) 
org.springframework.security.core.parameters.AnnotationParameterNameDiscoverer::findParameterName -- org.springframework.core.annotation.AnnotationUtils::getValue : AnnotationUtils.getValue(paramAnnotation,"value") 
interface ParameterNameFactory    {
  findParameterAnnotations(t : org.springframework.security.core.parameters.T) : org.springframework.security.core.parameters.Annotation[][]
}
class DefaultSecurityParameterNameDiscoverer extends org.springframework.core.PrioritizedParameterNameDiscoverer   {
  DATA_PARAM_CLASSNAME : java.lang.String
  DATA_PARAM_PRESENT : boolean
  DefaultSecurityParameterNameDiscoverer() : None
  DefaultSecurityParameterNameDiscoverer(parameterNameDiscovers : java.util.List) : None
}
org.springframework.security.core.parameters.DefaultSecurityParameterNameDiscoverer::DefaultSecurityParameterNameDiscoverer -- java.util.Collections::emptyList : Collections.emptyList() 
org.springframework.security.core.parameters.DefaultSecurityParameterNameDiscoverer::DefaultSecurityParameterNameDiscoverer -- org.springframework.util.Assert::notNull : Assert.notNull(parameterNameDiscovers,"parameterNameDiscovers cannot be null") 
}
package session {
class AbstractSessionEvent extends org.springframework.context.ApplicationEvent   {
  serialVersionUID : long
  AbstractSessionEvent(source : java.lang.Object) : None
}
class InMemoryReactiveSessionRegistry  implements org.springframework.security.core.session.ReactiveSessionRegistry  {
  sessionIdsByPrincipal : java.util.concurrent.ConcurrentMap
  sessionById : java.util.Map
  InMemoryReactiveSessionRegistry() : None
  InMemoryReactiveSessionRegistry(sessionIdsByPrincipal : java.util.concurrent.ConcurrentMap, sessionById : java.util.Map) : None
  getAllSessions(principal : java.lang.Object) : reactor.core.publisher.Flux
  saveSessionInformation(information : org.springframework.security.core.session.ReactiveSessionInformation) : reactor.core.publisher.Mono
  getSessionInformation(sessionId : java.lang.String) : reactor.core.publisher.Mono
  removeSessionInformation(sessionId : java.lang.String) : reactor.core.publisher.Mono
  updateLastAccessTime(sessionId : java.lang.String) : reactor.core.publisher.Mono
}
org.springframework.security.core.session.InMemoryReactiveSessionRegistry::getAllSessions -- reactor.core.publisher.Flux::fromIterable : Flux.fromIterable(this.sessionIdsByPrincipal.getOrDefault(principal,Collections.emptySet())).map(this.sessionById::get) 
org.springframework.security.core.session.InMemoryReactiveSessionRegistry::getAllSessions -- reactor.core.publisher.Flux::fromIterable : Flux.fromIterable(this.sessionIdsByPrincipal.getOrDefault(principal,Collections.emptySet())) 
org.springframework.security.core.session.InMemoryReactiveSessionRegistry::getAllSessions -- java.util.concurrent.ConcurrentMap::getOrDefault : this.sessionIdsByPrincipal.getOrDefault(principal,Collections.emptySet()) 
org.springframework.security.core.session.InMemoryReactiveSessionRegistry::getAllSessions -- java.util.Collections::emptySet : Collections.emptySet() 
org.springframework.security.core.session.InMemoryReactiveSessionRegistry::saveSessionInformation -- java.util.Map::put : this.sessionById.put(information.getSessionId(),information) 
org.springframework.security.core.session.InMemoryReactiveSessionRegistry::saveSessionInformation -- org.springframework.security.core.session.ReactiveSessionInformation::getSessionId : information.getSessionId() 
org.springframework.security.core.session.InMemoryReactiveSessionRegistry::saveSessionInformation -- java.util.concurrent.ConcurrentMap::computeIfAbsent : this.sessionIdsByPrincipal.computeIfAbsent(information.getPrincipal(),(key)->newCopyOnWriteArraySet<>()).add(information.getSessionId()) 
org.springframework.security.core.session.InMemoryReactiveSessionRegistry::saveSessionInformation -- java.util.concurrent.ConcurrentMap::computeIfAbsent : this.sessionIdsByPrincipal.computeIfAbsent(information.getPrincipal(),(key)->newCopyOnWriteArraySet<>()) 
org.springframework.security.core.session.InMemoryReactiveSessionRegistry::saveSessionInformation -- org.springframework.security.core.session.ReactiveSessionInformation::getPrincipal : information.getPrincipal() 
org.springframework.security.core.session.InMemoryReactiveSessionRegistry::saveSessionInformation -- org.springframework.security.core.session.ReactiveSessionInformation::getSessionId : information.getSessionId() 
org.springframework.security.core.session.InMemoryReactiveSessionRegistry::saveSessionInformation -- reactor.core.publisher.Mono::empty : Mono.empty() 
org.springframework.security.core.session.InMemoryReactiveSessionRegistry::getSessionInformation -- reactor.core.publisher.Mono::justOrEmpty : Mono.justOrEmpty(this.sessionById.get(sessionId)) 
org.springframework.security.core.session.InMemoryReactiveSessionRegistry::getSessionInformation -- java.util.Map::get : this.sessionById.get(sessionId) 
org.springframework.security.core.session.InMemoryReactiveSessionRegistry::removeSessionInformation -- org.springframework.security.core.session.InMemoryReactiveSessionRegistry::getSessionInformation : getSessionInformation(sessionId).doOnNext((sessionInformation)->{this.sessionById.remove(sessionId);Set<String>sessionsUsedByPrincipal=this.sessionIdsByPrincipal.get(sessionInformation.getPrincipal());if(sessionsUsedByPrincipal!=null){sessionsUsedByPrincipal.remove(sessionId);if(sessionsUsedByPrincipal.isEmpty()){this.sessionIdsByPrincipal.remove(sessionInformation.getPrincipal());}}}) 
org.springframework.security.core.session.InMemoryReactiveSessionRegistry::removeSessionInformation -- java.util.Map::remove : this.sessionById.remove(sessionId) 
org.springframework.security.core.session.InMemoryReactiveSessionRegistry::removeSessionInformation -- java.util.concurrent.ConcurrentMap::get : this.sessionIdsByPrincipal.get(sessionInformation.getPrincipal()) 
org.springframework.security.core.session.InMemoryReactiveSessionRegistry::removeSessionInformation -- java.util.concurrent.ConcurrentMap::remove : this.sessionIdsByPrincipal.remove(sessionInformation.getPrincipal()) 
org.springframework.security.core.session.InMemoryReactiveSessionRegistry::updateLastAccessTime -- java.util.Map::get : this.sessionById.get(sessionId) 
org.springframework.security.core.session.InMemoryReactiveSessionRegistry::updateLastAccessTime -- reactor.core.publisher.Mono::empty : Mono.empty() 
class ReactiveSessionInformation  implements java.io.Serializable  {
  serialVersionUID : long
  lastAccessTime : java.time.Instant
  principal : java.lang.Object
  sessionId : java.lang.String
  expired : boolean
  ReactiveSessionInformation(principal : java.lang.Object, sessionId : java.lang.String, lastAccessTime : java.time.Instant) : None
  withSessionId(sessionId : java.lang.String) : org.springframework.security.core.session.ReactiveSessionInformation
  invalidate() : reactor.core.publisher.Mono
  refreshLastRequest() : reactor.core.publisher.Mono
  getLastAccessTime() : java.time.Instant
  getPrincipal() : java.lang.Object
  getSessionId() : java.lang.String
  isExpired() : boolean
  setLastAccessTime(lastAccessTime : java.time.Instant) : void
}
org.springframework.security.core.session.ReactiveSessionInformation::ReactiveSessionInformation -- org.springframework.util.Assert::notNull : Assert.notNull(principal,"principal cannot be null") 
org.springframework.security.core.session.ReactiveSessionInformation::ReactiveSessionInformation -- org.springframework.util.Assert::hasText : Assert.hasText(sessionId,"sessionId cannot be null") 
org.springframework.security.core.session.ReactiveSessionInformation::ReactiveSessionInformation -- org.springframework.util.Assert::notNull : Assert.notNull(lastAccessTime,"lastAccessTime cannot be null") 
org.springframework.security.core.session.ReactiveSessionInformation::invalidate -- reactor.core.publisher.Mono::fromRunnable : Mono.fromRunnable(()->this.expired=true) 
org.springframework.security.core.session.ReactiveSessionInformation::refreshLastRequest -- java.time.Instant::now : Instant.now() 
org.springframework.security.core.session.ReactiveSessionInformation::refreshLastRequest -- reactor.core.publisher.Mono::empty : Mono.empty() 
interface ReactiveSessionRegistry    {
  getAllSessions(principal : java.lang.Object) : reactor.core.publisher.Flux
  saveSessionInformation(information : org.springframework.security.core.session.ReactiveSessionInformation) : reactor.core.publisher.Mono
  getSessionInformation(sessionId : java.lang.String) : reactor.core.publisher.Mono
  removeSessionInformation(sessionId : java.lang.String) : reactor.core.publisher.Mono
  updateLastAccessTime(sessionId : java.lang.String) : reactor.core.publisher.Mono
}
class SessionCreationEvent extends org.springframework.security.core.session.AbstractSessionEvent   {
  SessionCreationEvent(source : java.lang.Object) : None
}
class SessionDestroyedEvent extends org.springframework.security.core.session.AbstractSessionEvent   {
  SessionDestroyedEvent(source : java.lang.Object) : None
  getSecurityContexts() : java.util.List
  getId() : java.lang.String
}
class SessionIdChangedEvent extends org.springframework.security.core.session.AbstractSessionEvent   {
  SessionIdChangedEvent(source : java.lang.Object) : None
  getOldSessionId() : java.lang.String
  getNewSessionId() : java.lang.String
}
class SessionInformation  implements java.io.Serializable  {
  serialVersionUID : long
  lastRequest : java.util.Date
  principal : java.lang.Object
  sessionId : java.lang.String
  expired : boolean
  SessionInformation(principal : java.lang.Object, sessionId : java.lang.String, lastRequest : java.util.Date) : None
  expireNow() : void
  getLastRequest() : java.util.Date
  getPrincipal() : java.lang.Object
  getSessionId() : java.lang.String
  isExpired() : boolean
  refreshLastRequest() : void
}
org.springframework.security.core.session.SessionInformation::SessionInformation -- org.springframework.util.Assert::notNull : Assert.notNull(principal,"Principal required") 
org.springframework.security.core.session.SessionInformation::SessionInformation -- org.springframework.util.Assert::hasText : Assert.hasText(sessionId,"SessionId required") 
org.springframework.security.core.session.SessionInformation::SessionInformation -- org.springframework.util.Assert::notNull : Assert.notNull(lastRequest,"LastRequest required") 
interface SessionRegistry    {
  getAllPrincipals() : java.util.List
  getAllSessions(principal : java.lang.Object, includeExpiredSessions : boolean) : java.util.List
  getSessionInformation(sessionId : java.lang.String) : org.springframework.security.core.session.SessionInformation
  refreshLastRequest(sessionId : java.lang.String) : void
  registerNewSession(sessionId : java.lang.String, principal : java.lang.Object) : void
  removeSessionInformation(sessionId : java.lang.String) : void
}
class SessionRegistryImpl  implements org.springframework.security.core.session.SessionRegistry,ApplicationListener  {
  logger : org.apache.commons.logging.Log
  principals : java.util.concurrent.ConcurrentMap
  sessionIds : java.util.Map
  SessionRegistryImpl() : None
  SessionRegistryImpl(principals : java.util.concurrent.ConcurrentMap, sessionIds : java.util.Map) : None
  getAllPrincipals() : java.util.List
  getAllSessions(principal : java.lang.Object, includeExpiredSessions : boolean) : java.util.List
  getSessionInformation(sessionId : java.lang.String) : org.springframework.security.core.session.SessionInformation
  onApplicationEvent(event : org.springframework.security.core.session.AbstractSessionEvent) : void
  refreshLastRequest(sessionId : java.lang.String) : void
  registerNewSession(sessionId : java.lang.String, principal : java.lang.Object) : void
  removeSessionInformation(sessionId : java.lang.String) : void
}
org.springframework.security.core.session.SessionRegistryImpl::getAllPrincipals -- java.util.concurrent.ConcurrentMap::keySet : this.principals.keySet() 
org.springframework.security.core.session.SessionRegistryImpl::getAllSessions -- java.util.concurrent.ConcurrentMap::get : this.principals.get(principal) 
org.springframework.security.core.session.SessionRegistryImpl::getAllSessions -- java.util.Collections::emptyList : Collections.emptyList() 
org.springframework.security.core.session.SessionRegistryImpl::getSessionInformation -- org.springframework.util.Assert::hasText : Assert.hasText(sessionId,"SessionId required as per interface contract") 
org.springframework.security.core.session.SessionRegistryImpl::getSessionInformation -- java.util.Map::get : this.sessionIds.get(sessionId) 
org.springframework.security.core.session.SessionRegistryImpl::onApplicationEvent -- java.util.Map::containsKey : this.sessionIds.containsKey(oldSessionId) 
org.springframework.security.core.session.SessionRegistryImpl::onApplicationEvent -- java.util.Map::get : this.sessionIds.get(oldSessionId).getPrincipal() 
org.springframework.security.core.session.SessionRegistryImpl::onApplicationEvent -- java.util.Map::get : this.sessionIds.get(oldSessionId) 
org.springframework.security.core.session.SessionRegistryImpl::refreshLastRequest -- org.springframework.util.Assert::hasText : Assert.hasText(sessionId,"SessionId required as per interface contract") 
org.springframework.security.core.session.SessionRegistryImpl::registerNewSession -- org.springframework.util.Assert::hasText : Assert.hasText(sessionId,"SessionId required as per interface contract") 
org.springframework.security.core.session.SessionRegistryImpl::registerNewSession -- org.springframework.util.Assert::notNull : Assert.notNull(principal,"Principal required as per interface contract") 
org.springframework.security.core.session.SessionRegistryImpl::registerNewSession -- org.apache.commons.logging.Log::isDebugEnabled : this.logger.isDebugEnabled() 
org.springframework.security.core.session.SessionRegistryImpl::registerNewSession -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.format("Registering session %s, for principal %s",sessionId,principal)) 
org.springframework.security.core.session.SessionRegistryImpl::registerNewSession -- org.springframework.core.log.LogMessage::format : LogMessage.format("Registering session %s, for principal %s",sessionId,principal) 
org.springframework.security.core.session.SessionRegistryImpl::registerNewSession -- java.util.Map::put : this.sessionIds.put(sessionId,newSessionInformation(principal,sessionId,newDate())) 
org.springframework.security.core.session.SessionRegistryImpl::registerNewSession -- java.util.concurrent.ConcurrentMap::compute : this.principals.compute(principal,(key,sessionsUsedByPrincipal)->{if(sessionsUsedByPrincipal==null){sessionsUsedByPrincipal=newCopyOnWriteArraySet<>();}sessionsUsedByPrincipal.add(sessionId);this.logger.trace(LogMessage.format("Sessions used by '%s' : %s",principal,sessionsUsedByPrincipal));returnsessionsUsedByPrincipal;}) 
org.springframework.security.core.session.SessionRegistryImpl::registerNewSession -- org.apache.commons.logging.Log::trace : this.logger.trace(LogMessage.format("Sessions used by '%s' : %s",principal,sessionsUsedByPrincipal)) 
org.springframework.security.core.session.SessionRegistryImpl::registerNewSession -- org.springframework.core.log.LogMessage::format : LogMessage.format("Sessions used by '%s' : %s",principal,sessionsUsedByPrincipal) 
org.springframework.security.core.session.SessionRegistryImpl::removeSessionInformation -- org.springframework.util.Assert::hasText : Assert.hasText(sessionId,"SessionId required as per interface contract") 
org.springframework.security.core.session.SessionRegistryImpl::removeSessionInformation -- org.apache.commons.logging.Log::isTraceEnabled : this.logger.isTraceEnabled() 
org.springframework.security.core.session.SessionRegistryImpl::removeSessionInformation -- org.apache.commons.logging.Log::debug : this.logger.debug("Removing session "+sessionId+" from set of registered sessions") 
org.springframework.security.core.session.SessionRegistryImpl::removeSessionInformation -- java.util.Map::remove : this.sessionIds.remove(sessionId) 
org.springframework.security.core.session.SessionRegistryImpl::removeSessionInformation -- java.util.concurrent.ConcurrentMap::computeIfPresent : this.principals.computeIfPresent(info.getPrincipal(),(key,sessionsUsedByPrincipal)->{this.logger.debug(LogMessage.format("Removing session %s from principal's set of registered sessions",sessionId));sessionsUsedByPrincipal.remove(sessionId);if(sessionsUsedByPrincipal.isEmpty()){this.logger.debug(LogMessage.format("Removing principal %s from registry",info.getPrincipal()));sessionsUsedByPrincipal=null;}this.logger.trace(LogMessage.format("Sessions used by '%s' : %s",info.getPrincipal(),sessionsUsedByPrincipal));returnsessionsUsedByPrincipal;}) 
org.springframework.security.core.session.SessionRegistryImpl::removeSessionInformation -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.format("Removing session %s from principal's set of registered sessions",sessionId)) 
org.springframework.security.core.session.SessionRegistryImpl::removeSessionInformation -- org.springframework.core.log.LogMessage::format : LogMessage.format("Removing session %s from principal's set of registered sessions",sessionId) 
org.springframework.security.core.session.SessionRegistryImpl::removeSessionInformation -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.format("Removing principal %s from registry",info.getPrincipal())) 
org.springframework.security.core.session.SessionRegistryImpl::removeSessionInformation -- org.springframework.core.log.LogMessage::format : LogMessage.format("Removing principal %s from registry",info.getPrincipal()) 
org.springframework.security.core.session.SessionRegistryImpl::removeSessionInformation -- org.apache.commons.logging.Log::trace : this.logger.trace(LogMessage.format("Sessions used by '%s' : %s",info.getPrincipal(),sessionsUsedByPrincipal)) 
org.springframework.security.core.session.SessionRegistryImpl::removeSessionInformation -- org.springframework.core.log.LogMessage::format : LogMessage.format("Sessions used by '%s' : %s",info.getPrincipal(),sessionsUsedByPrincipal) 
}
package token {
class DefaultToken  implements org.springframework.security.core.token.Token  {
  key : java.lang.String
  keyCreationTime : long
  extendedInformation : java.lang.String
  DefaultToken(key : java.lang.String, keyCreationTime : long, extendedInformation : java.lang.String) : None
  getKey() : java.lang.String
  getKeyCreationTime() : long
  getExtendedInformation() : java.lang.String
  equals(obj : java.lang.Object) : boolean
  hashCode() : int
  toString() : java.lang.String
}
org.springframework.security.core.token.DefaultToken::DefaultToken -- org.springframework.util.Assert::hasText : Assert.hasText(key,"Key required") 
org.springframework.security.core.token.DefaultToken::DefaultToken -- org.springframework.util.Assert::notNull : Assert.notNull(extendedInformation,"Extended information cannot be null") 
org.springframework.security.core.token.DefaultToken::equals -- java.lang.String::equals : this.key.equals(rhs.key) 
org.springframework.security.core.token.DefaultToken::equals -- java.lang.String::equals : this.extendedInformation.equals(rhs.extendedInformation) 
org.springframework.security.core.token.DefaultToken::hashCode -- java.lang.String::hashCode : this.key.hashCode() 
org.springframework.security.core.token.DefaultToken::hashCode -- java.lang.Long::valueOf : Long.valueOf(this.keyCreationTime).hashCode() 
org.springframework.security.core.token.DefaultToken::hashCode -- java.lang.Long::valueOf : Long.valueOf(this.keyCreationTime) 
org.springframework.security.core.token.DefaultToken::hashCode -- java.lang.String::hashCode : this.extendedInformation.hashCode() 
class KeyBasedPersistenceTokenService  implements org.springframework.security.core.token.TokenService,InitializingBean  {
  pseudoRandomNumberBytes : int
  serverSecret : java.lang.String
  serverInteger : java.lang.Integer
  secureRandom : java.security.SecureRandom
  allocateToken(extendedInformation : java.lang.String) : org.springframework.security.core.token.Token
  computeKey(serverSecret : java.lang.String, content : java.lang.String) : java.lang.String
  verifyToken(key : java.lang.String) : org.springframework.security.core.token.Token
  generatePseudoRandomNumber() : java.lang.String
  computeServerSecretApplicableAt(time : long) : java.lang.String
  setServerSecret(serverSecret : java.lang.String) : void
  setSecureRandom(secureRandom : java.security.SecureRandom) : void
  setPseudoRandomNumberBytes(pseudoRandomNumberBytes : int) : void
  setServerInteger(serverInteger : java.lang.Integer) : void
  afterPropertiesSet() : void
}
org.springframework.security.core.token.KeyBasedPersistenceTokenService::allocateToken -- org.springframework.util.Assert::notNull : Assert.notNull(extendedInformation,"Must provided non-null extendedInformation (but it can be empty)") 
org.springframework.security.core.token.KeyBasedPersistenceTokenService::allocateToken -- org.springframework.security.core.token.System::currentTimeMillis : System.currentTimeMillis() 
org.springframework.security.core.token.KeyBasedPersistenceTokenService::computeKey -- org.springframework.security.core.token.Sha512DigestUtils::shaHex : Sha512DigestUtils.shaHex(content+":"+serverSecret) 
org.springframework.security.core.token.KeyBasedPersistenceTokenService::computeKey -- org.springframework.security.crypto.codec.Utf8::decode : Utf8.decode(Base64.getEncoder().encode(Utf8.encode(keyPayload))) 
org.springframework.security.core.token.KeyBasedPersistenceTokenService::computeKey -- java.util.Base64::getEncoder : Base64.getEncoder().encode(Utf8.encode(keyPayload)) 
org.springframework.security.core.token.KeyBasedPersistenceTokenService::computeKey -- java.util.Base64::getEncoder : Base64.getEncoder() 
org.springframework.security.core.token.KeyBasedPersistenceTokenService::computeKey -- org.springframework.security.crypto.codec.Utf8::encode : Utf8.encode(keyPayload) 
org.springframework.security.core.token.KeyBasedPersistenceTokenService::verifyToken -- org.springframework.util.StringUtils::delimitedListToStringArray : StringUtils.delimitedListToStringArray(Utf8.decode(Base64.getDecoder().decode(Utf8.encode(key))),":") 
org.springframework.security.core.token.KeyBasedPersistenceTokenService::verifyToken -- org.springframework.security.crypto.codec.Utf8::decode : Utf8.decode(Base64.getDecoder().decode(Utf8.encode(key))) 
org.springframework.security.core.token.KeyBasedPersistenceTokenService::verifyToken -- java.util.Base64::getDecoder : Base64.getDecoder().decode(Utf8.encode(key)) 
org.springframework.security.core.token.KeyBasedPersistenceTokenService::verifyToken -- java.util.Base64::getDecoder : Base64.getDecoder() 
org.springframework.security.core.token.KeyBasedPersistenceTokenService::verifyToken -- org.springframework.security.crypto.codec.Utf8::encode : Utf8.encode(key) 
org.springframework.security.core.token.KeyBasedPersistenceTokenService::verifyToken -- org.springframework.util.Assert::isTrue : Assert.isTrue(tokens.length>=4,()->"Expected 4 or more tokens but found "+tokens.length) 
org.springframework.security.core.token.KeyBasedPersistenceTokenService::verifyToken -- java.lang.Long::decode : Long.decode(tokens[0]) 
org.springframework.security.core.token.KeyBasedPersistenceTokenService::verifyToken -- org.springframework.security.core.token.Sha512DigestUtils::shaHex : Sha512DigestUtils.shaHex(content+":"+serverSecret) 
org.springframework.security.core.token.KeyBasedPersistenceTokenService::verifyToken -- org.springframework.util.Assert::isTrue : Assert.isTrue(expectedSha512Hex.equals(sha1Hex),"Key verification failure") 
org.springframework.security.core.token.KeyBasedPersistenceTokenService::generatePseudoRandomNumber -- java.security.SecureRandom::nextBytes : this.secureRandom.nextBytes(randomBytes) 
org.springframework.security.core.token.KeyBasedPersistenceTokenService::generatePseudoRandomNumber -- org.springframework.security.crypto.codec.Hex::encode : Hex.encode(randomBytes) 
org.springframework.security.core.token.KeyBasedPersistenceTokenService::computeServerSecretApplicableAt -- java.lang.Long::valueOf : Long.valueOf(time%this.serverInteger).intValue() 
org.springframework.security.core.token.KeyBasedPersistenceTokenService::computeServerSecretApplicableAt -- java.lang.Long::valueOf : Long.valueOf(time%this.serverInteger) 
org.springframework.security.core.token.KeyBasedPersistenceTokenService::setPseudoRandomNumberBytes -- org.springframework.util.Assert::isTrue : Assert.isTrue(pseudoRandomNumberBytes>=0,"Must have a positive pseudo random number bit size") 
org.springframework.security.core.token.KeyBasedPersistenceTokenService::afterPropertiesSet -- org.springframework.util.Assert::hasText : Assert.hasText(this.serverSecret,"Server secret required") 
org.springframework.security.core.token.KeyBasedPersistenceTokenService::afterPropertiesSet -- org.springframework.util.Assert::notNull : Assert.notNull(this.serverInteger,"Server integer required") 
org.springframework.security.core.token.KeyBasedPersistenceTokenService::afterPropertiesSet -- org.springframework.util.Assert::notNull : Assert.notNull(this.secureRandom,"SecureRandom instance required") 
class SecureRandomFactoryBean  implements org.springframework.beans.factory.FactoryBean  {
  algorithm : java.lang.String
  seed : org.springframework.core.io.Resource
  getObject() : java.security.SecureRandom
  getObjectType() : java.lang.Class
  isSingleton() : boolean
  setAlgorithm(algorithm : java.lang.String) : void
  setSeed(seed : org.springframework.core.io.Resource) : void
}
org.springframework.security.core.token.SecureRandomFactoryBean::getObject -- java.security.SecureRandom::getInstance : SecureRandom.getInstance(this.algorithm) 
org.springframework.security.core.token.SecureRandomFactoryBean::getObject -- org.springframework.util.FileCopyUtils::copyToByteArray : FileCopyUtils.copyToByteArray(this.seed.getInputStream()) 
org.springframework.security.core.token.SecureRandomFactoryBean::getObject -- org.springframework.core.io.Resource::getInputStream : this.seed.getInputStream() 
org.springframework.security.core.token.SecureRandomFactoryBean::setAlgorithm -- org.springframework.util.Assert::hasText : Assert.hasText(algorithm,"Algorithm required") 
class Sha512DigestUtils    {
  getSha512Digest() : java.security.MessageDigest
  sha(data : org.springframework.security.core.token.byte[]) : org.springframework.security.core.token.byte[]
  sha(data : java.lang.String) : org.springframework.security.core.token.byte[]
  shaHex(data : org.springframework.security.core.token.byte[]) : java.lang.String
  shaHex(data : java.lang.String) : java.lang.String
}
org.springframework.security.core.token.Sha512DigestUtils::getSha512Digest -- java.security.MessageDigest::getInstance : MessageDigest.getInstance("SHA-512") 
org.springframework.security.core.token.Sha512DigestUtils::sha -- org.springframework.security.core.token.Sha512DigestUtils::getSha512Digest : getSha512Digest().digest(data) 
org.springframework.security.core.token.Sha512DigestUtils::sha -- java.lang.String::getBytes : data.getBytes() 
org.springframework.security.core.token.Sha512DigestUtils::shaHex -- org.springframework.security.crypto.codec.Hex::encode : Hex.encode(sha(data)) 
org.springframework.security.core.token.Sha512DigestUtils::shaHex -- org.springframework.security.crypto.codec.Hex::encode : Hex.encode(sha(data)) 
interface Token    {
  getKey() : java.lang.String
  getKeyCreationTime() : long
  getExtendedInformation() : java.lang.String
}
interface TokenService    {
  allocateToken(extendedInformation : java.lang.String) : org.springframework.security.core.token.Token
  verifyToken(key : java.lang.String) : org.springframework.security.core.token.Token
}
}
package userdetails {
package cache {
class NullUserCache  implements org.springframework.security.core.userdetails.UserCache  {
  getUserFromCache(username : java.lang.String) : org.springframework.security.core.userdetails.UserDetails
  putUserInCache(user : org.springframework.security.core.userdetails.UserDetails) : void
  removeUserFromCache(username : java.lang.String) : void
}
class SpringCacheBasedUserCache  implements org.springframework.security.core.userdetails.UserCache  {
  logger : org.apache.commons.logging.Log
  cache : org.springframework.cache.Cache
  SpringCacheBasedUserCache(cache : org.springframework.cache.Cache) : None
  getUserFromCache(username : java.lang.String) : org.springframework.security.core.userdetails.UserDetails
  putUserInCache(user : org.springframework.security.core.userdetails.UserDetails) : void
  removeUserFromCache(user : org.springframework.security.core.userdetails.UserDetails) : void
  removeUserFromCache(username : java.lang.String) : void
}
org.springframework.security.core.userdetails.cache.SpringCacheBasedUserCache::SpringCacheBasedUserCache -- org.springframework.util.Assert::notNull : Assert.notNull(cache,"cache mandatory") 
org.springframework.security.core.userdetails.cache.SpringCacheBasedUserCache::getUserFromCache -- org.springframework.cache.Cache::get : this.cache.get(username) 
org.springframework.security.core.userdetails.cache.SpringCacheBasedUserCache::getUserFromCache -- org.apache.commons.logging.Log::debug : logger.debug(LogMessage.of(()->"Cache hit: "+(element!=null)+"; username: "+username)) 
org.springframework.security.core.userdetails.cache.SpringCacheBasedUserCache::getUserFromCache -- org.springframework.core.log.LogMessage::of : LogMessage.of(()->"Cache hit: "+(element!=null)+"; username: "+username) 
org.springframework.security.core.userdetails.cache.SpringCacheBasedUserCache::putUserInCache -- org.apache.commons.logging.Log::debug : logger.debug(LogMessage.of(()->"Cache put: "+user.getUsername())) 
org.springframework.security.core.userdetails.cache.SpringCacheBasedUserCache::putUserInCache -- org.springframework.core.log.LogMessage::of : LogMessage.of(()->"Cache put: "+user.getUsername()) 
org.springframework.security.core.userdetails.cache.SpringCacheBasedUserCache::putUserInCache -- org.springframework.security.core.userdetails.UserDetails::getUsername : user.getUsername() 
org.springframework.security.core.userdetails.cache.SpringCacheBasedUserCache::putUserInCache -- org.springframework.cache.Cache::put : this.cache.put(user.getUsername(),user) 
org.springframework.security.core.userdetails.cache.SpringCacheBasedUserCache::putUserInCache -- org.springframework.security.core.userdetails.UserDetails::getUsername : user.getUsername() 
org.springframework.security.core.userdetails.cache.SpringCacheBasedUserCache::removeUserFromCache -- org.apache.commons.logging.Log::debug : logger.debug(LogMessage.of(()->"Cache remove: "+user.getUsername())) 
org.springframework.security.core.userdetails.cache.SpringCacheBasedUserCache::removeUserFromCache -- org.springframework.core.log.LogMessage::of : LogMessage.of(()->"Cache remove: "+user.getUsername()) 
org.springframework.security.core.userdetails.cache.SpringCacheBasedUserCache::removeUserFromCache -- org.springframework.security.core.userdetails.UserDetails::getUsername : user.getUsername() 
org.springframework.security.core.userdetails.cache.SpringCacheBasedUserCache::removeUserFromCache -- org.springframework.security.core.userdetails.cache.SpringCacheBasedUserCache::removeUserFromCache : this.removeUserFromCache(user.getUsername()) 
org.springframework.security.core.userdetails.cache.SpringCacheBasedUserCache::removeUserFromCache -- org.springframework.security.core.userdetails.UserDetails::getUsername : user.getUsername() 
org.springframework.security.core.userdetails.cache.SpringCacheBasedUserCache::removeUserFromCache -- org.springframework.cache.Cache::evict : this.cache.evict(username) 
}
package jdbc {
class JdbcDaoImpl extends org.springframework.jdbc.core.support.JdbcDaoSupport implements org.springframework.security.core.userdetails.jdbc.UserDetailsService,MessageSourceAware  {
  DEFAULT_USER_SCHEMA_DDL_LOCATION : java.lang.String
  DEF_USERS_BY_USERNAME_QUERY : java.lang.String
  DEF_AUTHORITIES_BY_USERNAME_QUERY : java.lang.String
  DEF_GROUP_AUTHORITIES_BY_USERNAME_QUERY : java.lang.String
  messages : org.springframework.context.support.MessageSourceAccessor
  authoritiesByUsernameQuery : java.lang.String
  groupAuthoritiesByUsernameQuery : java.lang.String
  usersByUsernameQuery : java.lang.String
  rolePrefix : java.lang.String
  usernameBasedPrimaryKey : boolean
  enableAuthorities : boolean
  enableGroups : boolean
  JdbcDaoImpl() : None
  getMessages() : org.springframework.context.support.MessageSourceAccessor
  addCustomAuthorities(username : java.lang.String, authorities : java.util.List) : void
  getUsersByUsernameQuery() : java.lang.String
  initDao() : void
  loadUserByUsername(username : java.lang.String) : org.springframework.security.core.userdetails.UserDetails
  loadUsersByUsername(username : java.lang.String) : java.util.List
  loadUserAuthorities(username : java.lang.String) : java.util.List
  loadGroupAuthorities(username : java.lang.String) : java.util.List
  createUserDetails(username : java.lang.String, userFromUserQuery : org.springframework.security.core.userdetails.UserDetails, combinedAuthorities : java.util.List) : org.springframework.security.core.userdetails.UserDetails
  setAuthoritiesByUsernameQuery(queryString : java.lang.String) : void
  getAuthoritiesByUsernameQuery() : java.lang.String
  setGroupAuthoritiesByUsernameQuery(queryString : java.lang.String) : void
  setRolePrefix(rolePrefix : java.lang.String) : void
  getRolePrefix() : java.lang.String
  setUsernameBasedPrimaryKey(usernameBasedPrimaryKey : boolean) : void
  isUsernameBasedPrimaryKey() : boolean
  setUsersByUsernameQuery(usersByUsernameQueryString : java.lang.String) : void
  getEnableAuthorities() : boolean
  setEnableAuthorities(enableAuthorities : boolean) : void
  getEnableGroups() : boolean
  setEnableGroups(enableGroups : boolean) : void
  setMessageSource(messageSource : org.springframework.context.MessageSource) : void
}
org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl::initDao -- org.springframework.util.Assert::isTrue : Assert.isTrue(this.enableAuthorities||this.enableGroups,"Use of either authorities or groups must be enabled") 
org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl::loadUserByUsername -- org.springframework.context.support.MessageSourceAccessor::getMessage : this.messages.getMessage("JdbcDaoImpl.notFound",newObject[]{username},"Username {0} not found") 
org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl::loadUserByUsername -- org.springframework.context.support.MessageSourceAccessor::getMessage : this.messages.getMessage("JdbcDaoImpl.noAuthority",newObject[]{username},"User {0} has no GrantedAuthority") 
org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl::loadUsersByUsername -- org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl::getJdbcTemplate : getJdbcTemplate().query(this.usersByUsernameQuery,mapper,username) 
org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl::loadUserAuthorities -- org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl::getJdbcTemplate : getJdbcTemplate().query(this.authoritiesByUsernameQuery,newString[]{username},(rs,rowNum)->{StringroleName=JdbcDaoImpl.this.rolePrefix+rs.getString(2);returnnewSimpleGrantedAuthority(roleName);}) 
org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl::loadGroupAuthorities -- org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl::getJdbcTemplate : getJdbcTemplate().query(this.groupAuthoritiesByUsernameQuery,newString[]{username},(rs,rowNum)->{StringroleName=getRolePrefix()+rs.getString(3);returnnewSimpleGrantedAuthority(roleName);}) 
org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl::createUserDetails -- org.springframework.security.core.userdetails.UserDetails::getUsername : userFromUserQuery.getUsername() 
org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl::createUserDetails -- org.springframework.security.core.userdetails.UserDetails::getPassword : userFromUserQuery.getPassword() 
org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl::createUserDetails -- org.springframework.security.core.userdetails.UserDetails::isEnabled : userFromUserQuery.isEnabled() 
org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl::createUserDetails -- org.springframework.security.core.userdetails.UserDetails::isAccountNonExpired : userFromUserQuery.isAccountNonExpired() 
org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl::createUserDetails -- org.springframework.security.core.userdetails.UserDetails::isCredentialsNonExpired : userFromUserQuery.isCredentialsNonExpired() 
org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl::createUserDetails -- org.springframework.security.core.userdetails.UserDetails::isAccountNonLocked : userFromUserQuery.isAccountNonLocked() 
org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl::setMessageSource -- org.springframework.util.Assert::notNull : Assert.notNull(messageSource,"messageSource cannot be null") 
}
package memory {
class UserAttribute    {
  authorities : java.util.List
  password : java.lang.String
  enabled : boolean
  addAuthority(newAuthority : org.springframework.security.core.GrantedAuthority) : void
  getAuthorities() : java.util.List
  setAuthorities(authorities : java.util.List) : void
  setAuthoritiesAsString(authoritiesAsStrings : java.util.List) : void
  getPassword() : java.lang.String
  isEnabled() : boolean
  isValid() : boolean
  setEnabled(enabled : boolean) : void
  setPassword(password : java.lang.String) : void
}
org.springframework.security.core.userdetails.memory.UserAttribute::addAuthority -- java.util.List::add : this.authorities.add(newAuthority) 
org.springframework.security.core.userdetails.memory.UserAttribute::setAuthoritiesAsString -- java.util.List::size : authoritiesAsStrings.size() 
org.springframework.security.core.userdetails.memory.UserAttribute::isValid -- java.util.List::size : this.authorities.size() 
class UserAttributeEditor extends java.beans.PropertyEditorSupport   {
  setAsText(s : java.lang.String) : void
}
org.springframework.security.core.userdetails.memory.UserAttributeEditor::setAsText -- org.springframework.util.StringUtils::hasText : StringUtils.hasText(s) 
org.springframework.security.core.userdetails.memory.UserAttributeEditor::setAsText -- org.springframework.util.StringUtils::commaDelimitedListToStringArray : StringUtils.commaDelimitedListToStringArray(s) 
}
interface AuthenticationUserDetailsService    {
  loadUserDetails(token : org.springframework.security.core.userdetails.T) : org.springframework.security.core.userdetails.UserDetails
}
class MapReactiveUserDetailsService  implements org.springframework.security.core.userdetails.ReactiveUserDetailsService,ReactiveUserDetailsPasswordService  {
  users : java.util.Map
  MapReactiveUserDetailsService(users : java.util.Map) : None
  MapReactiveUserDetailsService() : None
  MapReactiveUserDetailsService(users : java.util.Collection) : None
  findByUsername(username : java.lang.String) : reactor.core.publisher.Mono
  updatePassword(user : org.springframework.security.core.userdetails.UserDetails, newPassword : java.lang.String) : reactor.core.publisher.Mono
  withNewPassword(userDetails : org.springframework.security.core.userdetails.UserDetails, newPassword : java.lang.String) : org.springframework.security.core.userdetails.UserDetails
  getKey(username : java.lang.String) : java.lang.String
}
org.springframework.security.core.userdetails.MapReactiveUserDetailsService::MapReactiveUserDetailsService -- java.util.Arrays::asList : Arrays.asList(users) 
org.springframework.security.core.userdetails.MapReactiveUserDetailsService::MapReactiveUserDetailsService -- org.springframework.util.Assert::notEmpty : Assert.notEmpty(users,"users cannot be null or empty") 
org.springframework.security.core.userdetails.MapReactiveUserDetailsService::MapReactiveUserDetailsService -- java.util.Map::put : this.users.put(getKey(user.getUsername()),user) 
org.springframework.security.core.userdetails.MapReactiveUserDetailsService::findByUsername -- java.util.Map::get : this.users.get(key) 
org.springframework.security.core.userdetails.MapReactiveUserDetailsService::findByUsername -- reactor.core.publisher.Mono::just : Mono.just(User.withUserDetails(result).build()) 
org.springframework.security.core.userdetails.MapReactiveUserDetailsService::findByUsername -- org.springframework.security.core.userdetails.User::withUserDetails : User.withUserDetails(result).build() 
org.springframework.security.core.userdetails.MapReactiveUserDetailsService::findByUsername -- org.springframework.security.core.userdetails.User::withUserDetails : User.withUserDetails(result) 
org.springframework.security.core.userdetails.MapReactiveUserDetailsService::findByUsername -- reactor.core.publisher.Mono::empty : Mono.empty() 
org.springframework.security.core.userdetails.MapReactiveUserDetailsService::updatePassword -- reactor.core.publisher.Mono::just : Mono.just(user).map((userDetails)->withNewPassword(userDetails,newPassword)).doOnNext((userDetails)->{Stringkey=getKey(user.getUsername());this.users.put(key,userDetails);}) 
org.springframework.security.core.userdetails.MapReactiveUserDetailsService::updatePassword -- reactor.core.publisher.Mono::just : Mono.just(user).map((userDetails)->withNewPassword(userDetails,newPassword)) 
org.springframework.security.core.userdetails.MapReactiveUserDetailsService::updatePassword -- reactor.core.publisher.Mono::just : Mono.just(user) 
org.springframework.security.core.userdetails.MapReactiveUserDetailsService::updatePassword -- org.springframework.security.core.userdetails.UserDetails::getUsername : user.getUsername() 
org.springframework.security.core.userdetails.MapReactiveUserDetailsService::updatePassword -- java.util.Map::put : this.users.put(key,userDetails) 
org.springframework.security.core.userdetails.MapReactiveUserDetailsService::withNewPassword -- org.springframework.security.core.userdetails.User::withUserDetails : User.withUserDetails(userDetails).password(newPassword).build() 
org.springframework.security.core.userdetails.MapReactiveUserDetailsService::withNewPassword -- org.springframework.security.core.userdetails.User::withUserDetails : User.withUserDetails(userDetails).password(newPassword) 
org.springframework.security.core.userdetails.MapReactiveUserDetailsService::withNewPassword -- org.springframework.security.core.userdetails.User::withUserDetails : User.withUserDetails(userDetails) 
org.springframework.security.core.userdetails.MapReactiveUserDetailsService::getKey -- java.lang.String::toLowerCase : username.toLowerCase(Locale.ROOT) 
interface ReactiveUserDetailsPasswordService    {
  updatePassword(user : org.springframework.security.core.userdetails.UserDetails, newPassword : java.lang.String) : reactor.core.publisher.Mono
}
interface ReactiveUserDetailsService    {
  findByUsername(username : java.lang.String) : reactor.core.publisher.Mono
}
class User  implements org.springframework.security.core.userdetails.UserDetails,CredentialsContainer  {
  serialVersionUID : long
  logger : org.apache.commons.logging.Log
  password : java.lang.String
  username : java.lang.String
  authorities : java.util.Set
  accountNonExpired : boolean
  accountNonLocked : boolean
  credentialsNonExpired : boolean
  enabled : boolean
  User(username : java.lang.String, password : java.lang.String, authorities : java.util.Collection) : None
  User(username : java.lang.String, password : java.lang.String, enabled : boolean, accountNonExpired : boolean, credentialsNonExpired : boolean, accountNonLocked : boolean, authorities : java.util.Collection) : None
  getAuthorities() : java.util.Collection
  getPassword() : java.lang.String
  getUsername() : java.lang.String
  isEnabled() : boolean
  isAccountNonExpired() : boolean
  isAccountNonLocked() : boolean
  isCredentialsNonExpired() : boolean
  eraseCredentials() : void
  sortAuthorities(authorities : java.util.Collection) : java.util.SortedSet
  equals(obj : java.lang.Object) : boolean
  hashCode() : int
  toString() : java.lang.String
  withUsername(username : java.lang.String) : org.springframework.security.core.userdetails.UserBuilder
  builder() : org.springframework.security.core.userdetails.UserBuilder
  withDefaultPasswordEncoder() : org.springframework.security.core.userdetails.UserBuilder
  withUserDetails(userDetails : org.springframework.security.core.userdetails.UserDetails) : org.springframework.security.core.userdetails.UserBuilder
}
org.springframework.security.core.userdetails.User::User -- org.springframework.util.Assert::isTrue : Assert.isTrue(username!=null&&!"".equals(username)&&password!=null,"Cannot pass null or empty values to constructor") 
org.springframework.security.core.userdetails.User::User -- java.util.Collections::unmodifiableSet : Collections.unmodifiableSet(sortAuthorities(authorities)) 
org.springframework.security.core.userdetails.User::sortAuthorities -- org.springframework.util.Assert::notNull : Assert.notNull(authorities,"Cannot pass a null GrantedAuthority collection") 
org.springframework.security.core.userdetails.User::sortAuthorities -- org.springframework.util.Assert::notNull : Assert.notNull(grantedAuthority,"GrantedAuthority list cannot contain any null elements") 
org.springframework.security.core.userdetails.User::equals -- java.lang.String::equals : this.username.equals(user.getUsername()) 
org.springframework.security.core.userdetails.User::hashCode -- java.lang.String::hashCode : this.username.hashCode() 
org.springframework.security.core.userdetails.User::toString -- org.springframework.security.core.userdetails.User::getClass : getClass().getName() 
org.springframework.security.core.userdetails.User::withUsername -- org.springframework.security.core.userdetails.User::builder : builder().username(username) 
org.springframework.security.core.userdetails.User::withDefaultPasswordEncoder -- org.apache.commons.logging.Log::warn : logger.warn("User.withDefaultPasswordEncoder() is considered unsafe for production "+"and is only intended for sample applications.") 
org.springframework.security.core.userdetails.User::withDefaultPasswordEncoder -- org.springframework.security.crypto.factory.PasswordEncoderFactories::createDelegatingPasswordEncoder : PasswordEncoderFactories.createDelegatingPasswordEncoder() 
org.springframework.security.core.userdetails.User::withDefaultPasswordEncoder -- org.springframework.security.core.userdetails.User::builder : builder().passwordEncoder(encoder::encode) 
org.springframework.security.core.userdetails.User::withUserDetails -- org.springframework.security.core.userdetails.User::withUsername : withUsername(userDetails.getUsername()).password(userDetails.getPassword()).accountExpired(!userDetails.isAccountNonExpired()).accountLocked(!userDetails.isAccountNonLocked()).authorities(userDetails.getAuthorities()).credentialsExpired(!userDetails.isCredentialsNonExpired()).disabled(!userDetails.isEnabled()) 
org.springframework.security.core.userdetails.User::withUserDetails -- org.springframework.security.core.userdetails.User::withUsername : withUsername(userDetails.getUsername()).password(userDetails.getPassword()).accountExpired(!userDetails.isAccountNonExpired()).accountLocked(!userDetails.isAccountNonLocked()).authorities(userDetails.getAuthorities()).credentialsExpired(!userDetails.isCredentialsNonExpired()) 
org.springframework.security.core.userdetails.User::withUserDetails -- org.springframework.security.core.userdetails.User::withUsername : withUsername(userDetails.getUsername()).password(userDetails.getPassword()).accountExpired(!userDetails.isAccountNonExpired()).accountLocked(!userDetails.isAccountNonLocked()).authorities(userDetails.getAuthorities()) 
org.springframework.security.core.userdetails.User::withUserDetails -- org.springframework.security.core.userdetails.User::withUsername : withUsername(userDetails.getUsername()).password(userDetails.getPassword()).accountExpired(!userDetails.isAccountNonExpired()).accountLocked(!userDetails.isAccountNonLocked()) 
org.springframework.security.core.userdetails.User::withUserDetails -- org.springframework.security.core.userdetails.User::withUsername : withUsername(userDetails.getUsername()).password(userDetails.getPassword()).accountExpired(!userDetails.isAccountNonExpired()) 
org.springframework.security.core.userdetails.User::withUserDetails -- org.springframework.security.core.userdetails.User::withUsername : withUsername(userDetails.getUsername()).password(userDetails.getPassword()) 
org.springframework.security.core.userdetails.User::withUserDetails -- org.springframework.security.core.userdetails.UserDetails::getUsername : userDetails.getUsername() 
org.springframework.security.core.userdetails.User::withUserDetails -- org.springframework.security.core.userdetails.UserDetails::getPassword : userDetails.getPassword() 
org.springframework.security.core.userdetails.User::withUserDetails -- org.springframework.security.core.userdetails.UserDetails::isAccountNonExpired : userDetails.isAccountNonExpired() 
org.springframework.security.core.userdetails.User::withUserDetails -- org.springframework.security.core.userdetails.UserDetails::isAccountNonLocked : userDetails.isAccountNonLocked() 
org.springframework.security.core.userdetails.User::withUserDetails -- org.springframework.security.core.userdetails.UserDetails::getAuthorities : userDetails.getAuthorities() 
org.springframework.security.core.userdetails.User::withUserDetails -- org.springframework.security.core.userdetails.UserDetails::isCredentialsNonExpired : userDetails.isCredentialsNonExpired() 
org.springframework.security.core.userdetails.User::withUserDetails -- org.springframework.security.core.userdetails.UserDetails::isEnabled : userDetails.isEnabled() 
class AuthorityComparator  implements org.springframework.security.core.userdetails.Comparator  {
  serialVersionUID : long
  compare(g1 : org.springframework.security.core.userdetails.GrantedAuthority, g2 : org.springframework.security.core.userdetails.GrantedAuthority) : int
}
org.springframework.security.core.userdetails.AuthorityComparator::compare -- org.springframework.security.core.userdetails.GrantedAuthority::getAuthority : g2.getAuthority() 
org.springframework.security.core.userdetails.AuthorityComparator::compare -- org.springframework.security.core.userdetails.GrantedAuthority::getAuthority : g1.getAuthority() 
org.springframework.security.core.userdetails.AuthorityComparator::compare -- org.springframework.security.core.userdetails.GrantedAuthority::getAuthority : g1.getAuthority().compareTo(g2.getAuthority()) 
org.springframework.security.core.userdetails.AuthorityComparator::compare -- org.springframework.security.core.userdetails.GrantedAuthority::getAuthority : g1.getAuthority() 
org.springframework.security.core.userdetails.AuthorityComparator::compare -- org.springframework.security.core.userdetails.GrantedAuthority::getAuthority : g2.getAuthority() 
class UserBuilder    {
  username : java.lang.String
  password : java.lang.String
  authorities : org.springframework.security.core.userdetails.List
  accountExpired : boolean
  accountLocked : boolean
  credentialsExpired : boolean
  disabled : boolean
  passwordEncoder : org.springframework.security.core.userdetails.Function
  UserBuilder() : None
  username(username : java.lang.String) : org.springframework.security.core.userdetails.UserBuilder
  password(password : java.lang.String) : org.springframework.security.core.userdetails.UserBuilder
  passwordEncoder(encoder : org.springframework.security.core.userdetails.Function) : org.springframework.security.core.userdetails.UserBuilder
  roles() : org.springframework.security.core.userdetails.UserBuilder
  authorities() : org.springframework.security.core.userdetails.UserBuilder
  authorities(authorities : org.springframework.security.core.userdetails.Collection) : org.springframework.security.core.userdetails.UserBuilder
  authorities() : org.springframework.security.core.userdetails.UserBuilder
  accountExpired(accountExpired : boolean) : org.springframework.security.core.userdetails.UserBuilder
  accountLocked(accountLocked : boolean) : org.springframework.security.core.userdetails.UserBuilder
  credentialsExpired(credentialsExpired : boolean) : org.springframework.security.core.userdetails.UserBuilder
  disabled(disabled : boolean) : org.springframework.security.core.userdetails.UserBuilder
  build() : org.springframework.security.core.userdetails.UserDetails
}
org.springframework.security.core.userdetails.UserBuilder::username -- org.springframework.security.core.userdetails.Assert::notNull : Assert.notNull(username,"username cannot be null") 
org.springframework.security.core.userdetails.UserBuilder::password -- org.springframework.security.core.userdetails.Assert::notNull : Assert.notNull(password,"password cannot be null") 
org.springframework.security.core.userdetails.UserBuilder::passwordEncoder -- org.springframework.security.core.userdetails.Assert::notNull : Assert.notNull(encoder,"encoder cannot be null") 
org.springframework.security.core.userdetails.UserBuilder::roles -- org.springframework.security.core.userdetails.Assert::isTrue : Assert.isTrue(!role.startsWith("ROLE_"),()->role+" cannot start with ROLE_ (it is automatically added)") 
org.springframework.security.core.userdetails.UserBuilder::roles -- org.springframework.security.core.userdetails.List::add : authorities.add(newSimpleGrantedAuthority("ROLE_"+role)) 
org.springframework.security.core.userdetails.UserBuilder::authorities -- org.springframework.security.core.userdetails.Assert::notNull : Assert.notNull(authorities,"authorities cannot be null") 
org.springframework.security.core.userdetails.UserBuilder::authorities -- org.springframework.security.core.userdetails.Arrays::asList : Arrays.asList(authorities) 
org.springframework.security.core.userdetails.UserBuilder::authorities -- org.springframework.security.core.userdetails.Assert::notNull : Assert.notNull(authorities,"authorities cannot be null") 
org.springframework.security.core.userdetails.UserBuilder::authorities -- org.springframework.security.core.userdetails.Assert::notNull : Assert.notNull(authorities,"authorities cannot be null") 
org.springframework.security.core.userdetails.UserBuilder::authorities -- org.springframework.security.core.userdetails.AuthorityUtils::createAuthorityList : AuthorityUtils.createAuthorityList(authorities) 
org.springframework.security.core.userdetails.UserBuilder::build -- org.springframework.security.core.userdetails.Function::apply : this.passwordEncoder.apply(this.password) 
interface UserCache    {
  getUserFromCache(username : java.lang.String) : org.springframework.security.core.userdetails.UserDetails
  putUserInCache(user : org.springframework.security.core.userdetails.UserDetails) : void
  removeUserFromCache(username : java.lang.String) : void
}
interface UserDetails    {
  getAuthorities() : java.util.Collection
  getPassword() : java.lang.String
  getUsername() : java.lang.String
  isAccountNonExpired() : boolean
  isAccountNonLocked() : boolean
  isCredentialsNonExpired() : boolean
  isEnabled() : boolean
}
class UserDetailsByNameServiceWrapper  implements org.springframework.security.core.userdetails.AuthenticationUserDetailsService  {
  userDetailsService : org.springframework.security.core.userdetails.UserDetailsService
  UserDetailsByNameServiceWrapper() : None
  UserDetailsByNameServiceWrapper(userDetailsService : org.springframework.security.core.userdetails.UserDetailsService) : None
  afterPropertiesSet() : void
  loadUserDetails(authentication : org.springframework.security.core.userdetails.T) : org.springframework.security.core.userdetails.UserDetails
  setUserDetailsService(aUserDetailsService : org.springframework.security.core.userdetails.UserDetailsService) : void
}
org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper::UserDetailsByNameServiceWrapper -- org.springframework.util.Assert::notNull : Assert.notNull(userDetailsService,"userDetailsService cannot be null.") 
org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper::afterPropertiesSet -- org.springframework.util.Assert::notNull : Assert.notNull(this.userDetailsService,"UserDetailsService must be set") 
org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper::loadUserDetails -- org.springframework.security.core.userdetails.UserDetailsService::loadUserByUsername : this.userDetailsService.loadUserByUsername(authentication.getName()) 
org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper::loadUserDetails -- org.springframework.security.core.userdetails.T::getName : authentication.getName() 
interface UserDetailsChecker    {
  check(toCheck : org.springframework.security.core.userdetails.UserDetails) : void
}
interface UserDetailsPasswordService    {
  updatePassword(user : org.springframework.security.core.userdetails.UserDetails, newPassword : java.lang.String) : org.springframework.security.core.userdetails.UserDetails
}
interface UserDetailsService    {
  loadUserByUsername(username : java.lang.String) : org.springframework.security.core.userdetails.UserDetails
}
class UsernameNotFoundException extends org.springframework.security.core.AuthenticationException   {
  serialVersionUID : long
  UsernameNotFoundException(msg : java.lang.String) : None
  UsernameNotFoundException(msg : java.lang.String, cause : java.lang.Throwable) : None
}
}
interface AuthenticatedPrincipal    {
  getName() : java.lang.String
}
interface Authentication    {
  getAuthorities() : java.util.Collection
  getCredentials() : java.lang.Object
  getDetails() : java.lang.Object
  getPrincipal() : java.lang.Object
  isAuthenticated() : boolean
  setAuthenticated(isAuthenticated : boolean) : void
}
class AuthenticationException extends org.springframework.security.core.RuntimeException   {
  serialVersionUID : long
  AuthenticationException(msg : java.lang.String, cause : java.lang.Throwable) : None
  AuthenticationException(msg : java.lang.String) : None
}
class ComparableVersion  implements org.springframework.security.core.Comparable  {
  MAX_INT_ITEM_LENGTH : int
  MAX_LONG_ITEM_LENGTH : int
  value : java.lang.String
  canonical : java.lang.String
  items : org.springframework.security.core.ListItem
}
interface Item    {
  compareTo(item : org.springframework.security.core.Item) : int
  getType() : int
  isNull() : boolean
}
class IntItem  implements org.springframework.security.core.Item  {
  value : int
  ZERO : org.springframework.security.core.IntItem
  IntItem() : None
  IntItem(str : java.lang.String) : None
  getType() : int
  isNull() : boolean
  compareTo(item : org.springframework.security.core.Item) : int
  equals(o : java.lang.Object) : boolean
  hashCode() : int
  toString() : java.lang.String
}
org.springframework.security.core.IntItem::IntItem -- java.lang.Integer::parseInt : Integer.parseInt(str) 
org.springframework.security.core.IntItem::compareTo -- org.springframework.security.core.Item::getType : item.getType() 
org.springframework.security.core.IntItem::compareTo -- java.lang.Integer::compare : Integer.compare(value,((IntItem)item).value) 
org.springframework.security.core.IntItem::compareTo -- org.springframework.security.core.Item::getClass : item.getClass() 
org.springframework.security.core.IntItem::equals -- java.lang.Object::getClass : o.getClass() 
org.springframework.security.core.IntItem::toString -- java.lang.Integer::toString : Integer.toString(value) 
class LongItem  implements org.springframework.security.core.Item  {
  value : long
  LongItem(str : java.lang.String) : None
  getType() : int
  isNull() : boolean
  compareTo(item : org.springframework.security.core.Item) : int
  equals(o : java.lang.Object) : boolean
  hashCode() : int
  toString() : java.lang.String
}
org.springframework.security.core.LongItem::LongItem -- java.lang.Long::parseLong : Long.parseLong(str) 
org.springframework.security.core.LongItem::compareTo -- org.springframework.security.core.Item::getType : item.getType() 
org.springframework.security.core.LongItem::compareTo -- java.lang.Long::compare : Long.compare(value,((LongItem)item).value) 
org.springframework.security.core.LongItem::compareTo -- org.springframework.security.core.Item::getClass : item.getClass() 
org.springframework.security.core.LongItem::equals -- java.lang.Object::getClass : o.getClass() 
org.springframework.security.core.LongItem::toString -- java.lang.Long::toString : Long.toString(value) 
class BigIntegerItem  implements org.springframework.security.core.Item  {
  value : org.springframework.security.core.BigInteger
  BigIntegerItem(str : java.lang.String) : None
  getType() : int
  isNull() : boolean
  compareTo(item : org.springframework.security.core.Item) : int
  equals(o : java.lang.Object) : boolean
  hashCode() : int
  toString() : java.lang.String
}
org.springframework.security.core.BigIntegerItem::compareTo -- org.springframework.security.core.Item::getType : item.getType() 
org.springframework.security.core.BigIntegerItem::compareTo -- org.springframework.security.core.BigInteger::compareTo : value.compareTo(((BigIntegerItem)item).value) 
org.springframework.security.core.BigIntegerItem::compareTo -- org.springframework.security.core.Item::getClass : item.getClass() 
org.springframework.security.core.BigIntegerItem::equals -- java.lang.Object::getClass : o.getClass() 
org.springframework.security.core.BigIntegerItem::equals -- org.springframework.security.core.BigInteger::equals : value.equals(that.value) 
org.springframework.security.core.BigIntegerItem::hashCode -- org.springframework.security.core.BigInteger::hashCode : value.hashCode() 
org.springframework.security.core.BigIntegerItem::toString -- org.springframework.security.core.BigInteger::toString : value.toString() 
class StringItem  implements org.springframework.security.core.Item  {
  QUALIFIERS : org.springframework.security.core.List
  ALIASES : org.springframework.security.core.Properties
  RELEASE_VERSION_INDEX : java.lang.String
  value : java.lang.String
  StringItem(value : java.lang.String, followedByDigit : boolean) : None
  getType() : int
  isNull() : boolean
  comparableQualifier(qualifier : java.lang.String) : java.lang.String
  compareTo(item : org.springframework.security.core.Item) : int
  equals(o : java.lang.Object) : boolean
  hashCode() : int
  toString() : java.lang.String
}
org.springframework.security.core.StringItem::StringItem -- java.lang.String::length : value.length() 
org.springframework.security.core.StringItem::StringItem -- java.lang.String::charAt : value.charAt(0) 
org.springframework.security.core.StringItem::StringItem -- org.springframework.security.core.ALIASES::getProperty : ALIASES.getProperty(value,value) 
org.springframework.security.core.StringItem::isNull -- org.springframework.security.core.StringItem::comparableQualifier : comparableQualifier(value).compareTo(RELEASE_VERSION_INDEX) 
org.springframework.security.core.StringItem::comparableQualifier -- org.springframework.security.core.QUALIFIERS::indexOf : QUALIFIERS.indexOf(qualifier) 
org.springframework.security.core.StringItem::comparableQualifier -- org.springframework.security.core.QUALIFIERS::size : QUALIFIERS.size() 
org.springframework.security.core.StringItem::comparableQualifier -- java.lang.String::valueOf : String.valueOf(i) 
org.springframework.security.core.StringItem::compareTo -- org.springframework.security.core.StringItem::comparableQualifier : comparableQualifier(value).compareTo(RELEASE_VERSION_INDEX) 
org.springframework.security.core.StringItem::compareTo -- org.springframework.security.core.Item::getType : item.getType() 
org.springframework.security.core.StringItem::compareTo -- org.springframework.security.core.StringItem::comparableQualifier : comparableQualifier(value).compareTo(comparableQualifier(((StringItem)item).value)) 
org.springframework.security.core.StringItem::compareTo -- org.springframework.security.core.Item::getClass : item.getClass() 
org.springframework.security.core.StringItem::equals -- java.lang.Object::getClass : o.getClass() 
org.springframework.security.core.StringItem::equals -- java.lang.String::equals : value.equals(that.value) 
org.springframework.security.core.StringItem::hashCode -- java.lang.String::hashCode : value.hashCode() 
class ListItem extends org.springframework.security.core.ArrayList implements org.springframework.security.core.Item  {
  getType() : int
  isNull() : boolean
  normalize() : void
  compareTo(item : org.springframework.security.core.Item) : int
  toString() : java.lang.String
  ComparableVersion(version : java.lang.String) : None
  parseVersion(version : java.lang.String) : void
  parseItem(isDigit : boolean, buf : java.lang.String) : org.springframework.security.core.Item
  stripLeadingZeroes(buf : java.lang.String) : java.lang.String
  compareTo(o : org.springframework.security.core.ComparableVersion) : int
  toString() : java.lang.String
  getCanonical() : java.lang.String
  equals(o : java.lang.Object) : boolean
  hashCode() : int
  main() : void
}
org.springframework.security.core.ListItem::compareTo -- org.springframework.security.core.Item::getType : item.getType() 
org.springframework.security.core.ListItem::compareTo -- org.springframework.security.core.Item::getClass : item.getClass() 
org.springframework.security.core.ListItem::parseVersion -- java.lang.String::toLowerCase : version.toLowerCase(Locale.ENGLISH) 
org.springframework.security.core.ListItem::parseVersion -- java.lang.String::length : version.length() 
org.springframework.security.core.ListItem::parseVersion -- java.lang.String::charAt : version.charAt(i) 
org.springframework.security.core.ListItem::parseVersion -- java.lang.String::substring : version.substring(startIndex,i) 
org.springframework.security.core.ListItem::parseVersion -- java.lang.String::substring : version.substring(startIndex,i) 
org.springframework.security.core.ListItem::parseVersion -- org.springframework.security.core.Character::isDigit : Character.isDigit(c) 
org.springframework.security.core.ListItem::parseVersion -- java.lang.String::substring : version.substring(startIndex,i) 
org.springframework.security.core.ListItem::parseVersion -- java.lang.String::substring : version.substring(startIndex,i) 
org.springframework.security.core.ListItem::parseVersion -- java.lang.String::length : version.length() 
org.springframework.security.core.ListItem::parseVersion -- java.lang.String::substring : version.substring(startIndex) 
org.springframework.security.core.ListItem::parseItem -- java.lang.String::length : buf.length() 
org.springframework.security.core.ListItem::parseItem -- java.lang.String::length : buf.length() 
org.springframework.security.core.ListItem::stripLeadingZeroes -- java.lang.String::isEmpty : buf.isEmpty() 
org.springframework.security.core.ListItem::stripLeadingZeroes -- java.lang.String::length : buf.length() 
org.springframework.security.core.ListItem::stripLeadingZeroes -- java.lang.String::charAt : buf.charAt(i) 
org.springframework.security.core.ListItem::stripLeadingZeroes -- java.lang.String::substring : buf.substring(i) 
org.springframework.security.core.ListItem::main -- java.lang.String::valueOf : String.valueOf(i++) 
interface CredentialsContainer    {
  eraseCredentials() : void
}
interface GrantedAuthority    {
  getAuthority() : java.lang.String
}
class SpringSecurityCoreVersion    {
  DISABLE_CHECKS : java.lang.String
  logger : org.apache.commons.logging.Log
  SERIAL_VERSION_UID : long
  MIN_SPRING_VERSION : java.lang.String
  SpringSecurityCoreVersion() : None
  performVersionChecks() : void
  performVersionChecks(minSpringVersion : java.lang.String) : void
  getVersion() : java.lang.String
  disableChecks(springVersion : java.lang.String, springSecurityVersion : java.lang.String) : boolean
  getSpringVersion() : java.lang.String
}
org.springframework.security.core.SpringSecurityCoreVersion::performVersionChecks -- org.springframework.core.SpringVersion::getVersion : SpringVersion.getVersion() 
org.springframework.security.core.SpringSecurityCoreVersion::performVersionChecks -- org.apache.commons.logging.Log::info : logger.info("You are running with Spring Security Core "+version) 
org.springframework.security.core.SpringSecurityCoreVersion::performVersionChecks -- org.springframework.security.core.SpringSecurityCoreVersion::newComparableVersion : newComparableVersion(springVersion).compareTo(newComparableVersion(minSpringVersion)) 
org.springframework.security.core.SpringSecurityCoreVersion::performVersionChecks -- org.apache.commons.logging.Log::warn : logger.warn("**** You are advised to use Spring "+minSpringVersion+" or later with this version. You are running: "+springVersion) 
org.springframework.security.core.SpringSecurityCoreVersion::disableChecks -- java.lang.String::equals : springVersion.equals(springSecurityVersion) 
org.springframework.security.core.SpringSecurityCoreVersion::disableChecks -- org.springframework.security.core.Boolean::getBoolean : Boolean.getBoolean(DISABLE_CHECKS) 
class SpringSecurityMessageSource extends org.springframework.context.support.ResourceBundleMessageSource   {
  SpringSecurityMessageSource() : None
  getAccessor() : org.springframework.context.support.MessageSourceAccessor
}
}
package jackson2 {
class AbstractUnmodifiableCollectionDeserializer extends com.fasterxml.jackson.databind.JsonDeserializer   {
  deserialize(jp : com.fasterxml.jackson.core.JsonParser, ctxt : com.fasterxml.jackson.databind.DeserializationContext) : org.springframework.security.jackson2.T
  createUnmodifiableCollection(values : java.util.Collection) : org.springframework.security.jackson2.T
}
org.springframework.security.jackson2.AbstractUnmodifiableCollectionDeserializer::deserialize -- com.fasterxml.jackson.core.JsonParser::getCodec : jp.getCodec() 
class AnonymousAuthenticationTokenMixin    {
  AnonymousAuthenticationTokenMixin(keyHash : java.lang.Integer, principal : java.lang.Object, authorities : java.util.Collection) : None
}
class BadCredentialsExceptionMixin    {
  BadCredentialsExceptionMixin(message : java.lang.String) : None
}
class CoreJackson2Module extends com.fasterxml.jackson.databind.module.SimpleModule   {
  CoreJackson2Module() : None
  setupModule(context : org.springframework.security.jackson2.SetupContext) : void
}
org.springframework.security.jackson2.CoreJackson2Module::setupModule -- org.springframework.security.jackson2.SecurityJackson2Modules::enableDefaultTyping : SecurityJackson2Modules.enableDefaultTyping(context.getOwner()) 
org.springframework.security.jackson2.CoreJackson2Module::setupModule -- org.springframework.security.jackson2.SetupContext::getOwner : context.getOwner() 
org.springframework.security.jackson2.CoreJackson2Module::setupModule -- org.springframework.security.jackson2.SetupContext::setMixInAnnotations : context.setMixInAnnotations(AnonymousAuthenticationToken.class,AnonymousAuthenticationTokenMixin.class) 
org.springframework.security.jackson2.CoreJackson2Module::setupModule -- org.springframework.security.jackson2.SetupContext::setMixInAnnotations : context.setMixInAnnotations(RememberMeAuthenticationToken.class,RememberMeAuthenticationTokenMixin.class) 
org.springframework.security.jackson2.CoreJackson2Module::setupModule -- org.springframework.security.jackson2.SetupContext::setMixInAnnotations : context.setMixInAnnotations(SimpleGrantedAuthority.class,SimpleGrantedAuthorityMixin.class) 
org.springframework.security.jackson2.CoreJackson2Module::setupModule -- org.springframework.security.jackson2.SetupContext::setMixInAnnotations : context.setMixInAnnotations(Collections.unmodifiableSet(Collections.emptySet()).getClass(),UnmodifiableSetMixin.class) 
org.springframework.security.jackson2.CoreJackson2Module::setupModule -- java.util.Collections::unmodifiableSet : Collections.unmodifiableSet(Collections.emptySet()).getClass() 
org.springframework.security.jackson2.CoreJackson2Module::setupModule -- java.util.Collections::unmodifiableSet : Collections.unmodifiableSet(Collections.emptySet()) 
org.springframework.security.jackson2.CoreJackson2Module::setupModule -- java.util.Collections::emptySet : Collections.emptySet() 
org.springframework.security.jackson2.CoreJackson2Module::setupModule -- org.springframework.security.jackson2.SetupContext::setMixInAnnotations : context.setMixInAnnotations(Collections.unmodifiableList(Collections.emptyList()).getClass(),UnmodifiableListMixin.class) 
org.springframework.security.jackson2.CoreJackson2Module::setupModule -- java.util.Collections::unmodifiableList : Collections.unmodifiableList(Collections.emptyList()).getClass() 
org.springframework.security.jackson2.CoreJackson2Module::setupModule -- java.util.Collections::unmodifiableList : Collections.unmodifiableList(Collections.emptyList()) 
org.springframework.security.jackson2.CoreJackson2Module::setupModule -- java.util.Collections::emptyList : Collections.emptyList() 
org.springframework.security.jackson2.CoreJackson2Module::setupModule -- org.springframework.security.jackson2.SetupContext::setMixInAnnotations : context.setMixInAnnotations(Collections.unmodifiableMap(Collections.emptyMap()).getClass(),UnmodifiableMapMixin.class) 
org.springframework.security.jackson2.CoreJackson2Module::setupModule -- java.util.Collections::unmodifiableMap : Collections.unmodifiableMap(Collections.emptyMap()).getClass() 
org.springframework.security.jackson2.CoreJackson2Module::setupModule -- java.util.Collections::unmodifiableMap : Collections.unmodifiableMap(Collections.emptyMap()) 
org.springframework.security.jackson2.CoreJackson2Module::setupModule -- java.util.Collections::emptyMap : Collections.emptyMap() 
org.springframework.security.jackson2.CoreJackson2Module::setupModule -- org.springframework.security.jackson2.SetupContext::setMixInAnnotations : context.setMixInAnnotations(User.class,UserMixin.class) 
org.springframework.security.jackson2.CoreJackson2Module::setupModule -- org.springframework.security.jackson2.SetupContext::setMixInAnnotations : context.setMixInAnnotations(UsernamePasswordAuthenticationToken.class,UsernamePasswordAuthenticationTokenMixin.class) 
org.springframework.security.jackson2.CoreJackson2Module::setupModule -- org.springframework.security.jackson2.SetupContext::setMixInAnnotations : context.setMixInAnnotations(BadCredentialsException.class,BadCredentialsExceptionMixin.class) 
class RememberMeAuthenticationTokenMixin    {
  RememberMeAuthenticationTokenMixin(keyHash : java.lang.Integer, principal : java.lang.Object, authorities : java.util.Collection) : None
}
class SecurityJackson2Modules    {
  logger : org.apache.commons.logging.Log
  securityJackson2ModuleClasses : java.util.List
  webServletJackson2ModuleClass : java.lang.String
  oauth2ClientJackson2ModuleClass : java.lang.String
  javaTimeJackson2ModuleClass : java.lang.String
  ldapJackson2ModuleClass : java.lang.String
  saml2Jackson2ModuleClass : java.lang.String
  casJackson2ModuleClass : java.lang.String
  webServletPresent : boolean
  oauth2ClientPresent : boolean
  javaTimeJacksonPresent : boolean
  ldapJacksonPresent : boolean
  saml2JacksonPresent : boolean
  casJacksonPresent : boolean
  SecurityJackson2Modules() : None
  enableDefaultTyping(mapper : com.fasterxml.jackson.databind.ObjectMapper) : void
  loadAndGetInstance(className : java.lang.String, loader : org.springframework.security.jackson2.ClassLoader) : com.fasterxml.jackson.databind.Module
  getModules(loader : org.springframework.security.jackson2.ClassLoader) : java.util.List
  addToModulesList(loader : org.springframework.security.jackson2.ClassLoader, modules : java.util.List, className : java.lang.String) : void
  createAllowlistedDefaultTyping() : com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder
}
org.springframework.security.jackson2.SecurityJackson2Modules::enableDefaultTyping -- com.fasterxml.jackson.databind.ObjectMapper::getDeserializationConfig : mapper.getDeserializationConfig().getDefaultTyper(null) 
org.springframework.security.jackson2.SecurityJackson2Modules::enableDefaultTyping -- com.fasterxml.jackson.databind.ObjectMapper::getDeserializationConfig : mapper.getDeserializationConfig() 
org.springframework.security.jackson2.SecurityJackson2Modules::enableDefaultTyping -- com.fasterxml.jackson.databind.ObjectMapper::setDefaultTyping : mapper.setDefaultTyping(createAllowlistedDefaultTyping()) 
org.springframework.security.jackson2.SecurityJackson2Modules::loadAndGetInstance -- org.springframework.util.ClassUtils::forName : ClassUtils.forName(className,loader) 
org.springframework.security.jackson2.SecurityJackson2Modules::loadAndGetInstance -- org.apache.commons.logging.Log::debug : logger.debug(LogMessage.format("Loaded module %s, now registering",className)) 
org.springframework.security.jackson2.SecurityJackson2Modules::loadAndGetInstance -- org.springframework.core.log.LogMessage::format : LogMessage.format("Loaded module %s, now registering",className) 
org.springframework.security.jackson2.SecurityJackson2Modules::loadAndGetInstance -- org.apache.commons.logging.Log::debug : logger.debug(LogMessage.format("Cannot load module %s",className),ex) 
org.springframework.security.jackson2.SecurityJackson2Modules::loadAndGetInstance -- org.springframework.core.log.LogMessage::format : LogMessage.format("Cannot load module %s",className) 
org.springframework.security.jackson2.SecurityJackson2Modules::addToModulesList -- java.util.List::add : modules.add(module) 
class AllowlistTypeResolverBuilder extends org.springframework.security.jackson2.ObjectMapper.DefaultTypeResolverBuilder   {
  AllowlistTypeResolverBuilder(defaultTyping : org.springframework.security.jackson2.ObjectMapper.DefaultTyping) : None
  idResolver(config : org.springframework.security.jackson2.MapperConfig, baseType : org.springframework.security.jackson2.JavaType, subtypeValidator : org.springframework.security.jackson2.PolymorphicTypeValidator, subtypes : org.springframework.security.jackson2.Collection, forSer : boolean, forDeser : boolean) : org.springframework.security.jackson2.TypeIdResolver
}
org.springframework.security.jackson2.AllowlistTypeResolverBuilder::AllowlistTypeResolverBuilder -- org.springframework.security.jackson2.BasicPolymorphicTypeValidator::builder : BasicPolymorphicTypeValidator.builder().allowIfSubType(Object.class).build() 
org.springframework.security.jackson2.AllowlistTypeResolverBuilder::AllowlistTypeResolverBuilder -- org.springframework.security.jackson2.BasicPolymorphicTypeValidator::builder : BasicPolymorphicTypeValidator.builder().allowIfSubType(Object.class) 
org.springframework.security.jackson2.AllowlistTypeResolverBuilder::AllowlistTypeResolverBuilder -- org.springframework.security.jackson2.BasicPolymorphicTypeValidator::builder : BasicPolymorphicTypeValidator.builder() 
class AllowlistTypeIdResolver  implements org.springframework.security.jackson2.TypeIdResolver  {
  ALLOWLIST_CLASS_NAMES : org.springframework.security.jackson2.Set
  delegate : org.springframework.security.jackson2.TypeIdResolver
  AllowlistTypeIdResolver(delegate : org.springframework.security.jackson2.TypeIdResolver) : None
  init(baseType : org.springframework.security.jackson2.JavaType) : void
  idFromValue(value : java.lang.Object) : java.lang.String
  idFromValueAndType(value : java.lang.Object, suggestedType : java.lang.Class) : java.lang.String
  idFromBaseType() : java.lang.String
  typeFromId(context : org.springframework.security.jackson2.DatabindContext, id : java.lang.String) : org.springframework.security.jackson2.JavaType
  isInAllowlist(id : java.lang.String) : boolean
  getDescForKnownTypeIds() : java.lang.String
  getMechanism() : org.springframework.security.jackson2.JsonTypeInfo.Id
}
org.springframework.security.jackson2.AllowlistTypeIdResolver::init -- org.springframework.security.jackson2.TypeIdResolver::init : this.delegate.init(baseType) 
org.springframework.security.jackson2.AllowlistTypeIdResolver::idFromValue -- org.springframework.security.jackson2.TypeIdResolver::idFromValue : this.delegate.idFromValue(value) 
org.springframework.security.jackson2.AllowlistTypeIdResolver::idFromValueAndType -- org.springframework.security.jackson2.TypeIdResolver::idFromValueAndType : this.delegate.idFromValueAndType(value,suggestedType) 
org.springframework.security.jackson2.AllowlistTypeIdResolver::idFromBaseType -- org.springframework.security.jackson2.TypeIdResolver::idFromBaseType : this.delegate.idFromBaseType() 
org.springframework.security.jackson2.AllowlistTypeIdResolver::typeFromId -- org.springframework.security.jackson2.DatabindContext::getConfig : context.getConfig() 
org.springframework.security.jackson2.AllowlistTypeIdResolver::typeFromId -- org.springframework.security.jackson2.TypeIdResolver::typeFromId : this.delegate.typeFromId(context,id) 
org.springframework.security.jackson2.AllowlistTypeIdResolver::typeFromId -- org.springframework.security.jackson2.AnnotationUtils::findAnnotation : AnnotationUtils.findAnnotation(result.getRawClass(),JacksonAnnotation.class) 
org.springframework.security.jackson2.AllowlistTypeIdResolver::isInAllowlist -- org.springframework.security.jackson2.ALLOWLIST_CLASS_NAMES::contains : ALLOWLIST_CLASS_NAMES.contains(id) 
org.springframework.security.jackson2.AllowlistTypeIdResolver::getDescForKnownTypeIds -- org.springframework.security.jackson2.TypeIdResolver::getDescForKnownTypeIds : this.delegate.getDescForKnownTypeIds() 
org.springframework.security.jackson2.AllowlistTypeIdResolver::getMechanism -- org.springframework.security.jackson2.TypeIdResolver::getMechanism : this.delegate.getMechanism() 
class SimpleGrantedAuthorityMixin    {
  SimpleGrantedAuthorityMixin(role : java.lang.String) : None
}
class UnmodifiableListDeserializer extends org.springframework.security.jackson2.AbstractUnmodifiableCollectionDeserializer   {
  createUnmodifiableCollection(values : java.util.Collection) : java.util.List
}
org.springframework.security.jackson2.UnmodifiableListDeserializer::createUnmodifiableCollection -- java.util.Collections::unmodifiableList : Collections.unmodifiableList(newArrayList<>(values)) 
class UnmodifiableListMixin    {
  UnmodifiableListMixin(s : java.util.Set) : None
}
class UnmodifiableMapDeserializer extends com.fasterxml.jackson.databind.JsonDeserializer   {
  deserialize(jp : com.fasterxml.jackson.core.JsonParser, ctxt : com.fasterxml.jackson.databind.DeserializationContext) : java.util.Map
}
org.springframework.security.jackson2.UnmodifiableMapDeserializer::deserialize -- com.fasterxml.jackson.core.JsonParser::getCodec : jp.getCodec() 
org.springframework.security.jackson2.UnmodifiableMapDeserializer::deserialize -- java.util.Collections::unmodifiableMap : Collections.unmodifiableMap(result) 
class UnmodifiableMapMixin    {
  UnmodifiableMapMixin(map : java.util.Map) : None
}
class UnmodifiableSetDeserializer extends org.springframework.security.jackson2.AbstractUnmodifiableCollectionDeserializer   {
  createUnmodifiableCollection(values : java.util.Collection) : java.util.Set
}
org.springframework.security.jackson2.UnmodifiableSetDeserializer::createUnmodifiableCollection -- java.util.Collections::unmodifiableSet : Collections.unmodifiableSet(newHashSet<>(values)) 
class UnmodifiableSetMixin    {
  UnmodifiableSetMixin(s : java.util.Set) : None
}
class UserDeserializer extends com.fasterxml.jackson.databind.JsonDeserializer   {
  SIMPLE_GRANTED_AUTHORITY_SET : com.fasterxml.jackson.core.type.TypeReference
  deserialize(jp : com.fasterxml.jackson.core.JsonParser, ctxt : com.fasterxml.jackson.databind.DeserializationContext) : org.springframework.security.core.userdetails.User
  readJsonNode(jsonNode : com.fasterxml.jackson.databind.JsonNode, field : java.lang.String) : com.fasterxml.jackson.databind.JsonNode
}
org.springframework.security.jackson2.UserDeserializer::deserialize -- com.fasterxml.jackson.core.JsonParser::getCodec : jp.getCodec() 
org.springframework.security.jackson2.UserDeserializer::deserialize -- org.springframework.security.jackson2.UserDeserializer::readJsonNode : readJsonNode(jsonNode,"username").asText() 
org.springframework.security.jackson2.UserDeserializer::deserialize -- org.springframework.security.jackson2.UserDeserializer::readJsonNode : readJsonNode(jsonNode,"enabled").asBoolean() 
org.springframework.security.jackson2.UserDeserializer::deserialize -- org.springframework.security.jackson2.UserDeserializer::readJsonNode : readJsonNode(jsonNode,"accountNonExpired").asBoolean() 
org.springframework.security.jackson2.UserDeserializer::deserialize -- org.springframework.security.jackson2.UserDeserializer::readJsonNode : readJsonNode(jsonNode,"credentialsNonExpired").asBoolean() 
org.springframework.security.jackson2.UserDeserializer::deserialize -- org.springframework.security.jackson2.UserDeserializer::readJsonNode : readJsonNode(jsonNode,"accountNonLocked").asBoolean() 
org.springframework.security.jackson2.UserDeserializer::readJsonNode -- com.fasterxml.jackson.databind.JsonNode::has : jsonNode.has(field) 
org.springframework.security.jackson2.UserDeserializer::readJsonNode -- com.fasterxml.jackson.databind.JsonNode::get : jsonNode.get(field) 
org.springframework.security.jackson2.UserDeserializer::readJsonNode -- com.fasterxml.jackson.databind.node.MissingNode::getInstance : MissingNode.getInstance() 
class UserMixin    {
}
class UsernamePasswordAuthenticationTokenDeserializer extends com.fasterxml.jackson.databind.JsonDeserializer   {
  GRANTED_AUTHORITY_LIST : com.fasterxml.jackson.core.type.TypeReference
  OBJECT : com.fasterxml.jackson.core.type.TypeReference
  deserialize(jp : com.fasterxml.jackson.core.JsonParser, ctxt : com.fasterxml.jackson.databind.DeserializationContext) : org.springframework.security.authentication.UsernamePasswordAuthenticationToken
  getCredentials(credentialsNode : com.fasterxml.jackson.databind.JsonNode) : java.lang.Object
  getPrincipal(mapper : com.fasterxml.jackson.databind.ObjectMapper, principalNode : com.fasterxml.jackson.databind.JsonNode) : java.lang.Object
  readJsonNode(jsonNode : com.fasterxml.jackson.databind.JsonNode, field : java.lang.String) : com.fasterxml.jackson.databind.JsonNode
}
org.springframework.security.jackson2.UsernamePasswordAuthenticationTokenDeserializer::deserialize -- com.fasterxml.jackson.core.JsonParser::getCodec : jp.getCodec() 
org.springframework.security.jackson2.UsernamePasswordAuthenticationTokenDeserializer::deserialize -- org.springframework.security.jackson2.UsernamePasswordAuthenticationTokenDeserializer::readJsonNode : readJsonNode(jsonNode,"authenticated").asBoolean() 
org.springframework.security.jackson2.UsernamePasswordAuthenticationTokenDeserializer::deserialize -- org.springframework.security.jackson2.UsernamePasswordAuthenticationTokenDeserializer::readJsonNode : readJsonNode(jsonNode,"authorities").traverse(mapper) 
org.springframework.security.jackson2.UsernamePasswordAuthenticationTokenDeserializer::deserialize -- org.springframework.security.authentication.UsernamePasswordAuthenticationToken::unauthenticated : UsernamePasswordAuthenticationToken.unauthenticated(principal,credentials) 
org.springframework.security.jackson2.UsernamePasswordAuthenticationTokenDeserializer::deserialize -- org.springframework.security.authentication.UsernamePasswordAuthenticationToken::authenticated : UsernamePasswordAuthenticationToken.authenticated(principal,credentials,authorities) 
org.springframework.security.jackson2.UsernamePasswordAuthenticationTokenDeserializer::getCredentials -- com.fasterxml.jackson.databind.JsonNode::isNull : credentialsNode.isNull() 
org.springframework.security.jackson2.UsernamePasswordAuthenticationTokenDeserializer::getCredentials -- com.fasterxml.jackson.databind.JsonNode::isMissingNode : credentialsNode.isMissingNode() 
org.springframework.security.jackson2.UsernamePasswordAuthenticationTokenDeserializer::getCredentials -- com.fasterxml.jackson.databind.JsonNode::asText : credentialsNode.asText() 
org.springframework.security.jackson2.UsernamePasswordAuthenticationTokenDeserializer::getPrincipal -- com.fasterxml.jackson.databind.JsonNode::isObject : principalNode.isObject() 
org.springframework.security.jackson2.UsernamePasswordAuthenticationTokenDeserializer::getPrincipal -- com.fasterxml.jackson.databind.ObjectMapper::readValue : mapper.readValue(principalNode.traverse(mapper),Object.class) 
org.springframework.security.jackson2.UsernamePasswordAuthenticationTokenDeserializer::getPrincipal -- com.fasterxml.jackson.databind.JsonNode::traverse : principalNode.traverse(mapper) 
org.springframework.security.jackson2.UsernamePasswordAuthenticationTokenDeserializer::getPrincipal -- com.fasterxml.jackson.databind.JsonNode::asText : principalNode.asText() 
org.springframework.security.jackson2.UsernamePasswordAuthenticationTokenDeserializer::readJsonNode -- com.fasterxml.jackson.databind.JsonNode::has : jsonNode.has(field) 
org.springframework.security.jackson2.UsernamePasswordAuthenticationTokenDeserializer::readJsonNode -- com.fasterxml.jackson.databind.JsonNode::get : jsonNode.get(field) 
org.springframework.security.jackson2.UsernamePasswordAuthenticationTokenDeserializer::readJsonNode -- com.fasterxml.jackson.databind.node.MissingNode::getInstance : MissingNode.getInstance() 
class UsernamePasswordAuthenticationTokenMixin    {
}
}
package provisioning {
interface GroupManager    {
  findAllGroups() : java.util.List
  findUsersInGroup(groupName : java.lang.String) : java.util.List
  createGroup(groupName : java.lang.String, authorities : java.util.List) : void
  deleteGroup(groupName : java.lang.String) : void
  renameGroup(oldName : java.lang.String, newName : java.lang.String) : void
  addUserToGroup(username : java.lang.String, group : java.lang.String) : void
  removeUserFromGroup(username : java.lang.String, groupName : java.lang.String) : void
  findGroupAuthorities(groupName : java.lang.String) : java.util.List
  addGroupAuthority(groupName : java.lang.String, authority : org.springframework.security.core.GrantedAuthority) : void
  removeGroupAuthority(groupName : java.lang.String, authority : org.springframework.security.core.GrantedAuthority) : void
}
class InMemoryUserDetailsManager  implements org.springframework.security.provisioning.UserDetailsManager,UserDetailsPasswordService  {
  logger : org.apache.commons.logging.Log
  users : java.util.Map
  securityContextHolderStrategy : org.springframework.security.core.context.SecurityContextHolderStrategy
  authenticationManager : org.springframework.security.authentication.AuthenticationManager
  InMemoryUserDetailsManager() : None
  InMemoryUserDetailsManager(users : java.util.Collection) : None
  InMemoryUserDetailsManager() : None
  InMemoryUserDetailsManager(users : java.util.Properties) : None
  createUserDetails(name : java.lang.String, attr : org.springframework.security.core.userdetails.memory.UserAttribute) : org.springframework.security.core.userdetails.User
  createUser(user : org.springframework.security.core.userdetails.UserDetails) : void
  deleteUser(username : java.lang.String) : void
  updateUser(user : org.springframework.security.core.userdetails.UserDetails) : void
  userExists(username : java.lang.String) : boolean
  changePassword(oldPassword : java.lang.String, newPassword : java.lang.String) : void
  updatePassword(user : org.springframework.security.core.userdetails.UserDetails, newPassword : java.lang.String) : org.springframework.security.core.userdetails.UserDetails
  loadUserByUsername(username : java.lang.String) : org.springframework.security.core.userdetails.UserDetails
  setSecurityContextHolderStrategy(securityContextHolderStrategy : org.springframework.security.core.context.SecurityContextHolderStrategy) : void
  setAuthenticationManager(authenticationManager : org.springframework.security.authentication.AuthenticationManager) : void
}
org.springframework.security.provisioning.InMemoryUserDetailsManager::InMemoryUserDetailsManager -- java.util.Map::propertyNames : users.propertyNames() 
org.springframework.security.provisioning.InMemoryUserDetailsManager::InMemoryUserDetailsManager -- java.util.Map::getProperty : users.getProperty(name) 
org.springframework.security.provisioning.InMemoryUserDetailsManager::InMemoryUserDetailsManager -- org.springframework.util.Assert::notNull : Assert.notNull(attr,()->"The entry with username '"+name+"' could not be converted to an UserDetails") 
org.springframework.security.provisioning.InMemoryUserDetailsManager::createUserDetails -- org.springframework.security.core.userdetails.memory.UserAttribute::getPassword : attr.getPassword() 
org.springframework.security.provisioning.InMemoryUserDetailsManager::createUserDetails -- org.springframework.security.core.userdetails.memory.UserAttribute::isEnabled : attr.isEnabled() 
org.springframework.security.provisioning.InMemoryUserDetailsManager::createUserDetails -- org.springframework.security.core.userdetails.memory.UserAttribute::getAuthorities : attr.getAuthorities() 
org.springframework.security.provisioning.InMemoryUserDetailsManager::createUser -- org.springframework.util.Assert::isTrue : Assert.isTrue(!userExists(user.getUsername()),"user should not exist") 
org.springframework.security.provisioning.InMemoryUserDetailsManager::createUser -- org.springframework.security.core.userdetails.UserDetails::getUsername : user.getUsername() 
org.springframework.security.provisioning.InMemoryUserDetailsManager::createUser -- java.util.Map::put : this.users.put(user.getUsername().toLowerCase(Locale.ROOT),mutable) 
org.springframework.security.provisioning.InMemoryUserDetailsManager::createUser -- org.springframework.security.core.userdetails.UserDetails::getUsername : user.getUsername().toLowerCase(Locale.ROOT) 
org.springframework.security.provisioning.InMemoryUserDetailsManager::createUser -- org.springframework.security.core.userdetails.UserDetails::getUsername : user.getUsername() 
org.springframework.security.provisioning.InMemoryUserDetailsManager::createUser -- java.util.Map::put : this.users.put(user.getUsername().toLowerCase(Locale.ROOT),newMutableUser(user)) 
org.springframework.security.provisioning.InMemoryUserDetailsManager::createUser -- org.springframework.security.core.userdetails.UserDetails::getUsername : user.getUsername().toLowerCase(Locale.ROOT) 
org.springframework.security.provisioning.InMemoryUserDetailsManager::createUser -- org.springframework.security.core.userdetails.UserDetails::getUsername : user.getUsername() 
org.springframework.security.provisioning.InMemoryUserDetailsManager::deleteUser -- java.util.Map::remove : this.users.remove(username.toLowerCase(Locale.ROOT)) 
org.springframework.security.provisioning.InMemoryUserDetailsManager::deleteUser -- java.lang.String::toLowerCase : username.toLowerCase(Locale.ROOT) 
org.springframework.security.provisioning.InMemoryUserDetailsManager::updateUser -- org.springframework.util.Assert::isTrue : Assert.isTrue(userExists(user.getUsername()),"user should exist") 
org.springframework.security.provisioning.InMemoryUserDetailsManager::updateUser -- org.springframework.security.core.userdetails.UserDetails::getUsername : user.getUsername() 
org.springframework.security.provisioning.InMemoryUserDetailsManager::updateUser -- java.util.Map::put : this.users.put(user.getUsername().toLowerCase(Locale.ROOT),mutable) 
org.springframework.security.provisioning.InMemoryUserDetailsManager::updateUser -- org.springframework.security.core.userdetails.UserDetails::getUsername : user.getUsername().toLowerCase(Locale.ROOT) 
org.springframework.security.provisioning.InMemoryUserDetailsManager::updateUser -- org.springframework.security.core.userdetails.UserDetails::getUsername : user.getUsername() 
org.springframework.security.provisioning.InMemoryUserDetailsManager::updateUser -- java.util.Map::put : this.users.put(user.getUsername().toLowerCase(Locale.ROOT),newMutableUser(user)) 
org.springframework.security.provisioning.InMemoryUserDetailsManager::updateUser -- org.springframework.security.core.userdetails.UserDetails::getUsername : user.getUsername().toLowerCase(Locale.ROOT) 
org.springframework.security.provisioning.InMemoryUserDetailsManager::updateUser -- org.springframework.security.core.userdetails.UserDetails::getUsername : user.getUsername() 
org.springframework.security.provisioning.InMemoryUserDetailsManager::userExists -- java.util.Map::containsKey : this.users.containsKey(username.toLowerCase(Locale.ROOT)) 
org.springframework.security.provisioning.InMemoryUserDetailsManager::userExists -- java.lang.String::toLowerCase : username.toLowerCase(Locale.ROOT) 
org.springframework.security.provisioning.InMemoryUserDetailsManager::changePassword -- org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : this.securityContextHolderStrategy.getContext().getAuthentication() 
org.springframework.security.provisioning.InMemoryUserDetailsManager::changePassword -- org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : this.securityContextHolderStrategy.getContext() 
org.springframework.security.provisioning.InMemoryUserDetailsManager::changePassword -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.format("Changing password for user '%s'",username)) 
org.springframework.security.provisioning.InMemoryUserDetailsManager::changePassword -- org.springframework.core.log.LogMessage::format : LogMessage.format("Changing password for user '%s'",username) 
org.springframework.security.provisioning.InMemoryUserDetailsManager::changePassword -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.format("Reauthenticating user '%s' for password change request.",username)) 
org.springframework.security.provisioning.InMemoryUserDetailsManager::changePassword -- org.springframework.core.log.LogMessage::format : LogMessage.format("Reauthenticating user '%s' for password change request.",username) 
org.springframework.security.provisioning.InMemoryUserDetailsManager::changePassword -- org.springframework.security.authentication.AuthenticationManager::authenticate : this.authenticationManager.authenticate(UsernamePasswordAuthenticationToken.unauthenticated(username,oldPassword)) 
org.springframework.security.provisioning.InMemoryUserDetailsManager::changePassword -- org.springframework.security.authentication.UsernamePasswordAuthenticationToken::unauthenticated : UsernamePasswordAuthenticationToken.unauthenticated(username,oldPassword) 
org.springframework.security.provisioning.InMemoryUserDetailsManager::changePassword -- org.apache.commons.logging.Log::debug : this.logger.debug("No authentication manager set. Password won't be re-checked.") 
org.springframework.security.provisioning.InMemoryUserDetailsManager::changePassword -- java.util.Map::get : this.users.get(username) 
org.springframework.security.provisioning.InMemoryUserDetailsManager::changePassword -- org.springframework.util.Assert::state : Assert.state(user!=null,"Current user doesn't exist in database.") 
org.springframework.security.provisioning.InMemoryUserDetailsManager::updatePassword -- org.springframework.security.core.userdetails.UserDetails::getUsername : user.getUsername() 
org.springframework.security.provisioning.InMemoryUserDetailsManager::updatePassword -- java.util.Map::get : this.users.get(username.toLowerCase(Locale.ROOT)) 
org.springframework.security.provisioning.InMemoryUserDetailsManager::loadUserByUsername -- java.util.Map::get : this.users.get(username.toLowerCase(Locale.ROOT)) 
org.springframework.security.provisioning.InMemoryUserDetailsManager::loadUserByUsername -- java.lang.String::toLowerCase : username.toLowerCase(Locale.ROOT) 
org.springframework.security.provisioning.InMemoryUserDetailsManager::setSecurityContextHolderStrategy -- org.springframework.util.Assert::notNull : Assert.notNull(securityContextHolderStrategy,"securityContextHolderStrategy cannot be null") 
class JdbcUserDetailsManager extends org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl implements org.springframework.security.provisioning.UserDetailsManager,GroupManager  {
  DEF_CREATE_USER_SQL : java.lang.String
  DEF_DELETE_USER_SQL : java.lang.String
  DEF_UPDATE_USER_SQL : java.lang.String
  DEF_INSERT_AUTHORITY_SQL : java.lang.String
  DEF_DELETE_USER_AUTHORITIES_SQL : java.lang.String
  DEF_USER_EXISTS_SQL : java.lang.String
  DEF_CHANGE_PASSWORD_SQL : java.lang.String
  DEF_FIND_GROUPS_SQL : java.lang.String
  DEF_FIND_USERS_IN_GROUP_SQL : java.lang.String
  DEF_INSERT_GROUP_SQL : java.lang.String
  DEF_FIND_GROUP_ID_SQL : java.lang.String
  DEF_INSERT_GROUP_AUTHORITY_SQL : java.lang.String
  DEF_DELETE_GROUP_SQL : java.lang.String
  DEF_DELETE_GROUP_AUTHORITIES_SQL : java.lang.String
  DEF_DELETE_GROUP_MEMBERS_SQL : java.lang.String
  DEF_RENAME_GROUP_SQL : java.lang.String
  DEF_INSERT_GROUP_MEMBER_SQL : java.lang.String
  DEF_DELETE_GROUP_MEMBER_SQL : java.lang.String
  DEF_GROUP_AUTHORITIES_QUERY_SQL : java.lang.String
  DEF_DELETE_GROUP_AUTHORITY_SQL : java.lang.String
  logger : org.apache.commons.logging.Log
  securityContextHolderStrategy : org.springframework.security.core.context.SecurityContextHolderStrategy
  createUserSql : java.lang.String
  deleteUserSql : java.lang.String
  updateUserSql : java.lang.String
  createAuthoritySql : java.lang.String
  deleteUserAuthoritiesSql : java.lang.String
  userExistsSql : java.lang.String
  changePasswordSql : java.lang.String
  findAllGroupsSql : java.lang.String
  findUsersInGroupSql : java.lang.String
  insertGroupSql : java.lang.String
  findGroupIdSql : java.lang.String
  insertGroupAuthoritySql : java.lang.String
  deleteGroupSql : java.lang.String
  deleteGroupAuthoritiesSql : java.lang.String
  deleteGroupMembersSql : java.lang.String
  renameGroupSql : java.lang.String
  insertGroupMemberSql : java.lang.String
  deleteGroupMemberSql : java.lang.String
  groupAuthoritiesSql : java.lang.String
  deleteGroupAuthoritySql : java.lang.String
  authenticationManager : org.springframework.security.authentication.AuthenticationManager
  userCache : org.springframework.security.core.userdetails.UserCache
  userDetailsMapper : org.springframework.jdbc.core.RowMapper
  grantedAuthorityMapper : org.springframework.jdbc.core.RowMapper
  JdbcUserDetailsManager() : None
  JdbcUserDetailsManager(dataSource : javax.sql.DataSource) : None
  setUserDetailsMapper(mapper : org.springframework.jdbc.core.RowMapper) : void
  setGrantedAuthorityMapper(mapper : org.springframework.jdbc.core.RowMapper) : void
  initDao() : void
  loadUsersByUsername(username : java.lang.String) : java.util.List
  mapToUser(rs : java.sql.ResultSet, rowNum : int) : org.springframework.security.core.userdetails.UserDetails
  createUser(user : org.springframework.security.core.userdetails.UserDetails) : void
  updateUser(user : org.springframework.security.core.userdetails.UserDetails) : void
  insertUserAuthorities(user : org.springframework.security.core.userdetails.UserDetails) : void
  deleteUser(username : java.lang.String) : void
  deleteUserAuthorities(username : java.lang.String) : void
  changePassword(oldPassword : java.lang.String, newPassword : java.lang.String) : void
  createNewAuthentication(currentAuth : org.springframework.security.core.Authentication, newPassword : java.lang.String) : org.springframework.security.core.Authentication
  userExists(username : java.lang.String) : boolean
  findAllGroups() : java.util.List
  findUsersInGroup(groupName : java.lang.String) : java.util.List
  createGroup(groupName : java.lang.String, authorities : java.util.List) : void
  deleteGroup(groupName : java.lang.String) : void
  renameGroup(oldName : java.lang.String, newName : java.lang.String) : void
  addUserToGroup(username : java.lang.String, groupName : java.lang.String) : void
  removeUserFromGroup(username : java.lang.String, groupName : java.lang.String) : void
  findGroupAuthorities(groupName : java.lang.String) : java.util.List
  mapToGrantedAuthority(rs : java.sql.ResultSet, rowNum : int) : org.springframework.security.core.GrantedAuthority
  removeGroupAuthority(groupName : java.lang.String, authority : org.springframework.security.core.GrantedAuthority) : void
  addGroupAuthority(groupName : java.lang.String, authority : org.springframework.security.core.GrantedAuthority) : void
  findGroupId(group : java.lang.String) : int
  setSecurityContextHolderStrategy(securityContextHolderStrategy : org.springframework.security.core.context.SecurityContextHolderStrategy) : void
  setAuthenticationManager(authenticationManager : org.springframework.security.authentication.AuthenticationManager) : void
  setCreateUserSql(createUserSql : java.lang.String) : void
  setDeleteUserSql(deleteUserSql : java.lang.String) : void
  setUpdateUserSql(updateUserSql : java.lang.String) : void
  setCreateAuthoritySql(createAuthoritySql : java.lang.String) : void
  setDeleteUserAuthoritiesSql(deleteUserAuthoritiesSql : java.lang.String) : void
  setUserExistsSql(userExistsSql : java.lang.String) : void
  setChangePasswordSql(changePasswordSql : java.lang.String) : void
  setFindAllGroupsSql(findAllGroupsSql : java.lang.String) : void
  setFindUsersInGroupSql(findUsersInGroupSql : java.lang.String) : void
  setInsertGroupSql(insertGroupSql : java.lang.String) : void
  setFindGroupIdSql(findGroupIdSql : java.lang.String) : void
  setInsertGroupAuthoritySql(insertGroupAuthoritySql : java.lang.String) : void
  setDeleteGroupSql(deleteGroupSql : java.lang.String) : void
  setDeleteGroupAuthoritiesSql(deleteGroupAuthoritiesSql : java.lang.String) : void
  setDeleteGroupMembersSql(deleteGroupMembersSql : java.lang.String) : void
  setRenameGroupSql(renameGroupSql : java.lang.String) : void
  setInsertGroupMemberSql(insertGroupMemberSql : java.lang.String) : void
  setDeleteGroupMemberSql(deleteGroupMemberSql : java.lang.String) : void
  setGroupAuthoritiesSql(groupAuthoritiesSql : java.lang.String) : void
  setDeleteGroupAuthoritySql(deleteGroupAuthoritySql : java.lang.String) : void
  setUserCache(userCache : org.springframework.security.core.userdetails.UserCache) : void
  validateUserDetails(user : org.springframework.security.core.userdetails.UserDetails) : void
  validateAuthorities(authorities : java.util.Collection) : void
}
org.springframework.security.provisioning.JdbcUserDetailsManager::setUserDetailsMapper -- org.springframework.util.Assert::notNull : Assert.notNull(mapper,"userDetailsMapper cannot be null") 
org.springframework.security.provisioning.JdbcUserDetailsManager::setGrantedAuthorityMapper -- org.springframework.util.Assert::notNull : Assert.notNull(mapper,"grantedAuthorityMapper cannot be null") 
org.springframework.security.provisioning.JdbcUserDetailsManager::initDao -- org.apache.commons.logging.Log::info : this.logger.info("No authentication manager set. Reauthentication of users when changing passwords will not be performed.") 
org.springframework.security.provisioning.JdbcUserDetailsManager::loadUsersByUsername -- org.springframework.security.provisioning.JdbcUserDetailsManager::getJdbcTemplate : getJdbcTemplate().query(getUsersByUsernameQuery(),this.userDetailsMapper,username) 
org.springframework.security.provisioning.JdbcUserDetailsManager::mapToUser -- java.sql.ResultSet::getString : rs.getString(1) 
org.springframework.security.provisioning.JdbcUserDetailsManager::mapToUser -- java.sql.ResultSet::getString : rs.getString(2) 
org.springframework.security.provisioning.JdbcUserDetailsManager::mapToUser -- java.sql.ResultSet::getBoolean : rs.getBoolean(3) 
org.springframework.security.provisioning.JdbcUserDetailsManager::mapToUser -- java.sql.ResultSet::getMetaData : rs.getMetaData().getColumnCount() 
org.springframework.security.provisioning.JdbcUserDetailsManager::mapToUser -- java.sql.ResultSet::getMetaData : rs.getMetaData() 
org.springframework.security.provisioning.JdbcUserDetailsManager::mapToUser -- java.sql.ResultSet::getBoolean : rs.getBoolean(4) 
org.springframework.security.provisioning.JdbcUserDetailsManager::mapToUser -- java.sql.ResultSet::getBoolean : rs.getBoolean(5) 
org.springframework.security.provisioning.JdbcUserDetailsManager::mapToUser -- java.sql.ResultSet::getBoolean : rs.getBoolean(6) 
org.springframework.security.provisioning.JdbcUserDetailsManager::createUser -- org.springframework.security.provisioning.JdbcUserDetailsManager::getJdbcTemplate : getJdbcTemplate().update(this.createUserSql,(ps)->{ps.setString(1,user.getUsername());ps.setString(2,user.getPassword());ps.setBoolean(3,user.isEnabled());intparamCount=ps.getParameterMetaData().getParameterCount();if(paramCount>3){ps.setBoolean(4,!user.isAccountNonLocked());ps.setBoolean(5,!user.isAccountNonExpired());ps.setBoolean(6,!user.isCredentialsNonExpired());}}) 
org.springframework.security.provisioning.JdbcUserDetailsManager::createUser -- org.springframework.security.core.userdetails.UserDetails::getUsername : user.getUsername() 
org.springframework.security.provisioning.JdbcUserDetailsManager::createUser -- org.springframework.security.core.userdetails.UserDetails::getPassword : user.getPassword() 
org.springframework.security.provisioning.JdbcUserDetailsManager::createUser -- org.springframework.security.core.userdetails.UserDetails::isEnabled : user.isEnabled() 
org.springframework.security.provisioning.JdbcUserDetailsManager::createUser -- org.springframework.security.core.userdetails.UserDetails::isAccountNonLocked : user.isAccountNonLocked() 
org.springframework.security.provisioning.JdbcUserDetailsManager::createUser -- org.springframework.security.core.userdetails.UserDetails::isAccountNonExpired : user.isAccountNonExpired() 
org.springframework.security.provisioning.JdbcUserDetailsManager::createUser -- org.springframework.security.core.userdetails.UserDetails::isCredentialsNonExpired : user.isCredentialsNonExpired() 
org.springframework.security.provisioning.JdbcUserDetailsManager::updateUser -- org.springframework.security.provisioning.JdbcUserDetailsManager::getJdbcTemplate : getJdbcTemplate().update(this.updateUserSql,(ps)->{ps.setString(1,user.getPassword());ps.setBoolean(2,user.isEnabled());intparamCount=ps.getParameterMetaData().getParameterCount();if(paramCount==3){ps.setString(3,user.getUsername());}else{ps.setBoolean(3,!user.isAccountNonLocked());ps.setBoolean(4,!user.isAccountNonExpired());ps.setBoolean(5,!user.isCredentialsNonExpired());ps.setString(6,user.getUsername());}}) 
org.springframework.security.provisioning.JdbcUserDetailsManager::updateUser -- org.springframework.security.core.userdetails.UserDetails::getPassword : user.getPassword() 
org.springframework.security.provisioning.JdbcUserDetailsManager::updateUser -- org.springframework.security.core.userdetails.UserDetails::isEnabled : user.isEnabled() 
org.springframework.security.provisioning.JdbcUserDetailsManager::updateUser -- org.springframework.security.core.userdetails.UserDetails::getUsername : user.getUsername() 
org.springframework.security.provisioning.JdbcUserDetailsManager::updateUser -- org.springframework.security.core.userdetails.UserDetails::isAccountNonLocked : user.isAccountNonLocked() 
org.springframework.security.provisioning.JdbcUserDetailsManager::updateUser -- org.springframework.security.core.userdetails.UserDetails::isAccountNonExpired : user.isAccountNonExpired() 
org.springframework.security.provisioning.JdbcUserDetailsManager::updateUser -- org.springframework.security.core.userdetails.UserDetails::isCredentialsNonExpired : user.isCredentialsNonExpired() 
org.springframework.security.provisioning.JdbcUserDetailsManager::updateUser -- org.springframework.security.core.userdetails.UserDetails::getUsername : user.getUsername() 
org.springframework.security.provisioning.JdbcUserDetailsManager::updateUser -- org.springframework.security.core.userdetails.UserDetails::getUsername : user.getUsername() 
org.springframework.security.provisioning.JdbcUserDetailsManager::updateUser -- org.springframework.security.core.userdetails.UserCache::removeUserFromCache : this.userCache.removeUserFromCache(user.getUsername()) 
org.springframework.security.provisioning.JdbcUserDetailsManager::updateUser -- org.springframework.security.core.userdetails.UserDetails::getUsername : user.getUsername() 
org.springframework.security.provisioning.JdbcUserDetailsManager::insertUserAuthorities -- org.springframework.security.core.userdetails.UserDetails::getAuthorities : user.getAuthorities() 
org.springframework.security.provisioning.JdbcUserDetailsManager::insertUserAuthorities -- org.springframework.security.provisioning.JdbcUserDetailsManager::getJdbcTemplate : getJdbcTemplate().update(this.createAuthoritySql,user.getUsername(),auth.getAuthority()) 
org.springframework.security.provisioning.JdbcUserDetailsManager::insertUserAuthorities -- org.springframework.security.core.userdetails.UserDetails::getUsername : user.getUsername() 
org.springframework.security.provisioning.JdbcUserDetailsManager::deleteUser -- org.springframework.security.provisioning.JdbcUserDetailsManager::getJdbcTemplate : getJdbcTemplate().update(this.deleteUserSql,username) 
org.springframework.security.provisioning.JdbcUserDetailsManager::deleteUser -- org.springframework.security.core.userdetails.UserCache::removeUserFromCache : this.userCache.removeUserFromCache(username) 
org.springframework.security.provisioning.JdbcUserDetailsManager::deleteUserAuthorities -- org.springframework.security.provisioning.JdbcUserDetailsManager::getJdbcTemplate : getJdbcTemplate().update(this.deleteUserAuthoritiesSql,username) 
org.springframework.security.provisioning.JdbcUserDetailsManager::changePassword -- org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : this.securityContextHolderStrategy.getContext().getAuthentication() 
org.springframework.security.provisioning.JdbcUserDetailsManager::changePassword -- org.springframework.security.core.context.SecurityContextHolderStrategy::getContext : this.securityContextHolderStrategy.getContext() 
org.springframework.security.provisioning.JdbcUserDetailsManager::changePassword -- org.apache.commons.logging.Log::debug : this.logger.debug(LogMessage.format("Reauthenticating user '%s' for password change request.",username)) 
org.springframework.security.provisioning.JdbcUserDetailsManager::changePassword -- org.springframework.core.log.LogMessage::format : LogMessage.format("Reauthenticating user '%s' for password change request.",username) 
org.springframework.security.provisioning.JdbcUserDetailsManager::changePassword -- org.springframework.security.authentication.AuthenticationManager::authenticate : this.authenticationManager.authenticate(UsernamePasswordAuthenticationToken.unauthenticated(username,oldPassword)) 
org.springframework.security.provisioning.JdbcUserDetailsManager::changePassword -- org.springframework.security.authentication.UsernamePasswordAuthenticationToken::unauthenticated : UsernamePasswordAuthenticationToken.unauthenticated(username,oldPassword) 
org.springframework.security.provisioning.JdbcUserDetailsManager::changePassword -- org.apache.commons.logging.Log::debug : this.logger.debug("No authentication manager set. Password won't be re-checked.") 
org.springframework.security.provisioning.JdbcUserDetailsManager::changePassword -- org.apache.commons.logging.Log::debug : this.logger.debug("Changing password for user '"+username+"'") 
org.springframework.security.provisioning.JdbcUserDetailsManager::changePassword -- org.springframework.security.provisioning.JdbcUserDetailsManager::getJdbcTemplate : getJdbcTemplate().update(this.changePasswordSql,newPassword,username) 
org.springframework.security.provisioning.JdbcUserDetailsManager::changePassword -- org.springframework.security.core.context.SecurityContextHolderStrategy::createEmptyContext : this.securityContextHolderStrategy.createEmptyContext() 
org.springframework.security.provisioning.JdbcUserDetailsManager::changePassword -- org.springframework.security.core.context.SecurityContextHolderStrategy::setContext : this.securityContextHolderStrategy.setContext(context) 
org.springframework.security.provisioning.JdbcUserDetailsManager::changePassword -- org.springframework.security.core.userdetails.UserCache::removeUserFromCache : this.userCache.removeUserFromCache(username) 
org.springframework.security.provisioning.JdbcUserDetailsManager::createNewAuthentication -- org.springframework.security.core.Authentication::getName : currentAuth.getName() 
org.springframework.security.provisioning.JdbcUserDetailsManager::createNewAuthentication -- org.springframework.security.authentication.UsernamePasswordAuthenticationToken::authenticated : UsernamePasswordAuthenticationToken.authenticated(user,null,user.getAuthorities()) 
org.springframework.security.provisioning.JdbcUserDetailsManager::createNewAuthentication -- org.springframework.security.core.Authentication::getDetails : currentAuth.getDetails() 
org.springframework.security.provisioning.JdbcUserDetailsManager::userExists -- org.springframework.security.provisioning.JdbcUserDetailsManager::getJdbcTemplate : getJdbcTemplate().queryForList(this.userExistsSql,newString[]{username},String.class) 
org.springframework.security.provisioning.JdbcUserDetailsManager::findAllGroups -- org.springframework.security.provisioning.JdbcUserDetailsManager::getJdbcTemplate : getJdbcTemplate().queryForList(this.findAllGroupsSql,String.class) 
org.springframework.security.provisioning.JdbcUserDetailsManager::findUsersInGroup -- org.springframework.util.Assert::hasText : Assert.hasText(groupName,"groupName should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::findUsersInGroup -- org.springframework.security.provisioning.JdbcUserDetailsManager::getJdbcTemplate : getJdbcTemplate().queryForList(this.findUsersInGroupSql,newString[]{groupName},String.class) 
org.springframework.security.provisioning.JdbcUserDetailsManager::createGroup -- org.springframework.util.Assert::hasText : Assert.hasText(groupName,"groupName should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::createGroup -- org.springframework.util.Assert::notNull : Assert.notNull(authorities,"authorities cannot be null") 
org.springframework.security.provisioning.JdbcUserDetailsManager::createGroup -- org.apache.commons.logging.Log::debug : this.logger.debug("Creating new group '"+groupName+"' with authorities "+AuthorityUtils.authorityListToSet(authorities)) 
org.springframework.security.provisioning.JdbcUserDetailsManager::createGroup -- org.springframework.security.core.authority.AuthorityUtils::authorityListToSet : AuthorityUtils.authorityListToSet(authorities) 
org.springframework.security.provisioning.JdbcUserDetailsManager::createGroup -- org.springframework.security.provisioning.JdbcUserDetailsManager::getJdbcTemplate : getJdbcTemplate().update(this.insertGroupSql,groupName) 
org.springframework.security.provisioning.JdbcUserDetailsManager::createGroup -- org.springframework.security.provisioning.JdbcUserDetailsManager::getJdbcTemplate : getJdbcTemplate().update(this.insertGroupAuthoritySql,(ps)->{ps.setInt(1,groupId);ps.setString(2,authority);}) 
org.springframework.security.provisioning.JdbcUserDetailsManager::deleteGroup -- org.apache.commons.logging.Log::debug : this.logger.debug("Deleting group '"+groupName+"'") 
org.springframework.security.provisioning.JdbcUserDetailsManager::deleteGroup -- org.springframework.util.Assert::hasText : Assert.hasText(groupName,"groupName should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::deleteGroup -- org.springframework.security.provisioning.JdbcUserDetailsManager::getJdbcTemplate : getJdbcTemplate().update(this.deleteGroupMembersSql,groupIdPSS) 
org.springframework.security.provisioning.JdbcUserDetailsManager::deleteGroup -- org.springframework.security.provisioning.JdbcUserDetailsManager::getJdbcTemplate : getJdbcTemplate().update(this.deleteGroupAuthoritiesSql,groupIdPSS) 
org.springframework.security.provisioning.JdbcUserDetailsManager::deleteGroup -- org.springframework.security.provisioning.JdbcUserDetailsManager::getJdbcTemplate : getJdbcTemplate().update(this.deleteGroupSql,groupIdPSS) 
org.springframework.security.provisioning.JdbcUserDetailsManager::renameGroup -- org.apache.commons.logging.Log::debug : this.logger.debug("Changing group name from '"+oldName+"' to '"+newName+"'") 
org.springframework.security.provisioning.JdbcUserDetailsManager::renameGroup -- org.springframework.util.Assert::hasText : Assert.hasText(oldName,"oldName should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::renameGroup -- org.springframework.util.Assert::hasText : Assert.hasText(newName,"newName should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::renameGroup -- org.springframework.security.provisioning.JdbcUserDetailsManager::getJdbcTemplate : getJdbcTemplate().update(this.renameGroupSql,newName,oldName) 
org.springframework.security.provisioning.JdbcUserDetailsManager::addUserToGroup -- org.apache.commons.logging.Log::debug : this.logger.debug("Adding user '"+username+"' to group '"+groupName+"'") 
org.springframework.security.provisioning.JdbcUserDetailsManager::addUserToGroup -- org.springframework.util.Assert::hasText : Assert.hasText(username,"username should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::addUserToGroup -- org.springframework.util.Assert::hasText : Assert.hasText(groupName,"groupName should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::addUserToGroup -- org.springframework.security.provisioning.JdbcUserDetailsManager::getJdbcTemplate : getJdbcTemplate().update(this.insertGroupMemberSql,(ps)->{ps.setInt(1,id);ps.setString(2,username);}) 
org.springframework.security.provisioning.JdbcUserDetailsManager::addUserToGroup -- org.springframework.security.core.userdetails.UserCache::removeUserFromCache : this.userCache.removeUserFromCache(username) 
org.springframework.security.provisioning.JdbcUserDetailsManager::removeUserFromGroup -- org.apache.commons.logging.Log::debug : this.logger.debug("Removing user '"+username+"' to group '"+groupName+"'") 
org.springframework.security.provisioning.JdbcUserDetailsManager::removeUserFromGroup -- org.springframework.util.Assert::hasText : Assert.hasText(username,"username should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::removeUserFromGroup -- org.springframework.util.Assert::hasText : Assert.hasText(groupName,"groupName should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::removeUserFromGroup -- org.springframework.security.provisioning.JdbcUserDetailsManager::getJdbcTemplate : getJdbcTemplate().update(this.deleteGroupMemberSql,(ps)->{ps.setInt(1,id);ps.setString(2,username);}) 
org.springframework.security.provisioning.JdbcUserDetailsManager::removeUserFromGroup -- org.springframework.security.core.userdetails.UserCache::removeUserFromCache : this.userCache.removeUserFromCache(username) 
org.springframework.security.provisioning.JdbcUserDetailsManager::findGroupAuthorities -- org.apache.commons.logging.Log::debug : this.logger.debug("Loading authorities for group '"+groupName+"'") 
org.springframework.security.provisioning.JdbcUserDetailsManager::findGroupAuthorities -- org.springframework.util.Assert::hasText : Assert.hasText(groupName,"groupName should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::findGroupAuthorities -- org.springframework.security.provisioning.JdbcUserDetailsManager::getJdbcTemplate : getJdbcTemplate().query(this.groupAuthoritiesSql,newString[]{groupName},this.grantedAuthorityMapper) 
org.springframework.security.provisioning.JdbcUserDetailsManager::mapToGrantedAuthority -- java.sql.ResultSet::getString : rs.getString(3) 
org.springframework.security.provisioning.JdbcUserDetailsManager::removeGroupAuthority -- org.apache.commons.logging.Log::debug : this.logger.debug("Removing authority '"+authority+"' from group '"+groupName+"'") 
org.springframework.security.provisioning.JdbcUserDetailsManager::removeGroupAuthority -- org.springframework.util.Assert::hasText : Assert.hasText(groupName,"groupName should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::removeGroupAuthority -- org.springframework.util.Assert::notNull : Assert.notNull(authority,"authority cannot be null") 
org.springframework.security.provisioning.JdbcUserDetailsManager::removeGroupAuthority -- org.springframework.security.provisioning.JdbcUserDetailsManager::getJdbcTemplate : getJdbcTemplate().update(this.deleteGroupAuthoritySql,(ps)->{ps.setInt(1,id);ps.setString(2,authority.getAuthority());}) 
org.springframework.security.provisioning.JdbcUserDetailsManager::removeGroupAuthority -- org.springframework.security.core.GrantedAuthority::getAuthority : authority.getAuthority() 
org.springframework.security.provisioning.JdbcUserDetailsManager::addGroupAuthority -- org.apache.commons.logging.Log::debug : this.logger.debug("Adding authority '"+authority+"' to group '"+groupName+"'") 
org.springframework.security.provisioning.JdbcUserDetailsManager::addGroupAuthority -- org.springframework.util.Assert::hasText : Assert.hasText(groupName,"groupName should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::addGroupAuthority -- org.springframework.util.Assert::notNull : Assert.notNull(authority,"authority cannot be null") 
org.springframework.security.provisioning.JdbcUserDetailsManager::addGroupAuthority -- org.springframework.security.provisioning.JdbcUserDetailsManager::getJdbcTemplate : getJdbcTemplate().update(this.insertGroupAuthoritySql,(ps)->{ps.setInt(1,id);ps.setString(2,authority.getAuthority());}) 
org.springframework.security.provisioning.JdbcUserDetailsManager::addGroupAuthority -- org.springframework.security.core.GrantedAuthority::getAuthority : authority.getAuthority() 
org.springframework.security.provisioning.JdbcUserDetailsManager::findGroupId -- org.springframework.security.provisioning.JdbcUserDetailsManager::getJdbcTemplate : getJdbcTemplate().queryForObject(this.findGroupIdSql,Integer.class,group) 
org.springframework.security.provisioning.JdbcUserDetailsManager::setSecurityContextHolderStrategy -- org.springframework.util.Assert::notNull : Assert.notNull(securityContextHolderStrategy,"securityContextHolderStrategy cannot be null") 
org.springframework.security.provisioning.JdbcUserDetailsManager::setCreateUserSql -- org.springframework.util.Assert::hasText : Assert.hasText(createUserSql,"createUserSql should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::setDeleteUserSql -- org.springframework.util.Assert::hasText : Assert.hasText(deleteUserSql,"deleteUserSql should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::setUpdateUserSql -- org.springframework.util.Assert::hasText : Assert.hasText(updateUserSql,"updateUserSql should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::setCreateAuthoritySql -- org.springframework.util.Assert::hasText : Assert.hasText(createAuthoritySql,"createAuthoritySql should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::setDeleteUserAuthoritiesSql -- org.springframework.util.Assert::hasText : Assert.hasText(deleteUserAuthoritiesSql,"deleteUserAuthoritiesSql should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::setUserExistsSql -- org.springframework.util.Assert::hasText : Assert.hasText(userExistsSql,"userExistsSql should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::setChangePasswordSql -- org.springframework.util.Assert::hasText : Assert.hasText(changePasswordSql,"changePasswordSql should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::setFindAllGroupsSql -- org.springframework.util.Assert::hasText : Assert.hasText(findAllGroupsSql,"findAllGroupsSql should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::setFindUsersInGroupSql -- org.springframework.util.Assert::hasText : Assert.hasText(findUsersInGroupSql,"findUsersInGroupSql should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::setInsertGroupSql -- org.springframework.util.Assert::hasText : Assert.hasText(insertGroupSql,"insertGroupSql should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::setFindGroupIdSql -- org.springframework.util.Assert::hasText : Assert.hasText(findGroupIdSql,"findGroupIdSql should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::setInsertGroupAuthoritySql -- org.springframework.util.Assert::hasText : Assert.hasText(insertGroupAuthoritySql,"insertGroupAuthoritySql should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::setDeleteGroupSql -- org.springframework.util.Assert::hasText : Assert.hasText(deleteGroupSql,"deleteGroupSql should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::setDeleteGroupAuthoritiesSql -- org.springframework.util.Assert::hasText : Assert.hasText(deleteGroupAuthoritiesSql,"deleteGroupAuthoritiesSql should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::setDeleteGroupMembersSql -- org.springframework.util.Assert::hasText : Assert.hasText(deleteGroupMembersSql,"deleteGroupMembersSql should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::setRenameGroupSql -- org.springframework.util.Assert::hasText : Assert.hasText(renameGroupSql,"renameGroupSql should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::setInsertGroupMemberSql -- org.springframework.util.Assert::hasText : Assert.hasText(insertGroupMemberSql,"insertGroupMemberSql should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::setDeleteGroupMemberSql -- org.springframework.util.Assert::hasText : Assert.hasText(deleteGroupMemberSql,"deleteGroupMemberSql should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::setGroupAuthoritiesSql -- org.springframework.util.Assert::hasText : Assert.hasText(groupAuthoritiesSql,"groupAuthoritiesSql should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::setDeleteGroupAuthoritySql -- org.springframework.util.Assert::hasText : Assert.hasText(deleteGroupAuthoritySql,"deleteGroupAuthoritySql should have text") 
org.springframework.security.provisioning.JdbcUserDetailsManager::setUserCache -- org.springframework.util.Assert::notNull : Assert.notNull(userCache,"userCache cannot be null") 
org.springframework.security.provisioning.JdbcUserDetailsManager::validateUserDetails -- org.springframework.util.Assert::hasText : Assert.hasText(user.getUsername(),"Username may not be empty or null") 
org.springframework.security.provisioning.JdbcUserDetailsManager::validateUserDetails -- org.springframework.security.core.userdetails.UserDetails::getUsername : user.getUsername() 
org.springframework.security.provisioning.JdbcUserDetailsManager::validateUserDetails -- org.springframework.security.core.userdetails.UserDetails::getAuthorities : user.getAuthorities() 
org.springframework.security.provisioning.JdbcUserDetailsManager::validateAuthorities -- org.springframework.util.Assert::notNull : Assert.notNull(authorities,"Authorities list must not be null") 
org.springframework.security.provisioning.JdbcUserDetailsManager::validateAuthorities -- org.springframework.util.Assert::notNull : Assert.notNull(authority,"Authorities list contains a null entry") 
org.springframework.security.provisioning.JdbcUserDetailsManager::validateAuthorities -- org.springframework.util.Assert::hasText : Assert.hasText(authority.getAuthority(),"getAuthority() method must return a non-empty string") 
class MutableUser  implements org.springframework.security.provisioning.MutableUserDetails  {
  serialVersionUID : long
  password : java.lang.String
  delegate : org.springframework.security.core.userdetails.UserDetails
  MutableUser(user : org.springframework.security.core.userdetails.UserDetails) : None
  getPassword() : java.lang.String
  setPassword(password : java.lang.String) : void
  getAuthorities() : java.util.Collection
  getUsername() : java.lang.String
  isAccountNonExpired() : boolean
  isAccountNonLocked() : boolean
  isCredentialsNonExpired() : boolean
  isEnabled() : boolean
}
org.springframework.security.provisioning.MutableUser::MutableUser -- org.springframework.security.core.userdetails.UserDetails::getPassword : user.getPassword() 
org.springframework.security.provisioning.MutableUser::getAuthorities -- org.springframework.security.core.userdetails.UserDetails::getAuthorities : this.delegate.getAuthorities() 
org.springframework.security.provisioning.MutableUser::getUsername -- org.springframework.security.core.userdetails.UserDetails::getUsername : this.delegate.getUsername() 
org.springframework.security.provisioning.MutableUser::isAccountNonExpired -- org.springframework.security.core.userdetails.UserDetails::isAccountNonExpired : this.delegate.isAccountNonExpired() 
org.springframework.security.provisioning.MutableUser::isAccountNonLocked -- org.springframework.security.core.userdetails.UserDetails::isAccountNonLocked : this.delegate.isAccountNonLocked() 
org.springframework.security.provisioning.MutableUser::isCredentialsNonExpired -- org.springframework.security.core.userdetails.UserDetails::isCredentialsNonExpired : this.delegate.isCredentialsNonExpired() 
org.springframework.security.provisioning.MutableUser::isEnabled -- org.springframework.security.core.userdetails.UserDetails::isEnabled : this.delegate.isEnabled() 
interface MutableUserDetails    {
  setPassword(password : java.lang.String) : void
}
interface UserDetailsManager    {
  createUser(user : org.springframework.security.core.userdetails.UserDetails) : void
  updateUser(user : org.springframework.security.core.userdetails.UserDetails) : void
  deleteUser(username : java.lang.String) : void
  changePassword(oldPassword : java.lang.String, newPassword : java.lang.String) : void
  userExists(username : java.lang.String) : boolean
}
}
package scheduling {
class DelegatingSecurityContextSchedulingTaskExecutor extends org.springframework.security.task.DelegatingSecurityContextAsyncTaskExecutor implements org.springframework.scheduling.SchedulingTaskExecutor  {
  DelegatingSecurityContextSchedulingTaskExecutor(delegateSchedulingTaskExecutor : org.springframework.scheduling.SchedulingTaskExecutor, securityContext : org.springframework.security.core.context.SecurityContext) : None
  DelegatingSecurityContextSchedulingTaskExecutor(delegateAsyncTaskExecutor : org.springframework.scheduling.SchedulingTaskExecutor) : None
  prefersShortLivedTasks() : boolean
  getDelegate() : org.springframework.scheduling.SchedulingTaskExecutor
}
org.springframework.security.scheduling.DelegatingSecurityContextSchedulingTaskExecutor::prefersShortLivedTasks -- org.springframework.security.scheduling.DelegatingSecurityContextSchedulingTaskExecutor::getDelegate : getDelegate().prefersShortLivedTasks() 
class DelegatingSecurityContextTaskScheduler  implements org.springframework.scheduling.TaskScheduler  {
  delegate : org.springframework.scheduling.TaskScheduler
  securityContext : org.springframework.security.core.context.SecurityContext
  DelegatingSecurityContextTaskScheduler(delegateTaskScheduler : org.springframework.scheduling.TaskScheduler, securityContext : org.springframework.security.core.context.SecurityContext) : None
  DelegatingSecurityContextTaskScheduler(delegate : org.springframework.scheduling.TaskScheduler) : None
  schedule(task : org.springframework.security.scheduling.Runnable, trigger : org.springframework.scheduling.Trigger) : java.util.concurrent.ScheduledFuture
  schedule(task : org.springframework.security.scheduling.Runnable, startTime : java.util.Date) : java.util.concurrent.ScheduledFuture
  scheduleAtFixedRate(task : org.springframework.security.scheduling.Runnable, startTime : java.util.Date, period : long) : java.util.concurrent.ScheduledFuture
  scheduleAtFixedRate(task : org.springframework.security.scheduling.Runnable, period : long) : java.util.concurrent.ScheduledFuture
  scheduleWithFixedDelay(task : org.springframework.security.scheduling.Runnable, startTime : java.util.Date, delay : long) : java.util.concurrent.ScheduledFuture
  scheduleWithFixedDelay(task : org.springframework.security.scheduling.Runnable, delay : long) : java.util.concurrent.ScheduledFuture
  schedule(task : org.springframework.security.scheduling.Runnable, startTime : java.time.Instant) : java.util.concurrent.ScheduledFuture
  scheduleAtFixedRate(task : org.springframework.security.scheduling.Runnable, startTime : java.time.Instant, period : java.time.Duration) : java.util.concurrent.ScheduledFuture
  scheduleAtFixedRate(task : org.springframework.security.scheduling.Runnable, period : java.time.Duration) : java.util.concurrent.ScheduledFuture
  scheduleWithFixedDelay(task : org.springframework.security.scheduling.Runnable, startTime : java.time.Instant, delay : java.time.Duration) : java.util.concurrent.ScheduledFuture
  scheduleWithFixedDelay(task : org.springframework.security.scheduling.Runnable, delay : java.time.Duration) : java.util.concurrent.ScheduledFuture
  getClock() : java.time.Clock
  wrap(delegate : org.springframework.security.scheduling.Runnable) : org.springframework.security.scheduling.Runnable
}
org.springframework.security.scheduling.DelegatingSecurityContextTaskScheduler::DelegatingSecurityContextTaskScheduler -- org.springframework.util.Assert::notNull : Assert.notNull(delegateTaskScheduler,"delegateTaskScheduler cannot be null") 
org.springframework.security.scheduling.DelegatingSecurityContextTaskScheduler::schedule -- org.springframework.scheduling.TaskScheduler::schedule : this.delegate.schedule(wrap(task),trigger) 
org.springframework.security.scheduling.DelegatingSecurityContextTaskScheduler::schedule -- org.springframework.scheduling.TaskScheduler::schedule : this.delegate.schedule(wrap(task),startTime) 
org.springframework.security.scheduling.DelegatingSecurityContextTaskScheduler::scheduleAtFixedRate -- org.springframework.scheduling.TaskScheduler::scheduleAtFixedRate : this.delegate.scheduleAtFixedRate(wrap(task),startTime,period) 
org.springframework.security.scheduling.DelegatingSecurityContextTaskScheduler::scheduleAtFixedRate -- org.springframework.scheduling.TaskScheduler::scheduleAtFixedRate : this.delegate.scheduleAtFixedRate(wrap(task),period) 
org.springframework.security.scheduling.DelegatingSecurityContextTaskScheduler::scheduleWithFixedDelay -- org.springframework.scheduling.TaskScheduler::scheduleWithFixedDelay : this.delegate.scheduleWithFixedDelay(wrap(task),startTime,delay) 
org.springframework.security.scheduling.DelegatingSecurityContextTaskScheduler::scheduleWithFixedDelay -- org.springframework.scheduling.TaskScheduler::scheduleWithFixedDelay : this.delegate.scheduleWithFixedDelay(wrap(task),delay) 
org.springframework.security.scheduling.DelegatingSecurityContextTaskScheduler::schedule -- org.springframework.scheduling.TaskScheduler::schedule : this.delegate.schedule(wrap(task),startTime) 
org.springframework.security.scheduling.DelegatingSecurityContextTaskScheduler::scheduleAtFixedRate -- org.springframework.scheduling.TaskScheduler::scheduleAtFixedRate : this.delegate.scheduleAtFixedRate(wrap(task),startTime,period) 
org.springframework.security.scheduling.DelegatingSecurityContextTaskScheduler::scheduleAtFixedRate -- org.springframework.scheduling.TaskScheduler::scheduleAtFixedRate : this.delegate.scheduleAtFixedRate(wrap(task),period) 
org.springframework.security.scheduling.DelegatingSecurityContextTaskScheduler::scheduleWithFixedDelay -- org.springframework.scheduling.TaskScheduler::scheduleWithFixedDelay : this.delegate.scheduleWithFixedDelay(wrap(task),startTime,delay) 
org.springframework.security.scheduling.DelegatingSecurityContextTaskScheduler::scheduleWithFixedDelay -- org.springframework.scheduling.TaskScheduler::scheduleWithFixedDelay : this.delegate.scheduleWithFixedDelay(wrap(task),delay) 
org.springframework.security.scheduling.DelegatingSecurityContextTaskScheduler::getClock -- org.springframework.scheduling.TaskScheduler::getClock : this.delegate.getClock() 
org.springframework.security.scheduling.DelegatingSecurityContextTaskScheduler::wrap -- org.springframework.security.concurrent.DelegatingSecurityContextRunnable::create : DelegatingSecurityContextRunnable.create(delegate,this.securityContext) 
}
package task {
class DelegatingSecurityContextAsyncTaskExecutor extends org.springframework.security.task.DelegatingSecurityContextTaskExecutor implements org.springframework.core.task.AsyncTaskExecutor  {
  DelegatingSecurityContextAsyncTaskExecutor(delegateAsyncTaskExecutor : org.springframework.core.task.AsyncTaskExecutor, securityContext : org.springframework.security.core.context.SecurityContext) : None
  DelegatingSecurityContextAsyncTaskExecutor(delegateAsyncTaskExecutor : org.springframework.core.task.AsyncTaskExecutor) : None
  execute(task : org.springframework.security.task.Runnable, startTimeout : long) : void
  submit(task : org.springframework.security.task.Runnable) : java.util.concurrent.Future
  submit(task : java.util.concurrent.Callable) : java.util.concurrent.Future
  getDelegate() : org.springframework.core.task.AsyncTaskExecutor
}
org.springframework.security.task.DelegatingSecurityContextAsyncTaskExecutor::execute -- org.springframework.security.task.DelegatingSecurityContextAsyncTaskExecutor::getDelegate : getDelegate().execute(wrap(task),startTimeout) 
org.springframework.security.task.DelegatingSecurityContextAsyncTaskExecutor::submit -- org.springframework.security.task.DelegatingSecurityContextAsyncTaskExecutor::getDelegate : getDelegate().submit(wrap(task)) 
org.springframework.security.task.DelegatingSecurityContextAsyncTaskExecutor::submit -- org.springframework.security.task.DelegatingSecurityContextAsyncTaskExecutor::getDelegate : getDelegate().submit(wrap(task)) 
class DelegatingSecurityContextTaskExecutor extends org.springframework.security.concurrent.DelegatingSecurityContextExecutor implements org.springframework.core.task.TaskExecutor  {
  DelegatingSecurityContextTaskExecutor(delegateTaskExecutor : org.springframework.core.task.TaskExecutor, securityContext : org.springframework.security.core.context.SecurityContext) : None
  DelegatingSecurityContextTaskExecutor(delegate : org.springframework.core.task.TaskExecutor) : None
}
}
package util {
class FieldUtils    {
  FieldUtils() : None
  getField(clazz : java.lang.Class, fieldName : java.lang.String) : java.lang.reflect.Field
  getFieldValue(bean : java.lang.Object, fieldName : java.lang.String) : java.lang.Object
  getProtectedFieldValue(protectedField : java.lang.String, object : java.lang.Object) : java.lang.Object
  setProtectedFieldValue(protectedField : java.lang.String, object : java.lang.Object, newValue : java.lang.Object) : void
}
org.springframework.security.util.FieldUtils::getField -- org.springframework.util.Assert::notNull : Assert.notNull(clazz,"Class required") 
org.springframework.security.util.FieldUtils::getField -- org.springframework.util.Assert::hasText : Assert.hasText(fieldName,"Field name required") 
org.springframework.security.util.FieldUtils::getField -- java.lang.Class::getDeclaredField : clazz.getDeclaredField(fieldName) 
org.springframework.security.util.FieldUtils::getField -- java.lang.Class::getSuperclass : clazz.getSuperclass() 
org.springframework.security.util.FieldUtils::getField -- java.lang.Class::getSuperclass : clazz.getSuperclass() 
org.springframework.security.util.FieldUtils::getFieldValue -- org.springframework.util.Assert::notNull : Assert.notNull(bean,"Bean cannot be null") 
org.springframework.security.util.FieldUtils::getFieldValue -- org.springframework.util.Assert::hasText : Assert.hasText(fieldName,"Field name required") 
org.springframework.security.util.FieldUtils::getFieldValue -- org.springframework.util.StringUtils::tokenizeToStringArray : StringUtils.tokenizeToStringArray(fieldName,".") 
org.springframework.security.util.FieldUtils::getFieldValue -- java.lang.Object::getClass : bean.getClass() 
org.springframework.security.util.FieldUtils::getProtectedFieldValue -- org.springframework.security.util.FieldUtils::getField : FieldUtils.getField(object.getClass(),protectedField) 
org.springframework.security.util.FieldUtils::getProtectedFieldValue -- java.lang.Object::getClass : object.getClass() 
org.springframework.security.util.FieldUtils::getProtectedFieldValue -- org.springframework.util.ReflectionUtils::handleReflectionException : ReflectionUtils.handleReflectionException(ex) 
org.springframework.security.util.FieldUtils::setProtectedFieldValue -- org.springframework.security.util.FieldUtils::getField : FieldUtils.getField(object.getClass(),protectedField) 
org.springframework.security.util.FieldUtils::setProtectedFieldValue -- java.lang.Object::getClass : object.getClass() 
org.springframework.security.util.FieldUtils::setProtectedFieldValue -- org.springframework.util.ReflectionUtils::handleReflectionException : ReflectionUtils.handleReflectionException(ex) 
class InMemoryResource extends org.springframework.core.io.AbstractResource   {
  source : org.springframework.security.util.byte[]
  description : java.lang.String
  InMemoryResource(source : java.lang.String) : None
  InMemoryResource(source : org.springframework.security.util.byte[]) : None
  InMemoryResource(source : org.springframework.security.util.byte[], description : java.lang.String) : None
  getDescription() : java.lang.String
  getInputStream() : java.io.InputStream
  equals(res : java.lang.Object) : boolean
  hashCode() : int
}
org.springframework.security.util.InMemoryResource::InMemoryResource -- org.springframework.security.util.byte[]::getBytes : source.getBytes() 
org.springframework.security.util.InMemoryResource::InMemoryResource -- org.springframework.util.Assert::notNull : Assert.notNull(source,"source cannot be null") 
org.springframework.security.util.InMemoryResource::equals -- java.util.Arrays::equals : Arrays.equals(this.source,((InMemoryResource)res).source) 
class MethodInvocationUtils    {
  MethodInvocationUtils() : None
  create(object : java.lang.Object, methodName : java.lang.String) : org.aopalliance.intercept.MethodInvocation
  createFromClass(clazz : java.lang.Class, methodName : java.lang.String) : org.aopalliance.intercept.MethodInvocation
  createFromClass(targetObject : java.lang.Object, clazz : java.lang.Class, methodName : java.lang.String, classArgs : java.lang.Class, args : org.springframework.security.util.Object[]) : org.aopalliance.intercept.MethodInvocation
}
org.springframework.security.util.MethodInvocationUtils::create -- org.springframework.util.Assert::notNull : Assert.notNull(object,"Object required") 
org.springframework.security.util.MethodInvocationUtils::create -- org.springframework.aop.support.AopUtils::getTargetClass : AopUtils.getTargetClass(object) 
org.springframework.security.util.MethodInvocationUtils::createFromClass -- java.lang.Class::getDeclaredMethods : clazz.getDeclaredMethods() 
org.springframework.security.util.MethodInvocationUtils::createFromClass -- org.springframework.util.Assert::isTrue : Assert.isTrue(invocation==null,()->"The class "+clazz+" has more than one method named"+" '"+methodName+"'") 
org.springframework.security.util.MethodInvocationUtils::createFromClass -- org.springframework.util.Assert::notNull : Assert.notNull(clazz,"Class required") 
org.springframework.security.util.MethodInvocationUtils::createFromClass -- org.springframework.util.Assert::hasText : Assert.hasText(methodName,"MethodName required") 
org.springframework.security.util.MethodInvocationUtils::createFromClass -- java.lang.Class::getMethod : clazz.getMethod(methodName,classArgs) 
class SimpleMethodInvocation  implements org.aopalliance.intercept.MethodInvocation  {
  method : java.lang.reflect.Method
  arguments : org.springframework.security.util.Object[]
  targetObject : java.lang.Object
  SimpleMethodInvocation(targetObject : java.lang.Object, method : java.lang.reflect.Method) : None
  SimpleMethodInvocation() : None
  getArguments() : org.springframework.security.util.Object[]
  getMethod() : java.lang.reflect.Method
  getStaticPart() : java.lang.reflect.AccessibleObject
  getThis() : java.lang.Object
  proceed() : java.lang.Object
  toString() : java.lang.String
}
}
}
}
}
@enduml
